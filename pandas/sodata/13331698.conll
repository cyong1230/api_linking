How	O
to	O
apply	O
a	O
function	O
to	O
two	O
columns	O
of	O
Pandas	O
dataframe	B-API

Suppose	O
I	O
have	O
a	O
`	O
df	B-API
`	O
which	O
has	O
columns	O
of	O
`'ID	O
'	O
,	O
'	O
col_1	O
'	O
,	O
'	O
col_2	O
'`	O
.	O

And	O
I	O
define	O
a	O
function	O
:	O

`	O
f	O
=	O
lambda	O
x	O
,	O
y	O
:	O
my_function_expression	O
`	O
.	O

Now	O
I	O
want	O
to	O
apply	O
the	O
`	O
f	O
`	O
to	O
`df`'s	O
two	O
columns	O
`'col_1	O
'	O
,	O
'	O
col_2	O
'`	O
to	O
element-wise	O
calculate	O
a	O
new	O
column	O
`'col_3	O
'`	O
,	O
somewhat	O
like	O
:	O

@CODE	O

How	O
to	O
do	O
?	O

**	O
Add	O
detail	O
sample	O
as	O
below	O
***	O

@CODE	O

Here's	O
an	O
example	O
using	O
`	O
apply	O
`	O
on	O
the	O
dataframe	B-API
,	O
which	O
I	O
am	O
calling	O
with	O
`	O
axis	O
=	O
1	O
`	O
.	O

Note	O
the	O
difference	O
is	O
that	O
instead	O
of	O
trying	O
to	O
pass	O
two	O
values	O
to	O
the	O
function	O
`	O
f	O
`	O
,	O
rewrite	O
the	O
function	O
to	O
accept	O
a	O
pandas	O
Series	B-API
object	O
,	O
and	O
then	O
index	O
the	O
Series	B-API
to	O
get	O
the	O
values	O
needed	O
.	O

@CODE	O

Depending	O
on	O
your	O
use	O
case	O
,	O
it	O
is	O
sometimes	O
helpful	O
to	O
create	O
a	O
pandas	O
`	O
group	O
`	O
object	O
,	O
and	O
then	O
use	O
`	O
apply	O
`	O
on	O
the	O
group	O
.	O

The	O
way	O
you	O
have	O
written	O
f	O
it	O
needs	O
two	O
inputs	O
.	O

If	O
you	O
look	O
at	O
the	O
error	O
message	O
it	O
says	O
you	O
are	O
not	O
providing	O
two	O
inputs	O
to	O
f	O
,	O
just	O
one	O
.	O

The	O
error	O
message	O
is	O
correct	O
.	O

The	O
mismatch	O
is	O
because	O
df[['col1','col2	O
'	O
]]	O
returns	O
a	O
single	O
dataframe	B-API
with	O
two	O
columns	O
,	O
not	O
two	O
separate	O
columns	O
.	O

You	O
need	O
to	O
change	O
your	O
f	O
so	O
that	O
it	O
takes	O
a	O
single	O
input	O
,	O
keep	O
the	O
above	O
data	O
frame	O
as	O
input	O
,	O
then	O
break	O
it	O
up	O
into	O
x	O
,	O
y	O
inside	O
the	O
function	O
body	O
.	O

Then	O
do	O
whatever	O
you	O
need	O
and	O
return	O
a	O
single	O
value	O
.	O

You	O
need	O
this	O
function	O
signature	O
because	O
the	O
syntax	O
is	O
.apply	O
(	O
f	O
)	O

So	O
f	O
needs	O
to	O
take	O
the	O
single	O
thing	O
=	O
dataframe	B-API
and	O
not	O
two	O
things	O
which	O
is	O
what	O
your	O
current	O
f	O
expects	O
.	O

Since	O
you	O
haven't	O
provided	O
the	O
body	O
of	O
f	O
I	O
can't	O
help	O
in	O
anymore	O
detail	O
-	O
but	O
this	O
should	O
provide	O
the	O
way	O
out	O
without	O
fundamentally	O
changing	O
your	O
code	O
or	O
using	O
some	O
other	O
methods	O
rather	O
than	O
apply	O

The	O
method	O
you	O
are	O
looking	O
for	O
is	O
Series.combine	B-API
.	O

However	O
,	O
it	O
seems	O
some	O
care	O
has	O
to	O
be	O
taken	O
around	O
datatypes	O
.	O

In	O
your	O
example	O
,	O
you	O
would	O
(	O
as	O
I	O
did	O
when	O
testing	O
the	O
answer	O
)	O
naively	O
call	O

@CODE	O

However	O
,	O
this	O
throws	O
the	O
error	O
:	O

@CODE	O

My	O
best	O
guess	O
is	O
that	O
it	O
seems	O
to	O
expect	O
the	O
result	O
to	O
be	O
of	O
the	O
same	O
type	O
as	O
the	O
series	O
calling	O
the	O
method	O
(	O
df.col_1	O
here	O
)	O
.	O

However	O
,	O
the	O
following	O
works	O
:	O

@CODE	O

A	O
interesting	O
question	O
!	O

my	O
answer	O
as	O
below	O
:	O

@CODE	O

Output	O
:	O

@CODE	O

I	O
changed	O
the	O
column	O
name	O
to	O
ID	O
,	O
J1	O
,	O
J2	O
,	O
J3	O
to	O
ensure	O
ID	O
J1	O
J2	O
J3	O
,	O
so	O
the	O
column	O
display	O
in	O
right	O
sequence	O
.	O

One	O
more	O
brief	O
version	O
:	O

@CODE	O
