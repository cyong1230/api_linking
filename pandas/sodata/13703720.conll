Converting	O
between	O
datetime	O
,	O
Timestamp	O
and	O
datetime64	O

How	O
do	O
I	O
convert	O
a	O
`	O
numpy.datetime64	O
`	O
object	O
to	O
a	O
`	O
datetime.datetime	O
`	O
(	O
or	O
`	O
Timestamp	O
`)	O
?	O

In	O
the	O
following	O
code	O
,	O
I	O
create	O
a	O
datetime	O
,	O
timestamp	O
and	O
datetime64	O
objects	O
.	O

@CODE	O

Note	O
:	O
it's	O
easy	O
to	O
get	O
the	O
datetime	O
from	O
the	O
Timestamp	O
:	O

@CODE	O

But	O
how	O
do	O
we	O
extract	O
the	O
`	O
datetime	O
`	O
or	O
`	O
Timestamp	O
`	O
from	O
a	O
`	O
numpy.datetime64	O
`	O
(	O
`	O
dt64	O
`)	O
?	O

.	O

Update	O
:	O
a	O
somewhat	O
nasty	O
example	O
in	O
my	O
dataset	O
(	O
perhaps	O
the	O
motivating	O
example	O
)	O
seems	O
to	O
be	O
:	O

@CODE	O

which	O
should	O
be	O
`	O
datetime.datetime	O
(	O
2002	O
,	O
6	O
,	O
28	O
,	O
1	O
,	O
0	O
)`	O
,	O
and	O
not	O
a	O
long	O
(	O
!	O
)	O
(	O
`	O
1025222400000000000L	O
`)	O
...	O

One	O
option	O
is	O
to	O
use	O
`	O
str	O
`	O
,	O
and	O
then	O
`	O
to_datetime	B-API
`	O
(	O
or	O
similar	O
):	O

@CODE	O

Note	O
:	O
it	O
is	O
not	O
equal	O
to	O
`	O
dt	O
`	O
because	O
it's	O
become	O
"	O
offset-aware	O
"	O
:	O

@CODE	O

This	O
seems	O
inelegant	O
.	O

.	O

Update	O
:	O
this	O
can	O
deal	O
with	O
the	O
"	O
nasty	O
example	O
"	O
:	O

@CODE	O

@CODE	O

For	O
`	O
DatetimeIndex	B-API
`	O
,	O
the	O
`	O
tolist	O
`	O
returns	O
a	O
list	O
of	O
`	O
datetime	O
`	O
objects	O
.	O

For	O
a	O
single	O
`	O
datetime64	O
`	O
object	O
it	O
returns	O
a	O
single	O
`	O
datetime	O
`	O
object	O
.	O

To	O
convert	O
`	O
numpy.datetime64	O
`	O
to	O
datetime	O
object	O
that	O
represents	O
time	O
in	O
UTC	O
on	O
`	O
numpy-1.8	O
`	O
:	O

@CODE	O

The	O
above	O
example	O
assumes	O
that	O
a	O
naive	O
datetime	O
object	O
is	O
interpreted	O
by	O
`	O
np.datetime64	O
`	O
as	O
time	O
in	O
UTC	O
.	O

To	O
convert	O
datetime	O
to	O
np.datetime64	O
and	O
back	O
(	O
`	O
numpy-1.6	O
`)	O
:	O

@CODE	O

It	O
works	O
both	O
on	O
a	O
single	O
np.datetime64	O
object	O
and	O
a	O
numpy	O
array	O
of	O
np.datetime64	O
.	O

Think	O
of	O
np.datetime64	O
the	O
same	O
way	O
you	O
would	O
about	O
np.int8	O
,	O
np.int16	O
,	O
etc	O
and	O
apply	O
the	O
same	O
methods	O
to	O
convert	O
beetween	O
Python	O
objects	O
such	O
as	O
int	O
,	O
datetime	O
and	O
corresponding	O
numpy	O
objects	O
.	O

Your	O
"	O
nasty	O
example	O
"	O
works	O
correctly	O
:	O

@CODE	O

I	O
can	O
reproduce	O
the	O
`	O
long	O
`	O
value	O
on	O
`	O
numpy-1.8.0	O
`	O
installed	O
as	O
:	O

@CODE	O

The	O
same	O
example	O
:	O

@CODE	O

It	O
returns	O
`	O
long	O
`	O
because	O
for	O
`	O
numpy.datetime64	O
`	O
type	O
`	O
.astype	O
(	O
datetime	O
)`	O
is	O
equivalent	O
to	O
`	O
.astype	O
(	O
object	O
)`	O
that	O
returns	O
Python	O
integer	O
(	O
`	O
long	O
`)	O
on	O
`	O
numpy-1.8	O
`	O
.	O

To	O
get	O
datetime	O
object	O
you	O
could	O
:	O

@CODE	O

To	O
get	O
datetime64	O
that	O
uses	O
seconds	O
directly	O
:	O

@CODE	O

The	O
numpy	O
docs	O
say	O
that	O
the	O
datetime	O
API	O
is	O
experimental	O
and	O
may	O
change	O
in	O
future	O
numpy	O
versions	O
.	O

Welcome	O
to	O
hell	O
.	O

You	O
can	O
just	O
pass	O
a	O
datetime64	O
object	O
to	O
`	O
pandas.Timestamp	O
`	O
:	O

@CODE	O

I	O
noticed	O
that	O
this	O
doesn't	O
work	O
right	O
though	O
in	O
NumPy	O
1.6.1	O
:	O

@CODE	O

Also	O
,	O
`	O
pandas.to_datetime	B-API
`	O
can	O
be	O
used	O
(	O
this	O
is	O
off	O
of	O
the	O
dev	O
version	O
,	O
haven't	O
checked	O
v0.9.1	O
):	O

@CODE	O

You	O
can	O
just	O
use	O
the	O
pd.Timestamp	O
constructor	O
.	O

The	O
following	O
diagram	O
may	O
be	O
useful	O
for	O
this	O
and	O
related	O
questions	O
.	O

If	O
you	O
want	O
to	O
convert	O
an	O
entire	O
pandas	O
series	O
of	O
datetimes	O
to	O
regular	O
python	O
datetimes	O
,	O
you	O
can	O
also	O
use	O
`	O
.to_pydatetime()	O
`	O
.	O

@CODE	O

It	O
also	O
supports	O
timezones	O
:	O

@CODE	O

indeed	O
,	O
all	O
of	O
these	O
datetime	O
types	O
can	O
be	O
difficult	O
,	O
and	O
potentially	O
problematic	O
(	O
must	O
keep	O
careful	O
track	O
of	O
timezone	O
information	O
)	O
.	O

here's	O
what	O
i	O
have	O
done	O
,	O
though	O
i	O
admit	O
that	O
i	O
am	O
concerned	O
that	O
at	O
least	O
part	O
of	O
it	O
is	O
"	O
not	O
by	O
design	O
"	O
.	O
also	O
,	O
this	O
can	O
be	O
made	O
a	O
bit	O
more	O
compact	O
as	O
needed	O
.	O

starting	O
with	O
a	O
numpy.datetime64	O
dt_a	O
:	O

dt_a	O

numpy.datetime64('2015	O
-	O
04-24T23	O
:	O
11:26	O
.270000	O
-0700	O
')	O

dt_a1	O
=	O
dt_a.tolist()	O
#	O
yields	O
a	O
datetime	O
object	O
in	O
UTC	O
,	O
but	O
without	O
tzinfo	O

dt_a1	O

datetime.datetime	O
(	O
2015	O
,	O
4	O
,	O
25	O
,	O
6	O
,	O
11	O
,	O
26	O
,	O
270000	O
)	O

@CODE	O

dt_a2	O
=d	O
atetime.datetime	O
(	O
*list	O
(	O
dt_a1.timetuple()	O
[:	O
6	O
]	O
)	O
+	O
[	O
dt_a1.microsecond	O
]	O
,	O
tzinfo=pytz.timezone('UTC	O
'))	O

...	O
and	O
of	O
course	O
,	O
that	O
can	O
be	O
compressed	O
into	O
one	O
line	O
as	O
needed	O
.	O
