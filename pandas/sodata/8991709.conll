Why	O
are	O
pandas	O
merges	O
in	O
python	O
faster	O
than	O
data.table	O
merges	O
in	O
R	O
?	O

I	O
recently	O
came	O
across	O
the	O
pandas	O
library	O
for	O
python	O
,	O
which	O
according	O
to	O
this	O
benchmark	O
performs	O
very	O
fast	O
in-memory	O
merges	O
.	O

It's	O
even	O
faster	O
than	O
the	O
data.table	O
package	O
in	O
R	O
(	O
my	O
language	O
of	O
choice	O
for	O
analysis	O
)	O
.	O

Why	O
is	O
`	O
pandas	O
`	O
so	O
much	O
faster	O
than	O
`	O
data.table	O
`	O
?	O

Is	O
it	O
because	O
of	O
an	O
inherent	O
speed	O
advantage	O
python	O
has	O
over	O
R	O
,	O
or	O
is	O
there	O
some	O
tradeoff	O
I'm	O
not	O
aware	O
of	O
?	O

Is	O
there	O
a	O
way	O
to	O
perform	O
inner	O
and	O
outer	O
joins	O
in	O
`	O
data.table	O
`	O
without	O
resorting	O
to	O
`	O
merge	O
(	O
X	O
,	O
Y	O
,	O
all=FALSE	O
)`	O
and	O
`	O
merge	O
(	O
X	O
,	O
Y	O
,	O
all=TRUE	O
)`	O
?	O

Here's	O
the	O
R	O
code	O
and	O
the	O
Python	O
code	O
used	O
to	O
benchmark	O
the	O
various	O
packages	O
.	O

The	O
reason	O
pandas	O
is	O
faster	O
is	O
because	O
I	O
came	O
up	O
with	O
a	O
better	O
algorithm	O
,	O
which	O
is	O
implemented	O
very	O
carefully	O
using	O
a	O
fast	O
hash	O
table	O
implementation	O
-	O
klib	O
and	O
in	O
C	O
Cython	O
to	O
avoid	O
the	O
Python	O
interpreter	O
overhead	O
for	O
the	O
non-vectorizable	O
parts	O
.	O

The	O
algorithm	O
is	O
described	O
in	O
some	O
detail	O
in	O
my	O
presentation	O
:	O
A	O
look	O
inside	O
pandas	O
design	O
and	O
development	O
.	O

The	O
comparison	O
with	O
`	O
data.table	O
`	O
is	O
actually	O
a	O
bit	O
interesting	O
because	O
the	O
whole	O
point	O
of	O
R's	O
`	O
data.table	O
`	O
is	O
that	O
it	O
contains	O
pre-computed	O
indexes	O
for	O
various	O
columns	O
to	O
accelerate	O
operations	O
like	O
data	O
selection	O
and	O
merges	O
.	O

In	O
this	O
case	O
(	O
database	O
joins	O
)	O
pandas	O
'	O
DataFrame	B-API
contains	O
no	O
pre-computed	O
information	O
that	O
is	O
being	O
used	O
for	O
the	O
merge	O
,	O
so	O
to	O
speak	O
it's	O
a	O
"	O
cold	O
"	O
merge	O
.	O

If	O
I	O
had	O
stored	O
the	O
factorized	O
versions	O
of	O
the	O
<<<<<<< Updated upstream
join	O
=======
join	B-API
>>>>>>> Stashed changes
keys	O
,	O
the	O
join	O
would	O
be	O
significantly	O
faster	O
-	O
as	O
factorizing	O
is	O
the	O
biggest	O
bottleneck	O
for	O
this	O
algorithm	O
.	O

I	O
should	O
also	O
add	O
that	O
the	O
internal	O
design	O
of	O
pandas	O
'	O
DataFrame	B-API
is	O
much	O
more	O
amenable	O
to	O
these	O
kinds	O
of	O
operations	O
than	O
R's	O
data.frame	O
(	O
which	O
is	O
just	O
a	O
list	O
of	O
arrays	O
internally	O
)	O
.	O

It	O
looks	O
like	O
Wes	O
may	O
have	O
discovered	O
a	O
known	O
issue	O
in	O
`	O
data.table	O
`	O
when	O
the	O
number	O
of	O
unique	O
strings	O
(	O
levels	O
)	O
is	O
large	O
:	O
10,000	O
.	O

Does	O
`	O
`	O
reveal	O
most	O
of	O
the	O
time	O
spent	O
in	O
the	O
call	O
`	O
sortedmatch	O
(	O
levels	O
(	O
i[[lc]]	O
)	O
,	O
levels	O
(	O
x[[rc]]	O
)`	O
?	O

This	O
isn't	O
really	O
the	O
join	O
itself	O
(	O
the	O
algorithm	O
)	O
,	O
but	O
a	O
preliminary	O
step	O
.	O

Recent	O
efforts	O
have	O
gone	O
into	O
allowing	O
character	O
columns	O
in	O
keys	O
,	O
which	O
should	O
resolve	O
that	O
issue	O
by	O
integrating	O
more	O
closely	O
with	O
R's	O
own	O
global	O
string	O
hash	O
table	O
.	O

Some	O
benchmark	O
results	O
are	O
already	O
reported	O
by	O
`	O
`	O
but	O
that	O
code	O
isn't	O
hooked	O
up	O
yet	O
to	O
replace	O
the	O
levels	O
to	O
levels	O
match	O
.	O

Are	O
pandas	O
merges	O
faster	O
than	O
`	O
data.table	O
`	O
for	O
regular	O
integer	O
columns	O
?	O

That	O
should	O
be	O
a	O
way	O
to	O
isolate	O
the	O
algorithm	O
itself	O
vs	O
factor	O
issues	O
.	O

Also	O
,	O
`	O
data.table	O
`	O
has	O
time	O
series	O
merge	O
in	O
mind	O
.	O

Two	O
aspects	O
to	O
that	O
:	O
i	O
)	O
multi	O
column	O
<<<<<<< Updated upstream
ordered	O
=======
ordered	B-API
>>>>>>> Stashed changes
keys	O
such	O
as	O
(	O
id	O
,	O
datetime	O
)	O
ii	O
)	O
fast	O
prevailing	O
join	O
(	O
`	O
roll=TRUE	O
`)	O
a.k.a.	O
last	O
observation	O
carried	O
forward	O
.	O

I'll	O
need	O
some	O
time	O
to	O
confirm	O
as	O
it's	O
the	O
first	O
I've	O
seen	O
of	O
the	O
comparison	O
to	O
`	O
data.table	O
`	O
as	O
presented	O
.	O

UPDATE	O
from	O
data.table	O
v1.8.0	O
released	O
July	O
2012	O

Internal	O
function	O
removed	O
and	O
replaced	O
with	O

when	O
matching	O
i	O
levels	O
to	O
x	O
levels	O
for	O
columns	O
of	O
type	O
'	O
factor	O
'	O
.	O

This	O

preliminary	O
step	O
was	O
causing	O
a	O
(	O
known	O
)	O
significant	O
slowdown	O
when	O
the	O
number	O

of	O
levels	O
of	O
a	O
factor	O
column	O
was	O
large	O
(	O
e.g.	O
>	O
10,000	O
)	O
.	O

Exacerbated	O
in	O

tests	O
of	O
joining	O
four	O
such	O
columns	O
,	O
as	O
demonstrated	O
by	O
Wes	O
McKinney	O

(	O
author	O
of	O
Python	O
package	O
Pandas	O
)	O
.	O

Matching	O
1	O
million	O
strings	O
of	O
which	O

of	O
which	O
600,000	O
are	O
unique	O
is	O
now	O
reduced	O
from	O
16s	O
to	O
0.5s	O
,	O
for	O
example	O
.	O

also	O
in	O
that	O
release	O
was	O
:	O

character	O
columns	O
are	O
now	O
allowed	O
in	O
keys	O
and	O
are	O
preferred	O
to	O

factor	O
.	O
and	O
no	O
longer	O
coerce	O
character	O
to	O

factor	O
.	O

Factors	O
are	O
still	O
supported	O
.	O

Implements	O
FR	O
#1493	O
,	O
FR	O
#1224	O

and	O
(	O
partially	O
)	O
FR	O
#951	O
.	O

New	O
functions	O
and	O
%chin%	O
,	O
faster	O
versions	O
of	O

and	O
%in%	O
for	O
character	O
vectors	O
.	O

R's	O
internal	O
string	O
cache	O
is	O

utilised	O
(	O
no	O
hash	O
table	O
is	O
built	O
)	O
.	O

They	O
are	O
about	O
4	O
times	O
faster	O

than	O
on	O
the	O
example	O
in	O
?	O

chmatch	O
.	O

As	O
of	O
Sep	O
2013	O
data.table	O
is	O
v1.8.10	O
on	O
CRAN	O
and	O
we're	O
working	O
on	O
v1.9.0	O
.	O

NEWS	O
is	O
updated	O
live	O
.	O

But	O
as	O
I	O
wrote	O
originally	O
,	O
above	O
:	O

`	O
data.table	O
`	O
has	O
time	O
series	O
merge	O
in	O
mind	O
.	O

Two	O
aspects	O
to	O
that	O
:	O
i	O
)	O

multi	O
column	O
<<<<<<< Updated upstream
ordered	O
=======
ordered	B-API
>>>>>>> Stashed changes
keys	O
such	O
as	O
(	O
id	O
,	O
datetime	O
)	O
ii	O
)	O
fast	O
prevailing	O

join	O
(	O
`	O
roll=TRUE	O
`)	O
a.k.a.	O
last	O
observation	O
carried	O
forward	O
.	O

So	O
the	O
Pandas	O
equi	O
join	O
of	O
two	O
character	O
columns	O
is	O
probably	O
still	O
faster	O
than	O
data.table	O
.	O

Since	O
it	O
sounds	O
like	O
it	O
hashes	O
the	O
combined	O
two	O
columns	O
.	O
data.table	O
doesn't	O
hash	O
the	O
key	O
because	O
it	O
has	O
prevailing	O
ordered	O
joins	O
in	O
mind	O
.	O

A	O
"	O
key	O
"	O
in	O
data.table	O
is	O
literally	O
just	O
the	O
<<<<<<< Updated upstream
sort	O
=======
sort	B-API
>>>>>>> Stashed changes
order	O
(	O
similar	O
to	O
a	O
clustered	O
index	O
in	O
SQL	O
;	O
i.e.	O
,	O
that's	O
how	O
the	O
data	O
is	O
ordered	O
in	O
RAM	O
)	O
.	O

On	O
the	O
list	O
is	O
to	O
add	O
secondary	O
keys	O
,	O
for	O
example	O
.	O

In	O
summary	O
,	O
the	O
glaring	O
speed	O
difference	O
highlighted	O
by	O
this	O
particular	O
two-character-column	O
test	O
with	O
over	O
10,000	O
unique	O
strings	O
shouldn't	O
be	O
as	O
bad	O
now	O
,	O
since	O
the	O
known	O
problem	O
has	O
been	O
fixed	O
.	O

Since	O
both	O
of	O
the	O
other	O
answers	O
are	O
from	O
the	O
respective	O
authors	O
of	O
the	O
two	O
packages	O
,	O
I	O
thought	O
I'd	O
add	O
a	O
users	O
view	O
on	O
this	O
,	O
since	O
I've	O
used	O
both	O
packages	O
quite	O
a	O
bit	O
.	O

Headline	O
message	O
for	O
users	O
:	O
don't	O
choose	O
between	O
these	O
packages	O
based	O
on	O
speed	O
or	O
benchmarks	O
,	O
that	O
will	O
be	O
second	O
order	O
in	O
your	O
work	O
.	O

If	O
you	O
care	O
that	O
much	O
about	O
speed	O
,	O
write	O
you	O
application	O
in	O
assembly	O
/	O
C	O
for	O
your	O
specific	O
case	O
,	O
and	O
buy	O
a	O
faster	O
computer	O
.	O

Looking	O
at	O
the	O
implementation	O
of	O
both	O
,	O
they	O
should	O
generally	O
come	O
out	O
similar	O
in	O
speed	O
,	O
and	O
tests	O
I've	O
run	O
now	O
generally	O
do	O
.	O

(	O
As	O
explained	O
above	O
the	O
big	O
difference	O
found	O
in	O
an	O
early	O
benchmark	O
was	O
a	O
bug	O
)	O
.	O

For	O
certain	O
tasks	O
one	O
or	O
other	O
can	O
come	O
out	O
a	O
tad	O
faster	O
,	O
but	O
never	O
by	O
much	O
.	O

The	O
reason	O
for	O
this	O
,	O
is	O
the	O
heavy	O
lifting	O
part	O
is	O
"	O
factoring	O
"	O
the	O
<<<<<<< Updated upstream
join	O
=======
join	B-API
>>>>>>> Stashed changes
keys	O
,	O
and	O
both	O
packages	O
seem	O
to	O
have	O
found	O
the	O
same	O
solution	O
to	O
this	O
problem	O
,	O
to	O
use	O
something	O
very	O
similar	O
to	O
a	O
Counting	O
Sort	O
.	O

Matthew	O
(	O
data.table	O
)	O
generally	O
calls	O
this	O
a	O
Radix	O
Sort	O
(	O
since	O
it	O
is	O
incorrectly	O
named	O
such	O
in	O
R	O
)	O
and	O
Wes	O
(	O
pandas	O
)	O
is	O
using	O
a	O
klib	O
hash	O
table	O
to	O
achieve	O
a	O
similar	O
end	O
.	O

Thus	O
the	O
only	O
<<<<<<< Updated upstream
real	O
=======
real	B-API
>>>>>>> Stashed changes
difference	O
in	O
approach	O
that	O
I	O
can	O
see	O
is	O

To	O
hash	O
or	O
not	O

Pandas	O
gives	O
everything	O
to	O
klib	O
to	O
hash	O
,	O
and	O
relies	O
on	O
klib	O
being	O
smart	O
(	O
which	O
it	O
is	O
)	O
,	O
but	O
this	O
must	O
still	O
cause	O
at	O
least	O
one	O
opcode	O
!	O

data.table	O
will	O
just	O
use	O
the	O
object	O
itself	O
if	O
it	O
can	O
,	O
e.g.	O
integer	O
,	O
and	O
uses	O
Rs	O
internal	O
hash	O
tables	O
for	O
strings	O
.	O

Other	O
data-types	O
things	O
get	O
a	O
bit	O
less	O
optimal	O
.	O

An	O
advantage	O
to	O
this	O
is	O
you	O
often	O
get	O
things	O
in	O
"	O
natural	O
"	O
order	O
.	O

Build	O
the	O
index	O
in	O
advance	O
or	O
not	O
(	O
although	O
it	O
appears	O
pandas	O
does	O
some	O
caching	O
here	O
for	O
future	O
calls	O
?	O
)	O

And	O
these	O
two	O
effect	O
can	O
mess	O
with	O
benchmarks	O
quite	O
badly	O
.	O

Leave	O
out	O
the	O
`	O
set.index	O
`	O
part	O
of	O
the	O
`	O
data.table	O
`	O
and	O
`	O
data.table	O
`	O
looks	O
good	O
.	O

Use	O
keys	O
that	O
are	O
"	O
ugly	O
"	O
in	O
their	O
raw	O
form	O
and	O
pandas	O
can	O
look	O
better	O
.	O

I've	O
not	O
found	O
the	O
pattern	O
but	O
I'm	O
sure	O
non-unique	O
key	O
values	O
will	O
also	O
cause	O
differences	O
.	O

So	O
you	O
can	O
see	O
,	O
in	O
the	O
wild	O
you	O
are	O
likely	O
to	O
be	O
unsure	O
where	O
on	O
the	O
spectrum	O
you	O
will	O
actually	O
be	O
.	O

For	O
example	O
,	O
you	O
may	O
have	O
a	O
situation	O
where	O
the	O
join	O
favours	O
pandas	O
slightly	O
,	O
but	O
later	O
on	O
you	O
need	O
to	O
have	O
the	O
table	O
sorted	O
by	O
that	O
key	O
column	O
,	O
and	O
the	O
"	O
unhashed	O
"	O
approach	O
of	O
data.table	O
can	O
make	O
that	O
sort	O
faster	O
(	O
since	O
it	O
will	O
already	O
be	O
in	O
order	O
)	O
.	O

I	O
haven't	O
gone	O
through	O
every	O
line	O
in	O
the	O
source	O
of	O
both	O
packages	O
,	O
so	O
I	O
can't	O
be	O
certain	O
I	O
haven't	O
missed	O
anything	O
.	O
