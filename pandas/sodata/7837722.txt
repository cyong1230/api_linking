What is the most efficient way to loop through dataframes with pandas?
I want to perform my own complex operations on financial data in dataframes in a sequential manner. 
For example I am using the following MSFT CSV file taken from Yahoo Finance : @CODE
I then do the following: @CODE
Is that the most efficient way? Given the focus on speed in pandas, I would assume there must be some special function to iterate through the values in a manner that one also retrieves the index (possibly through a generator to be memory efficient)? `df.iteritems` unfortunately only iterates column by column.
have you tried writing a function and passing it to `df.apply()`?
If you want memory efficieny you should consider using vectorized operations (using matrices and vectors). But I don't know pandas, so I can't tell you, whether such operations are possible there.
Citing `unutbu`, NumPy seems to support vectorized operations (`The key to speed with NumPy arrays is to perform your operations on the whole array at once`).
Pandas is based on NumPy arrays.
The key to speed with NumPy arrays is to perform your operations on the whole array at once, never row-by-row or item-by-item. 
For example, if `close` is a 1-d array, and you want the day-over-day percent change, @CODE
This computes the entire array of percent changes as one statement, instead of @CODE
So try to avoid the Python loop `for i, row in enumerate(...)` entirely, and
think about how to perform your calculations with operations on the entire array (or dataframe) as a whole, rather than row-by-row.
I agree that this is the best way and that is what I usually do for simple operations. However, in this case, this is not possible, since the resulting operations can get very complex. Specifically I am trying to backtest trading strategies.&#xA;&#xA;E.g. if the price is at a new low over a 30d period, then we might want to buy the stock and get out whenever a certain condition is met and this needs to be simulated in-place. This simple example could still be done by vectorization, however, the more complex a trading-strategy gets, the less possible it becomes to use vectorization.
You'll have to explain in more detail the exact calculation you are trying to perform. It helps to write the code any way you can first, then profile and optimize it.
By the way, for some calculations (especially those that can not be expressed as operations on whole arrays) code using Python lists can be faster than equivalent code using numpy arrays.
makes sense. Will work with that. thank you!
I agree vectorization is the right solution where possible-- sometimes an iterative algorithm is the only way though.
late comment, but i have found that trying to do full calculation for a column is sometimes difficult to write and debug.   Consider intermediary calculation columns,  makes it easier to debug and understand the calculations.   have found that even the most complex logic can be implemented like this, while still avoiding looping.
You can loop through the rows by transposing and then calling iteritems: @CODE
I am not certain about efficiency in that case. To get the best possible performance in an iterative algorithm, you might want to explore writing it in Cython , so you could do something like: @CODE
I would recommend writing the algorithm in pure Python first, make sure it works and see how fast it is-- if it's not fast enough, convert things to Cython like this with minimal work to get something that's about as fast as hand-coded C/C++.
I also recommend Cython; I was working on a similar problem for building my backtesting engine, and I got a 1,000x speedup. I then combined that with the multiprocessing library, which is a very nice combination.
This answer needs updating to include the new `df.iterrows()` as per @NickCrawford's answer.
`df.T.iteritems()` is a great solution rather than using `df.iterrows()` if you want to iterate over a specific column +1
The newest versions of pandas now include a built-in function for iterating over rows. @CODE
Or, if you want it faster use `itertuples()` 
But, unutbu's suggestion to use numpy functions to avoid iterating over rows will produce the fastest code.
Note that `iterrows` is very slow (it converts every row to a series, potentially messing with your data types). When you need an iterator, better to use `itertuples`
I checked out `iterrows` after noticing Nick Crawford's answer, but found that it yields (index, Series) tuples. Not sure which would work best for you, but I ended up using the `itertuples` method for my problem, which yields (index, row_value1...) tuples. 
There's also `iterkv`, which iterates through (column, series) tuples.
you can do something like dict(row) to make a set out of the row with searchable columns
I also found itertuples to be much faster (10x) in my use case as Series objects are not being created.
FYI: `iterkv` deprecated since 0.13.1
`iterrows(): Iterate over the rows of a DataFrame as (index, Series) pairs....&#xA;itertuples(): Iterate over the rows of a DataFrame as tuples of the values. This is a lot faster as iterrows(), and is in most cases preferable to use to iterate over the values of a DataFrame.`
Just as a small addition, you can also do an apply if you have a complex function that you apply to a single column: 
http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.apply.html @CODE
probably x is a confusing name for the column name and the row variable, though I agree apply is easiest way to do it :)
Good comment, I've edited it so that the "x" confusion has gone!
just to add, `apply` can also be applied to multiple columns:&#xA;`df['c'] = df[['a','b']].apply(lambda x: do stuff with x[0] and x[1] here, axis=1)`
Can apply take in a function defined elsewhere in code? this is  so that we can introduce a more complicated function
Yes, the lambda function can use any kind of user defined function. Mind you: if you have a large dataframe, you might want to revert to cython instead (Python has a bit of overhead when it comes to calling functions)
I renamed `x` -> `col`. Better name
Another suggestion would be to combine groupby with vectorized calculations if subsets of the rows shared characteristics which allowed you to do so.
Like what has been mentioned before, pandas object is most efficient when process the whole array at once. However for those who really need to loop through a pandas DataFrame to perform something, like me, I found at least three ways to do it. I have done a short test to see which one of the three is the least time consuming. @CODE
Result: @CODE
This is probably not the best way to measure the time consumption but it's quick for me. 
Here are some pros and cons IMHO: 
.iterrows(): return index and row items in separate variables, but significantly slower 
.itertuples(): faster than .iterrows(), but return index together with row items, ir[0] is the index 
zip: quickest, but no access to index of the row
