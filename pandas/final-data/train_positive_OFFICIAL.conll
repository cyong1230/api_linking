In	O
[	O
8]	O
:	O
%timeit	O
df	O
[	O
'	O
r	O
']	O
=	O
df	O
[[	O
'	O
minor	O
'	O
,	O
'	O
major	O
']]	O
.abs()	B-API
.max	B-API
(	O
axis=1	O
)	O

You	O
can	O
do	O
this	O
by	O
using	O
a	O
`	O
groupby()	B-API
.transform()	B-API
`	O
,	O
see	O
#URL	O

Specifying	O
dtype	B-API
in	O
pandas	O

Pandas	O
dropna	B-API
-	O
store	O
dropped	O
rows	O

I've	O
been	O
through	O
the	O
`	O
to_json	B-API
`	O
and	O
`	O
json.dumps	O
`	O
documentation	O
and	O
tried	O
different	O
kinds	O
of	O
indexes	O
and	O
dicts	O
,	O
and	O
I'm	O
getting	O
lost	O
...	O

EDIT	O
:	O
The	O
problem	O
stems	O
from	O
that	O
fact	O
that	O
I	O
am	O
using	O
an	O
irregular	O
calendar	O
in	O
`	O
num2date	B-API
`	O
which	O
violates	O
the	O
fact	O
that	O
`	O
pandas.PeriodIndex	O
`	O
needs	O
to	O
have	O
regular	O
intervals	O

`	O
df	O
[	O
"	O
YTD	O
"]	O
=	O
GroupedDat	O
[	O
'	O
CLOSE_SPX	O
']	O
.transform	B-API
(	O
lambda	O
x	O
:	O
x	O
/	O
x.iloc	O
[	O
0	O
]	O
-	O
1.0	O
)`	O

I'm	O
pretty	O
sure	O
there	O
is	O
a	O
way	O
to	O
do	O
this	O
with	O
apply()	B-API
but	O
I'm	O
not	O
getting	O
anywhere	O
.	O

when	O
specifying	O
dtypes	B-API
to	O
pass	O
to	O
`	O
read_csv	B-API
`	O
,	O
they	O
must	O
be	O
numpy	O
dtypes	B-API
;	O
and	O
string	O
dtypes	B-API
are	O
converted	O
to	O
`	O
object	O
`	O
dtype	B-API
(	O
so	O
the	O
`	O
s64	O
`	O
doesn't	O
do	O
anything	O
)	O
.	O
nor	O
does	O
the	O
`	O
datetime	O
`	O
,	O
that's	O
what	O
`	O
parse_dates	O
`	O
is	O
used	O
.	O

Without	O
the	O
dtype	B-API
parameter	O
,	O
the	O
column	O
is	O
imported	O
as	O
an	O
'	O
object	O
'	O
dtype	B-API
.	O

As	O
this	O
seems	O
a	O
bug	O
,	O
I	O
opened	O
an	O
issue	O
about	O
this	O
here	O
:	O
#URL	O
Workaround	O
for	O
now	O
is	O
indeed	O
using	O
`	O
.agg	B-API
(	O
lambda	O
x	O
:	O
x.idxmax()	O
)`	O
instead	O
of	O
using	O
`	O
.idxmax()	B-API
`	O

hi	O
Alexander	O
-	O
I	O
see	O
the	O
problem	O
with	O
my	O
iloc	B-API
columns	O
,	O
sorry	O
for	O
that	O
.	O

Pandas	O
module	O
read_csv	B-API
reads	O
file	O
within	O
Eclipse+pydev	O
while	O
fail	O
if	O
I	O
run	O
standalone	O

I've	O
tried	O
again	O
and	O
same	O
thing	O
,	O
it's	O
really	O
strange	O
because	O
set_index	B-API
has	O
the	O
inplace	O
argument	O
.	O

Was	O
too	O
lazy	O
too	O
lazy	O
to	O
do	O
an	O
actual	O
example	O
since	O
read_clipboard	B-API
doesn't	O
handle	O
MultiIndexes	O
:)	O
I'll	O
post	O
it	O
up	O
formally	O
later	O
.	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O
`	O
.	O

`	O
(	O
although	O
the	O
`	O
.dt	B-API
`	O
part	O
might	O
only	O
work	O
if	O
you're	O
using	O
v0.15	O
of	O
Pandas	O
)	O

The	O
problem	O
can	O
be	O
fixed	O
by	O
converting	O
`	O
ts.index	O
`	O
to	O
a	O
`	O
DatetimeIndex	B-API
`	O
:	O
#CODE	O

It	O
is	O
still	O
a	O
numpy	O
object	O
,	O
regardless	O
of	O
`	O
dtype	B-API
`	O
.	O

Thanks	O
,	O
get_loc	B-API
is	O
what	O
I	O
need	O
.	O

You	O
can	O
`	O
get_level_values	B-API
`	O
in	O
conjunction	O
with	O
Boolean	O
slicing	O
.	O

Other	O
approaches	O
include	O
using	O
`	O
applymap	B-API
`	O
or	O
boolean	O
indexing	O
,	O
i.e.	O
#CODE	O

There's	O
a	O
good	O
chance	O
I'm	O
getting	O
lost	O
in	O
the	O
linspace	B-API
part	O
.	O

I	O
don't	O
think	O
.shift()	B-API
works	O
in	O
this	O
case	O
as	O
'	O
rule3	O
'	O
is	O
a	O
calculated	O
column	O
with	O
each	O
row	O
value	O
dependant	O
on	O
the	O
previous	O
row	O
value	O
.	O

And	O
even	O
when	O
I	O
follow	O
experienced	O
programmers	O
'	O
suggestions	O
of	O
using	O
.loc	B-API
,	O
same	O
warnings	O
persist	O
(	O
as	O
below	O
)	O
.	O

More	O
generally	O
,	O
what	O
is	O
the	O
syntax	O
for	O
`	O
iloc	B-API
`	O
for	O
Multi-level	O
DataFrames	O
?	O

The	O
(	O
dtype	B-API
)	O
line	O
is	O
useful	O
to	O
enforce	O
the	O
columns	O
type	O
to	O
not	O
fail	O
on	O
assert	O
(	O
could	O
be	O
optional	O
)	O
.	O

That	O
said	O
,	O
it	O
seems	O
to	O
have	O
a	O
form	O
(	O
see	O
edit	O
)	O
that	O
isn't	O
easily	O
passed	O
into	O
`	O
cumprod	B-API
`	O
.	O

And	O
using	O
pandas.Series.map	B-API
:	O
#CODE	O

In	O
your	O
example	O
,	O
try	O
df	O
[	O
df	O
[	O
0	O
]	O
>	O
8]	O
.ix	B-API
[	O
0	O
,	O
1	O
]	O
,	O
it	O
will	O
return	O
NaN	O
,	O
although	O
we	O
have	O
two	O
rows	O
in	O
the	O
result	O
and	O
we	O
should	O
be	O
able	O
to	O
access	O
them	O
using	O
.ix	B-API
[	O
0	O
,	O
1	O
]	O
.	O

Fairly	O
certain	O
from_product()	B-API
is	O
the	O
problem	O
.	O

To	O
summarize	O
:	O
Without	O
using	O
`	O
head()	B-API
`	O
the	O
`	O
merge()	B-API
`	O
output	O
is	O
showing	O
reduced	O
rows	O
(	O
#	O
rows	O
=	O
#	O
right	O
side	O
rows	O
)	O
and	O
each	O
ingredient	O
ID	O
is	O
simply	O
"	O
pasted	O
"	O
on	O
there	O
in	O
a	O
serial	O
manner	O
.	O

bookings	O
rolling_mean	B-API
rolling_std_dev	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O

In	O
fact	O
,	O
for	O
some	O
types	O
,	O
`	O
str()	B-API
`	O
may	O
not	O
produce	O
anything	O
useful	O
for	O
you	O
.	O

`	O
pivot5min1.loc	O
[(	O
'	O
2013-06-19	O
09:30	O
:	O
00	O
'	O
,	O
'	O
ACCT1	O
')]	O
.loc	B-API
[	O
'	O
ABC	O
']`	O

When	O
you	O
say	O
it's	O
not	O
supported	O
,	O
are	O
you	O
specifically	O
talking	O
about	O
to_hdf	B-API
/	O
read_hdf	B-API
not	O
supporting	O
it	O
,	O
or	O
are	O
you	O
actually	O
saying	O
that	O
Pandas	O
in	O
general	O
doesn't	O
support	O
it	O
?	O

Can	O
you	O
confirm	O
that	O
the	O
dtype	B-API
is	O
a	O
datetime	O
based	O
one	O

apply()	B-API
with	O
trimming	O
and	O
custom	O
padding	O
worked	O
perfectly	O
.	O

Would	O
you	O
edit	O
your	O
answer	O
so	O
it	O
includes	O
the	O
`	O
dtype	B-API
=o	O
bject	O
`	O
suggestion	O
?	O

I	O
might	O
be	O
missing	O
something	O
,	O
but	O
this	O
seems	O
like	O
it	O
could	O
be	O
fully	O
vectorized	O
with	O
`	O
rolling_mean	B-API
`	O
and	O
`	O
rolling_std	B-API
`	O
?	O

Why	O
is	O
Pandas	O
Concatenation	O
(	O
pandas.concat	B-API
)	O
so	O
Memory	O
Inefficient	O
?	O

As	O
Andy	O
pointed	O
out	O
,	O
you	O
can	O
do	O
this	O
using	O
`	O
bdate_range	B-API
`	O
,	O
but	O
I	O
prefer	O
this	O
method	O
due	O
to	O
its	O
simplicity	O
and	O
readability	O

I'm	O
trying	O
to	O
monkeypatch	O
how	O
`	O
pandas	O
`	O
Panel's	O
slicing	O
(	O
`	O
__getitem__	B-API
`)	O
.	O

g.ax_joint.xaxis.set_major_locator	O
(	O
ticker.MultipleLocator	B-API
(	O
90	O
))	O

There	O
are	O
a	O
host	O
more	O
of	O
these	O
.dt	B-API
accessors	O
...	O

If	O
I	O
understand	O
you	O
correctly	O
,	O
`	O
pivot_table	B-API
`	O
might	O
be	O
closer	O
to	O
what	O
you	O
need	O
:	O
#CODE	O

---->	O
8	O
quarter_score_diff	O
=	O
region	O
[(	O
region.Quradate	O
==	O
most_recent_date	O
)	O
or	O
(	O
region.Quradate	O
==	O
last_quarter	O
)]	O
.diff()	B-API

Ok	O
I	O
managed	O
to	O
upgrade	O
to	O
Pandas	O
0.13.1	O
numpy	O
1.8.0	O
I	O
can	O
now	O
run	O
your	O
example	O
code	O
up	O
to	O
`	O
split_times	O
(	O
row	O
)`	O
which	O
returns	O
:	O
`	O
TypeError	O
:	O
cannot	O
astype	B-API
a	O
timedelta	O
from	O
[	O
timedelta64	O
[	O
ns	O
]]	O
to	O
[	O
int32	O
]`	O

Maybe	O
you're	O
looking	O
for	O
[	O
`	O
pivot_table	B-API
`]	O
(	O
#URL	O
)	O
?	O

I	O
had	O
missed	O
that	O
Pandas	O
is	O
converting	O
the	O
mixed	O
timezone	O
column	O
to	O
dtype	B-API
`	O
object	O
`	O
.	O

This	O
needs	O
to	O
work	O
with	O
pandas	O
0.10	O
,	O
so	O
using	O
`	O
the_series.to_frame()	O
.transpose()	B-API
`	O
is	O
not	O
an	O
option	O
.	O

As	O
mentioned	O
in	O
your	O
answer	O
,	O
this	O
is	O
a	O
little	O
cleaner	O
(	O
though	O
there	O
is	O
no	O
ambiguity	O
in	O
this	O
case	O
)	O
as	O
`	O
.loc	B-API
`	O
rather	O
than	O
`	O
.ix	B-API
`	O
.	O

Is	O
concat()	B-API
with	O
axis=1	O
equivalent	O
to	O
merge()	B-API
?	O

An	O
alternative	O
would	O
be	O
to	O
make	O
a	O
`	O
ndarray	B-API
`	O
of	O
`	O
datetime	O
`	O
objects	O
by	O
choosing	O
`	O
dtype	B-API
=o	O
bject	O
`	O
.	O

I	O
was	O
writing	O
functions	O
and	O
doing	O
an	O
dataframe.apply	B-API

However	O
,	O
trying	O
to	O
print	O
the	O
dtype	B-API
of	O
`	O
AllAlexaAndGoogleInfo	O
`	O
like	O
so	O
:	O
#CODE	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O
.	O

You	O
can	O
see	O
that	O
the	O
dtype	B-API
for	O
Desired	O
Output	O
is	O
not	O
`	O
datetime.time	O
`	O
:	O
#CODE	O

.agg	B-API

`	O
df	O
[	O
0	O
]	O
.iloc	B-API
[	O
0	O
]	O
.year	B-API
`	O

That's	O
why	O
I	O
used	O
notnull()	B-API
and	O
lenX	O
in	O
my	O
original	O
question	O
.	O

rolling_mean	B-API
instability	O
in	O
pandas	O

I	O
think	O
this	O
is	O
leaking	O
implementation	O
details	O
about	O
exactly	O
the	O
way	O
in	O
which	O
(	O
as	O
the	O
docs	O
say	O
)	O
"	O
iterrows	B-API
does	O
**	O
not	O
**	O
preserve	O
dtypes	B-API
across	O
the	O
rows	O
"	O
.	O

Starting	O
from	O
0.15	O
,	O
`	O
to_sql	B-API
`	O
has	O
a	O
`	O
chunksize	O
`	O
option	O
(	O
0.15	O
is	O
still	O
in	O
development	O
,	O
but	O
the	O
feature	O
is	O
merged	O
in	O
master	O
)	O

try	O
with	O
grp	O
[	O
'	O
temp_3	O
']	O
.dropna()	B-API
.index	B-API

I	O
had	O
to	O
slip	O
that	O
`	O
fillna	B-API
(	O
0	O
)`	O
in	O
the	O
middle	O
there	O
so	O
that	O
the	O
`	O
NaN	O
`	O
s	O
weren't	O
dropped	O
.	O

For	O
some	O
reason	O
using	O
axis=0	O
in	O
the	O
`	O
pandas.concat	B-API
`	O
does	O
not	O
do	O
what	O
I'd	O
expect	O
.	O

@USER	O
:	O
If	O
I	O
dropna	B-API
,	O
I	O
am	O
assuming	O
that	O
Pandas	O
still	O
treats	O
the	O
column	O
as	O
float	O
.	O

Out	O
of	O
memory	O
when	O
DataFrame.resample()	B-API
is	O
called	O
in	O
pandas	O
on	O
small	O
dataset	O

Here	O
are	O
the	O
dtypes	B-API
for	O
each	O
of	O
these	O
columns	O
:	O
#CODE	O

`	O
.iloc	B-API
`	O
selects	O
rows	O
by	O
ordinal	O
position	O
.	O

You	O
should	O
be	O
using	O
the	O
`	O
DataFrame.loc	B-API
`	O
method	O
,	O
as	O
the	O
warning	O
suggests	O
,	O
like	O
this	O
:	O
#CODE	O

Argh	O
,	O
that	O
still	O
gives	O
me	O
`	O
dtype	B-API
(	O
'	O
datetime64	O
[	O
us	O
]')`	O
.	O

I	O
didn't	O
want	O
`	O
iloc	B-API
`	O
I	O
was	O
specifically	O
testing	O
the	O
behavior	O
of	O
duplicate-duplicate	O
indexing	O
.	O

Yea	O
,	O
seems	O
like	O
set_value	B-API
and	O
get_value	B-API
are	O
the	O
best	O
performers	O
.	O

`	O
.iloc	B-API
`	O
selects	O
rows	O
by	O
ordinal	O
position	O
.	O

This	O
works	O
fine	O
using	O
.concat	B-API
.	O

data.groupby	O
(	O
level=0	O
)	O
.apply	B-API
(	O
lambda	O
d	O
:	O
d.reset_index	O
(	O
level=0	O
,	O
drop=True	O
)	O
.resample	B-API
(	O
"	O
M	O
"	O
,	O
how=	O
""))	O

In	O
effect	O
are	O
you	O
expecting	O
no	O
change	O
or	O
that	O
`	O
NaN	O
`	O
is	O
replaced	O
with	O
`	O
None	O
`	O
which	O
doesn't	O
make	O
sense	O
for	O
numerical	O
dtypes	B-API

It	O
looks	O
like	O
the	O
`	O
pandas.merge()	B-API
`	O
method	O
is	O
restricted	O
to	O
working	O
with	O
only	O
two	O
dataframes	O
.	O

dtypes	B-API
:	O
float64	O
(	O
1	O
)	O
,	O
object	O
(	O
3	O
)	O

Maybe	O
you're	O
looking	O
for	O
[	O
`	O
pivot_table	B-API
`]	O
(	O
#URL	O
)	O
?	O

File	O
"	O
C	O
:\	O
Users\Owner\AppData\Local\Continuum\Anaconda3\Lib\	O
site-packages	O
\pandas\io\	O
sql.py	O
"	O
,	O
line	O
534	O
,	O
in	O
to_sql	B-API

pandas	O
rolling_apply	B-API
pass	O
memo	O
to	O
udf	O

@USER	O
ah	O
yes	O
,	O
I	O
missed	O
that	O
,	O
doing	O
it	O
column-wise	O
*	O
may	O
*	O
be	O
better	O
option	O
as	O
you	O
avoid	O
possibly	O
upcasting	O
the	O
dtype	B-API
(	O
e.g.	O
from	O
int	O
to	O
float	O
)	O
,	O
depends	O
...	O
probably	O
much	O
of	O
a	O
muchness	O
.	O

I	O
could	O
specify	O
the	O
dtype	B-API
of	O
the	O
specific	O
columns	O
as	O
int	O
with	O
the	O
`	O
dtype	B-API
`	O
keyword	O
.	O

Its	O
`	O
dtype	B-API
`	O
by	O
default	O
is	O
`	O
object	O
`	O
.	O

dtype	B-API
:	O
float64	O

I'm	O
not	O
sure	O
if	O
the	O
get_dummies()	B-API
allows	O
me	O
to	O
do	O
that	O
?	O

I	O
didn't	O
realize	O
that	O
the	O
qcut()	B-API
output	O
had	O
labels	O
.	O

The	O
dtype	B-API
conversion	O
is	O
not	O
done	O
here	O
because	O
you	O
could	O
be	O
potentially	O
doing	O
a	O
very	O
expensive	O
operation	O
.	O

`	O
s	O
=	O
s.resample	O
(	O
'	O
M	O
'	O
,	O
fill_method=	O
'	O
ffill	B-API
')`	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O

This	O
works	O
well	O
,	O
although	O
`	O
numpy.unpackbits	B-API
`	O
only	O
seems	O
to	O
work	O
on	O
8-b	O
it	O
integers	O
.	O

yeah	O
i	O
like	O
your	O
answer	O
better	O
,	O
i've	O
never	O
seen	O
`	O
select_dtypes	B-API
`	O
before	O

df_g	O
[	O
'	O
Mem	O
']	O
=d	O
f_g	O
[	O
'	O
Mem	O
']	O
.map	B-API
(	O
'	O
{	O
:	O
4d}	O
'	O
.format	B-API
)	O
#CODE	O

Note	O
:	O
In	O
soon	O
to	O
be	O
released	O
0.13	O
a	O
`	O
drop_level	O
`	O
argument	O
has	O
been	O
added	O
to	O
xs	B-API
(	O
thanks	O
to	O
this	O
question	O
!	O
):	O
#CODE	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O

pandas	O
read_csv()	B-API
input	O
local	O
datetime	O
strings	O
,	O
tz_convert	B-API
to	O
UTC	O

Trying	O
the	O
same	O
with	O
`	O
.apply	B-API
`	O
would	O
give	O
`	O
NaNs	O
`	O
in	O
`	O
sum_C	O
`	O
.	O

and	O
,	O
`	O
ts.asfreq	O
(	O
'	O
H	O
'	O
,	O
method=	O
'	O
ffill	B-API
')`	O
to	O
have	O
hourly	O
frequency	O
.	O

The	O
`	O
.copy()	B-API
`	O
suggestion	O
indeed	O
solves	O
the	O
issue	O
.	O

Do	O
I	O
have	O
to	O
specific	O
the	O
dtypes	B-API
to	O
make	O
this	O
work	O
?	O

@USER	O
:	O
there	O
is	O
no	O
other	O
answer	O
that	O
I	O
can	O
see	O
that	O
mentions	O
`	O
.get	B-API
(	O
0	O
)`	O
.	O

`	O
string	O
`	O
is	O
not	O
a	O
dtype	B-API

What	O
is	O
the	O
dtype	B-API
of	O
`	O
year_week	O
`	O
?	O

I'm	O
trying	O
to	O
monkeypatch	O
how	O
`	O
pandas	O
`	O
Panel's	O
slicing	O
(	O
`	O
__getitem__	B-API
`)	O
.	O

Doing	O
so	O
changes	O
the	O
column's	O
dtype	B-API
to	O
`	O
object	O
`	O
.	O

That	O
doesn't	O
actually	O
surprise	O
me	O
too	O
much	O
,	O
to	O
be	O
honest	O
,	O
because	O
going	O
via	O
a	O
`	O
lambda	O
`	O
is	O
likely	O
to	O
be	O
slower	O
than	O
using	O
`	O
str.startswith	B-API
`	O
directly	O
,	O
but	O
it's	O
really	O
hard	O
to	O
guess	O
.	O

The	O
work-around	O
is	O
that	O
a	O
`	O
FixedLocator	B-API
`	O
should	O
also	O
be	O
used	O
.	O

On	O
my	O
machine	O
.iloc	B-API
tends	O
to	O
be	O
about	O
twice	O
as	O
fast	O
as	O
.loc	B-API
.	O

Automatically	O
inferring	O
dtypes	B-API
and	O
min_itemsize	O
on	O
large	O
datasets	O
iteratively	O

You	O
probably	O
want	O
`	O
dtypes	B-API
`	O
#CODE	O

Here	O
is	O
one	O
way	O
using	O
`	O
stack()	B-API
`	O
.	O

Interesting	O
,	O
so	O
is	O
`	O
.ix	B-API
`	O
the	O
only	O
way	O
of	O
changing	O
it	O
?	O

`	O
df	O
[	O
entities	O
]	O
.tolist()	B-API
`	O
seems	O
to	O
be	O
getting	O
me	O
somewhere	O
.	O

Can	O
I	O
just	O
ask	O
you	O
,	O
what	O
does	O
`	O
apply()	B-API
`	O
specifically	O
do	O
?	O

Gah	O
,	O
you're	O
right	O
--	O
I	O
took	O
your	O
advice	O
too	O
literally	O
and	O
called	O
`	O
fillna	B-API
`	O
_before_	O
`	O
assert_frame_check	O
`	O
,	O
so	O
I	O
missed	O
that	O
it	O
works	O
out	O
the	O
differences	O
.	O

y_labs	O
is	O
numpy.ndarray	B-API

I	O
try	O
to	O
specify	O
the	O
dtypes	B-API
when	O
converting	O
to	O
DF	O
,	O
but	O
not	O
quite	O
getting	O
it	O
:	O
#CODE	O

How	O
to	O
change	O
Pandas.DataFrame.resample	B-API
default	O
holiday	O
calendar	O
?	O

Pandas	O
package	O
offers	O
DataFrame.to_html()	B-API
method	O
.	O

(	O
when	O
using	O
`	O
asfreq	B-API
`	O
the	O
keyword	O
seems	O
to	O
be	O
`	O
method	O
`	O
(	O
not	O
`	O
fill_method	O
`	O
in	O
0.10	O
)	O

You	O
can	O
determine	O
which	O
backend	O
you	O
are	O
using	O
with	O
the	O
command	O
`	O
matplotlib.get_backend()	B-API
`	O
.	O

Compute	O
rolling_mean()	B-API
for	O
midpoints	O

using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O

`	O
DataFrame.drop_duplicates	B-API
`	O
is	O
a	O
method	O
,	O
you	O
need	O
to	O
call	O
it	O
.	O

File	O
"	O
C	O
:\	O
Python27\lib\	O
site-packages	O
\pandas\core\	O
groupby.py	O
"	O
,	O
line	O
278	O
,	O
in	O
get_group	B-API

`	O
df1	O
/	O
df2.ix	O
[:	O
,	O
df1.columns	O
]	O
.squeeze()	B-API
`	O
also	O
works	O
but	O
@USER	O
'	O
s	O
answer	O
is	O
much	O
nicer	O

`	O
subset	O
`	O
->	O
`	O
DataFrame.query()	B-API
`	O
and	O
`	O
with	O
`	O
->	O
`	O
DataFrame.eval()	B-API
`	O
is	O
the	O
way	O
I	O
was	O
thinking	O
about	O
how	O
the	O
`	O
pandas	O
`	O
methods	O
relate	O
to	O
the	O
corresponding	O
R	O
versions	O
.	O

Not	O
really	O
-	O
the	O
API	O
change	O
you're	O
referring	O
to	O
just	O
means	O
that	O
`	O
pandas.Series	B-API
`	O
subclasses	O
`	O
NDFrame	O
`	O
rather	O
than	O
directly	O
subclassing	O
`	O
numpy.ndarray	B-API
`	O
,	O
but	O
internal	O
storage	O
used	O
by	O
`	O
NDFrame	O
`	O
still	O
consists	O
of	O
`	O
numpy.ndarrays	O
`	O
.	O

In	O
R	O
,	O
I	O
can	O
do	O
this	O
simply	O
by	O
taking	O
the	O
`	O
outer()	B-API
`	O
products	O
:	O
#CODE	O

---->	O
8	O
quarter_score_diff	O
=	O
region	O
[(	O
region.Quradate	O
==	O
most_recent_date	O
)	O
or	O
(	O
region.Quradate	O
==	O
last_quarter	O
)]	O
.diff()	B-API

s_mask	O
=	O
pandas.concat	B-API
((	O
msk1	O
,	O
msk2	O
)	O
,	O
axis=1	O
)	O

@USER	O
This	O
was	O
a	O
Python	O
3	O
question	O
,	O
so	O
map()	B-API
isn't	O
good	O
enough	O
.	O

I	O
read	O
a	O
bit	O
about	O
the	O
category	O
dtype	B-API
in	O
pandas	O
-	O
does	O
this	O
make	O
output	O
file	O
sizes	O
smaller	O
too	O
or	O
just	O
in-memory	O
?	O

dtype	B-API
,	O
copy=copy	O
,	O
raise_on_error=raise_on_error	O
)	O

'	O
rpt_date	O
'	O
is	O
from	O
'	O
rpt_date	O
=	O
ori_rpt.groupby	O
(	O
'	O
STK_ID	O
')	O
.RPT_Date	O
.apply	B-API
(	O
__makeup_rpt_date_list__	O
)'	O
.	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O

I	O
think	O
that	O
predicting	O
the	O
dtype	B-API
may	O
not	O
be	O
possible	O
/	O
reasonable	O
on	O
larger	O
dataframes	O
,	O
especially	O
if	O
there	O
were	O
many	O
more	O
columns	O
than	O
in	O
this	O
toy	O
example	O
...	O

I	O
think	O
this	O
must	O
be	O
a	O
bug	O
with	O
MultiIndex.from_product()	B-API
because	O
the	O
long	O
version	O
,	O
using	O
MultiIndex.from_tuples()	B-API
works	O
:	O
#CODE	O

Doing	O
so	O
changes	O
the	O
column's	O
dtype	B-API
to	O
`	O
object	O
`	O
.	O

My	O
experience	O
has	O
been	O
with	O
`	O
read_csv	B-API
`	O
,	O
one	O
has	O
to	O
try	O
a	O
few	O
combinations	O
before	O
one	O
gets	O
what	O
one	O
wants	O
.	O

When	O
running	O
timeit's	O
on	O
numpy	O
ndarrays	O
or	O
matrices	O
of	O
dtype	B-API
int64	O
,	O
you	O
see	O
the	O
same	O
performance	O
lag	O
.	O

Essentially	O
,	O
the	O
``	O
hstack	B-API
``	O
approach	O
is	O
the	O
same	O
as	O
you	O
doing	O
the	O
job	O
of	O
``	O
FeatureUnion	O
``	O
manually	O
.	O

In	O
that	O
case	O
would	O
I	O
just	O
defer	O
to	O
it	O
for	O
boolean	O
vectors	O
and	O
things	O
like	O
`	O
iloc	B-API
`	O
?	O

I	O
was	O
just	O
going	O
to	O
suggest	O
rolling_apply	B-API
as	O
well	O
.	O

I'm	O
just	O
trying	O
to	O
replicate	O
behavior	O
of	O
the	O
`	O
drop_duplicates	B-API
`	O
,	O
except	O
that	O
original	O
row	O
should	O
also	O
be	O
dropped	O
.	O

No	O
,	O
it	O
just	O
can't	O
handle	O
the	O
string	O
dtypes	B-API
.	O

If	O
I	O
do	O
`	O
concs.iloc	O
[:	O
100000	O
]	O
.resample	B-API
(	O
'	O
5min	O
')`	O
the	O
problem	O
persists	O
.	O

Note	O
that	O
point	O
are	O
generated	O
with	O
linear	O
dependency	O
due	O
to	O
nontrivial	O
covariance	O
paramether	O
for	O
multivariate_normal	B-API
.	O

What	O
errors	O
are	O
you	O
getting	O
for	O
the	O
category	O
dtypes	B-API
?	O

your	O
timeit	O
with	O
.loc	B-API
is	O
VERY	O
odd	O
.	O
what	O
version	O
are	O
you	O
using	O
?	O

So	O
essentially	O
`	O
to_native_types	B-API
`	O
can	O
be	O
replaced	O
with	O
`	O
tolist	B-API
`	O
in	O
the	O
above	O
code	O
.	O

Perhaps	O
`	O
qcut()	B-API
`	O
is	O
what	O
you're	O
seeking	O
.	O

In	O
addition	O
these	O
dtypes	B-API

Shouldn't	O
`	O
df	O
[[	O
'	O
week1	O
'	O
,	O
'	O
week2	O
']]	O
.apply	B-API
(	O
lambda	O
x	O
:	O
(	O
x	O
-	O
x.mean()	O
)	O
/	O
x.std()	O
)`	O
work	O
?	O

As	O
an	O
alternative	O
you	O
can	O
do	O
this	O
as	O
a	O
`	O
pivot_table	B-API
`	O
:	O
#CODE	O

this	O
suggests	O
a	O
feature	O
:	O
``	O
.resample	B-API
(	O
'	O
D	O
'	O
,	O
how=	O
'	O
range	O
'	O
,	O
start=0	O
,	O
stop=3	O
)	O
.median()	B-API
``	O

using	O
`	O
.pivot	B-API
`	O
:	O
#CODE	O

You	O
can	O
achieve	O
desired	O
effect	O
using	O
agg()	B-API
.	O

This	O
Code	O
plots	O
some	O
boxplots	O
in	O
a	O
row	O
for	O
every	O
weekday	B-API
.	O

print	O
(	O
col	O
,	O
df	O
[	O
col	O
]	O
.dtype	B-API
)`	O
?	O

Have	O
you	O
tried	O
g_test.get_group	O
((	O
1	O
,	O
5	O
,	O
13	O
,	O
8))	O
[	O
"'	O
monthly_sales	O
"]	O
=	O
g_train.get_group	O
((	O
1	O
,	O
5	O
,	O
13	O
,	O
8))	O
.monthly_sales	O
.mean()	B-API
?	O

I	O
found	O
"	O
rolling_corr_pairwise	B-API
"	O
in	O
the	O
Pandas	O
documentation	O
.	O

Can	O
you	O
check	O
the	O
dtype	B-API
on	O
your	O
`	O
converted_dates	O
`	O
and	O
`	O
today_date	O
`	O
?	O

try	O
using	O
something	O
like	O
:	O
`	O
resampled_data.fillna	O
(	O
0	O
)	O
.plot()	B-API
`	O
and	O
i	O
think	O
you'll	O
see	O
what	O
you're	O
expecting	O
.	O

try	O
using	O
[	O
`	O
.apply	B-API
`]	O
(	O
#URL	O
)	O
,	O
with	O
`	O
axis=1	O
`	O

Wes's	O
answer	O
to	O
the	O
other	O
one	O
is	O
also	O
very	O
informative	O
(	O
although	O
iterrows	B-API
gets	O
the	O
job	O
done	O
for	O
now	O
)	O

I'm	O
working	O
with	O
really	O
large	O
CSV	O
files	O
and	O
want	O
to	O
know	O
if	O
pandas	O
'	O
`	O
to_sql	B-API
`	O
can	O
efficiently	O
handle	O
gigabytes	O
worth	O
of	O
CSV	O
?	O

These	O
solutions	O
worked	O
,	O
but	O
pandas	O
.cumprod()	B-API
turned	O
out	O
to	O
be	O
the	O
easiest	O
solution	O
.	O

table2	O
[	O
'	O
SUBDIVISION	O
']	O
.replace	B-API
(	O
df	O
[	O
'	O
NSUBDIVISION	O
']	O
.to_dict()	B-API
,	O
inplace=True	O
)	O

I	O
might	O
be	O
overlooking	O
something	O
,	O
but	O
I	O
think	O
using	O
`	O
.shift()	B-API
`	O
should	O
do	O
it	O
.	O

the	O
`	O
dtype=None	O
`	O
tells	O
`	O
genfromtxt	B-API
`	O
to	O
make	O
an	O
intelligent	O
guess	O
about	O
the	O
type	O
of	O
each	O
column	O
--	O
so	O
your	O
float-like	O
numbers	O
will	O
automatically	O
have	O
dtype	B-API
float	O
.	O

C	O
)	O
Pandas	O
'	O
`	O
get_dummies	B-API
`	O
#CODE	O

I	O
think	O
you	O
don't	O
need	O
the	O
`	O
to_datetime	B-API
`	O
bit	O
could	O
you	O
try	O
`	O
df	O
[	O
'	O
OEDatum	O
']	O
=	O
df	O
[[	O
'	O
OEDatum	O
'	O
,	O
'	O
OEUhrzeit	O
']]	O
.apply	B-API
(	O
lambda	O
x	O
:	O
dt.datetime.combine	O
(	O
x	O
[	O
'	O
OEDatum	O
']	O
.date()	B-API
,	O
x	O
[	O
'	O
OEUhrzeit	O
'])	O
,	O
axis=1	O
)`	O

dtype	B-API
=d	O
type	O
)	O

metals.ix	O
[	O
'	O
BI	O
'	O
,	O
'	O
Arsenic	O
,	O
Dissolved	O
']	O
.ix	B-API
[:	O
,	O
1	O
]	O

I	O
think	O
it's	O
more	O
pandorable	O
to	O
write	O
`	O
aapl.index.to_series()	O
.diff()	B-API
.mean()	B-API
`	O
or	O
`	O
.median()	B-API
`	O
.	O

I've	O
tried	O
.shift	B-API
(	O
1	O
)	O
within	O
the	O
for	O
loop	O
,	O
to	O
no	O
avail	O
:	O
#CODE	O

Could	O
you	O
edit	O
your	O
question	O
to	O
include	O
the	O
result	O
of	O
`	O
df	O
[	O
"	O
sex	O
"]	O
.head()	B-API
.values	B-API
`	O
before	O
you	O
do	O
your	O
mapping	O
?	O

b	O
=b	O
.as_matrix()	B-API
`	O

`	O
s	O
=	O
s.resample	O
(	O
'	O
M	O
'	O
,	O
fill_method=	O
'	O
ffill	B-API
')`	O

Oh	O
,	O
I	O
misunderstood	O
,	O
`	O
pct_change	B-API
`	O
calculates	O
the	O
row-over-row	O
change	O
.	O

Perhaps	O
`	O
.transform	B-API
`	O
can	O
help	O
with	O
this	O
:	O
#CODE	O

Using	O
`	O
DataFrame.where	B-API
`	O
'	O
s	O
`	O
other	O
`	O
argument	O
and	O
`	O
pandas.concat	B-API
`	O
:	O
#CODE	O

set_index	B-API
equivalent	O
for	O
columns	O
headings	O

I	O
was	O
assuming	O
that	O
under	O
the	O
hood	O
pandas	O
was	O
using	O
agg_general	O
and	O
simply	O
only	O
calling	O
it	O
with	O
numeric	O
dtypes	B-API
.	O

Is	O
there	O
a	O
way	O
to	O
manually	O
change	O
the	O
dtype	B-API
to	O
numeric	O
?	O

`	O
nx.set_edge_attributes	O
(	O
G	O
,	O
'	O
myattr	O
'	O
,	O
df	O
[	O
'	O
attribute	O
']	O
.astype	B-API
(	O
int	O
)	O
.to_dict()	B-API
)`	O
works	O
fine	O
but	O
then	O
`	O
nx.write_gexf()	O
`	O
complains	O
.	O

I	O
did	O
turn	O
the	O
`	O
activity_month	O
`	O
column	O
in	O
to	O
a	O
datetime	O
dtype	B-API
.	O

Do	O
you	O
maybe	O
have	O
insight	O
why	O
the	O
groupby()	B-API
.apply()	B-API
allows	O
different	O
dimensions	O
to	O
be	O
returned	O
,	O
while	O
the	O
DataFrame.apply()	B-API
does	O
not	O
?	O

dtype	B-API
=	O
'	O
object	O
')`	O

Note	O
:	O
you	O
need	O
pandas	O
0.15.2	O
+	O
for	O
this	O
`	O
dtype	B-API
`	O
argument	O
.	O

However	O
,	O
I	O
would	O
like	O
the	O
layout	O
to	O
be	O
generated	O
from	O
the	O
number	O
of	O
levels	O
in	O
the	O
categorical	B-API
conditioning	O
(	O
or	O
"	O
by	O
")	O
variable	O
(	O
s	O
)	O
.	O

`	O
grouped.unstack	O
(	O
'	O
two	O
')	O
.fillna	B-API
(	O
0	O
)	O
.stack()	B-API
`	O

I'm	O
getting	O
"	O
AttributeError	O
:	O
'	O
StringMethods	O
'	O
object	O
has	O
no	O
attribute	O
'	O
get_dummies	B-API
'"	O
.	O

Python	O
Pandas	O
:	O
rolling_kurt	B-API
vs	O
.	O
scipy.stats.kurtosis	O

I	O
tried	O
using	O
DataFrame.replace()	B-API
and	O
DataFrame.assign()	B-API
methods	O
.	O

Below	O
is	O
the	O
quotation	O
for	O
what	O
pandas.Series.apply	B-API
should	O
expect	O
:	O

`	O
.ix	B-API
`	O
is	O
actual	O
integer-based	O
indexing	O
.	O

Specifying	O
dtypes	B-API
worked	O
.	O

It's	O
much	O
easier	O
just	O
to	O
let	O
`	O
read_csv	B-API
`	O
infer	O
the	O
column	O
dtypes	B-API
.	O

You	O
need	O
`	O
.loc	B-API
`	O
(	O
label-based	O
)	O
instead	O
of	O
`	O
.iloc	B-API
`	O
(	O
position-based	O
)	O
.	O

`	O
x	O
=	O
eq_data	O
[	O
'	O
longitude	O
']	O
.values	B-API
;	O
y=	O
eq_data	O
[	O
'	O
latitude	O
']	O
.values	B-API
;	O
map2.plot	O
(	O
x	O
,	O
y	O
,	O
marker=	O
'	O
0	O
'	O
,	O
markercolor=	O
'	O
red	O
'	O
,	O
markersize=6	O
);	O
`	O

@USER	O
yes	O
that	O
would	O
not	O
work	O
,	O
I	O
think	O
what	O
you	O
want	O
is	O
just	O
g	O
=	O
df	O
[	O
df	O
[	O
'	O
rating	O
']	O
.notnull()	B-API
]	O
.groupby	B-API
(	O
'	O
movie	O
')	O
.mean()	B-API
.	O

@USER	O
btw	O
,	O
not	O
sure	O
why	O
,	O
but	O
`	O
read_fwf	B-API
`	O
doesn't	O
seem	O
to	O
support	O
`	O
dtype	B-API
`	O
even	O
though	O
it's	O
in	O
the	O
document	O
#URL	O

`	O
--->	O
11	O
UngroupedResGenesLineage.groupby	O
(	O
'	O
Lineage	O
')	O
.apply	B-API
(	O
func	O
)	O
.reset_index()	B-API
.drop	B-API
(	O
'	O
level_1	O
'	O
,	O
axis=1	O
)	O

The	O
behavior	O
of	O
`	O
pandas.DataFrame.apply	B-API
(	O
myfunc	O
)`	O
is	O
application	O
of	O
`	O
myfunc	O
`	O
along	O
columns	O
.	O

As	O
a	O
bonus	O
,	O
I	O
still	O
see	O
different	O
recommendation	O
results	O
when	O
using	O
fillna	B-API
(	O
0	O
)	O
with	O
Pearson	O
correlation	O
.	O

btw	O
,	O
is	O
.agg()	B-API
the	O
same	O
as	O
.aggregate()	B-API
?	O

Of	O
course	O
you	O
can	O
`	O
drop_duplicates	B-API
`	O
before	O
of	O
after	O
joining	O

Let's	O
say	O
I	O
create	O
5	O
quantiles	O
using	O
pandas.qcut	B-API
:	O
#CODE	O

:)	O
I	O
was	O
just	O
about	O
to	O
comment	O
that	O
pivot_table	B-API
is	O
much	O
nicer	O
before	O
you	O
deleted	O
your	O
answer	O
!!	O

see	O
[	O
.filter	B-API
]	O
(	O
#URL	O
);	O
it	O
has	O
support	O
for	O
regex	O

This	O
effectively	O
replaces	O
the	O
need	O
for	O
`	O
.xs	B-API
`	O
.	O

Is	O
there	O
a	O
way	O
to	O
obtain	O
non-negative	O
integers	O
as	O
the	O
interval	O
boundaries	O
directly	O
with	O
`	O
pandas.cut()	B-API
`	O
without	O
using	O
numpy	O
?	O

RESOLVE	O
D:	O
I	O
was	O
making	O
another	O
,	O
equally	O
clowny	O
,	O
mistake	O
and	O
calling	O
all()	B-API
before	O
calling	O
fillna	B-API
so	O
many	O
of	O
the	O
rows	O
were	O
blank	O
.	O

Now	O
,	O
adding	O
the	O
cumsum	B-API
of	O
this	O
gets	O
you	O
the	O
result	O
you're	O
after	O
:	O
#CODE	O

@USER	O
Using	O
JohnE's	O
suggestions	O
I	O
appended	O
my	O
original	O
post	O
with	O
.info()	B-API
.	O

Just	O
updated	O
so	O
that	O
there	O
is	O
only	O
one	O
call	O
to	O
`	O
stack()	B-API
`	O
.	O

The	O
rolling_mean	B-API
and	O
ewma	B-API
functions	O
in	O
pandas	O
are	O
not	O
meant	O
for	O
randomly	O
spaced	O
x-values	O
,	O
so	O
they	O
are	O
not	O
really	O
appropriate	O
.	O

Alternatively	O
,	O
you	O
could	O
access	O
`	O
df	O
[	O
'	O
Weekdays	O
']`	O
before	O
using	O
`	O
.loc	B-API
`	O
:	O
#CODE	O

I	O
have	O
run	O
into	O
an	O
issue	O
when	O
comparing	O
two	O
`	O
DatetimeIndex	B-API
`'	O
s	O
with	O
different	O
lengths	O
in	O
an	O
`	O
assert	O
`	O
like	O
the	O
following	O
:	O
#CODE	O

but	O
I	O
would	O
like	O
to	O
understand	O
why	O
this	O
behavior	O
happens	O
when	O
doing	O
dict-like	O
slicing	O
(	O
e.g.	O
`	O
df	O
[	O
'	O
L	O
']	O
[	O
'	O
Five	O
']`)	O
and	O
not	O
when	O
using	O
the	O
`	O
.loc	B-API
`	O
slicing	O
.	O

I	O
couldn't	O
think	O
of	O
a	O
nice	O
way	O
to	O
vectorize	B-API
the	O
answer	O
,	O
but	O
here's	O
a	O
hack	O
that	O
gets	O
the	O
basic	O
logic	O
.	O

Oh	O
cripes	O
it	O
looks	O
like	O
there	O
is	O
a	O
bug	O
in	O
`	O
get_dummies	B-API
`	O
,	O
it's	O
not	O
ignoring	O
the	O
NaN	O
but	O
rather	O
doing	O
something	O
strange	O
...	O

`	O
dropna	B-API
`	O
takes	O
care	O
of	O
the	O
nulls	O
produced	O
for	O
gene	O
c	O
.	O

dtype	B-API
:	O
category	O

Was	O
thinking	O
to	O
a	O
reindex_like	B-API
perhaps	O
?	O

See	O
also	O
the	O
documentation	O
page	O
of	O
`	O
to_sql	B-API
`	O
.	O

pandas	O
rolling_mean	B-API
of	O
timedelta64	O
produces	O
float64	O

That	O
is	O
what	O
`	O
pandas.factorize	B-API
`	O
does	O
:	O
#CODE	O

@USER	O
.m	O
I	O
need	O
a	O
runnable	O
example	O
that	O
uses	O
`	O
applymap	B-API
`	O
to	O
assist	O
further	O
.	O

Using	O
an	O
`	O
HDFStore	B-API
`	O
like	O
below	O
changes	O
nothing	O
.	O

@USER	O
I	O
want	O
to	O
do	O
something	O
very	O
similar	O
to	O
this	O
however	O
I	O
am	O
using	O
dataframe.boxplot	B-API
(	O
by=	O
'	O
column1	O
')	O
this	O
grouping	O
doesn't	O
seem	O
to	O
work	O
with	O
your	O
example	O
.	O

I	O
tried	O
using	O
any()	B-API
and	O
am	O
having	O
immense	O
difficulty	O
with	O
this	O
.	O

I	O
tried	O
what	O
many	O
other	O
answers	O
suggested	O
with	O
`	O
figure.tight_layout()	B-API
`	O
to	O
no	O
avail	O
.	O

I	O
also	O
tried	O
specifying	O
dtype	B-API
by	O
column	O
using	O
a	O
dictionary	O
:	O
#CODE	O

Then	O
I	O
create	O
the	O
pivot_table	B-API
shown	O
above	O
.	O

So	O
depending	O
on	O
what	O
you	O
want	O
to	O
achieve	O
,	O
its	O
easy	O
to	O
do	O
an	O
overlap	O
,	O
by	O
using	O
rolling_mean	B-API

I	O
learned	O
this	O
cute	O
utilization	O
of	O
`	O
concat()	B-API
`	O
from	O
HYRY	O
here	O
.	O

I	O
have	O
tried	O
a	O
`	O
.replace	B-API
`	O
however	O
it	O
did	O
not	O
work	O
.	O

`	O
cat2	O
`	O
is	O
an	O
`	O
object	O
`	O
`	O
dtype	B-API
`	O
so	O
it	O
is	O
probably	O
a	O
string	O
,	O
I	O
think	O
you	O
want	O
:	O
#CODE	O

`	O
pandas.qcut	B-API
`	O
has	O
a	O
`	O
precision	O
`	O
parameter	O
for	O
the	O
bin	O
representation	O
that	O
defaults	O
to	O
3	O
-	O
you	O
may	O
need	O
a	O
higher	O
number	O
(	O
see	O
docs	O
)	O
.	O

Then	O
modify	O
with	O
`	O
iloc	B-API
`	O
and	O
integer	O
indexes	O
:	O
#CODE	O

`	O
dropna	B-API
`	O
takes	O
care	O
of	O
the	O
nulls	O
produced	O
for	O
gene	O
c	O
.	O

would	O
resample()	B-API
be	O
able	O
to	O
create	O
the	O
5min	O
bins	O
?	O

Specifying	O
dtype	B-API
in	O
pandas	O

Can	O
you	O
call	O
the	O
python	O
built-in	O
`	O
type()	O
`	O
on	O
one	O
of	O
these	O
elements	O
(	O
`	O
type	O
(	O
element	O
)`)	O
that	O
has	O
`	O
dtype	B-API
(	O
'	O
O	O
')`	O
--	O
It	O
doesn't	O
look	O
like	O
numpy	O
knows	O
it's	O
a	O
string	O
.	O

Meanwhile	O
,	O
I	O
would	O
suggest	O
using	O
the	O
`	O
Panel.select	B-API
`	O
method	O
:	O
#CODE	O

`	O
DataFrame.replace()	B-API
`	O
:	O
#CODE	O

In	O
Pandas	O
,	O
how	O
to	O
re-determine	O
the	O
dtypes	B-API
of	O
columns	O
after	O
dropna	B-API
?	O

*	O
`	O
include_start	O
`	O
and	O
`	O
include_end	O
`	O
are	O
optional	O
boolean	O
arguments	O
of	O
`	O
indexer_between_time	B-API
`	O
.	O

Trying	O
the	O
same	O
with	O
`	O
.apply	B-API
`	O
would	O
give	O
`	O
NaNs	O
`	O
in	O
`	O
sum_C	O
`	O
.	O

`'	O
,	O
'	O
.join	B-API
(	O
df	O
[	O
"	O
city	O
"]	O
.values	B-API
)`	O
--	O
this	O
will	O
return	O
a	O
comma-separated	O
string	O
.	O

---->	O
2	O
s=	O
"	O
"	O
.join	B-API
(	O
x	O
)	O

An	O
alterantive	O
is	O
to	O
give	O
a	O
dtype	B-API
for	O
each	O
column	O
.	O

I	O
also	O
check	O
the	O
dtype	B-API
of	O
the	O
problem	O
column	O
:	O

HDFStore	B-API
:	O
table.select	O
and	O
RAM	O
usage	O

HDFStore	B-API
(	O
and	O
HDF5	O
in	O
general	O
)	O
are	O
row	O
oriented	O
.	O

loadtxt	B-API
is	O
working	O
great	O
!	O

Certain	O
serialization	O
formats	O
,	O
e.g.	O
`	O
HDFStore	B-API
`	O
stores	O
the	O
strings	O
as	O
fixed-length	O
strings	O
on	O
disk	O
though	O
.	O

Note	O
:	O
the	O
increase	O
in	O
performance	O
depends	O
on	O
dtypes	B-API
.	O

This	O
might	O
also	O
be	O
helpful	O
for	O
reading	O
strings	O
with	O
`	O
genfromtxt	B-API
`	O
:	O
#URL	O

[	O
PeriodIndex	O
]	O
(	O
#URL	O
)	O
can	O
represent	O
longer	O
timespans	O
than	O
DatetimeIndex	B-API
.	O

Try	O
using	O
.loc	B-API
[	O
row_indexer	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O

numpy.sum	B-API
behaves	O
differently	O
on	O
numpy.array	B-API
vs	O
pandas.DataFrame	B-API

iloc	B-API
:	O
work	O
on	O
position	O

Also	O
,	O
what	O
about	O
.map	B-API
vs	O
.apply	B-API
?	O

Try	O
using	O
.loc	B-API
[	O
row_index	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O

so	O
``	O
df	O
[	O
col	O
]	O
.loc	B-API
[	O
i	O
]``	O
is	O
*	O
chained	O
assignment*	O
.	O

Pandas	O
DataFrame.apply()	B-API
and	O
mibian	O

``	O
p.loc	O
[:	O
,	O
:	O
,	O
indexer	O
]	O
=	O
value	O
``	O
is	O
what	O
you	O
want	O
(	O
``	O
minor_xs	B-API
``	O
is	O
a	O
convience	O
feature	O
)	O

As	O
requested	O
in	O
the	O
comments	O
,	O
subset	O
[:	O
1	O
]	O
.to_dict()	B-API
outputs	O
:	O
#CODE	O

`	O
df	O
[	O
"	O
col2	O
"]	O
.apply	B-API
(	O
lambda	O
x	O
:	O
di.get	O
(	O
x	O
,	O
x	O
))`	O
works	O
!	O

Does	O
using	O
pandas.cut	B-API
change	O
the	O
structure	O
of	O
a	O
data.frame	O
.	O

For	O
some	O
reason	O
it	O
is	O
related	O
to	O
the	O
line	O
you	O
just	O
removed	O
`	O
labels	O
=	O
[	O
"	O
{	O
left	O
:	O
,.	O
0f	O
}	O
to	O
{	O
right	O
:	O
,.	O
0f}	O
"	O
.format	B-API
(	O
left=yr	O
[	O
0	O
]	O
,	O
right=yr	O
[	O
0	O
]	O
+yr	O
[	O
1	O
]	O
-1	O
)	O
for	O
yr	O
in	O
joint	O
]`	O
.	O

I've	O
also	O
tried	O
this	O
using	O
this	O
with	O
a	O
`	O
dtype	B-API
`	O
of	O
`	O
numpy.int32	O
`	O
or	O
`	O
numpy.int64	O
`	O
.	O

the	O
new	O
`	O
interpolate()	B-API
`	O
is	O
on	O
0.13.0	O
.	O

To	O
make	O
this	O
a	O
little	O
more	O
concrete	O
,	O
this	O
is	O
what	O
it	O
looks	O
like	O
for	O
the	O
8th	O
iteration	O
(	O
and	O
the	O
`	O
rolling_corr	B-API
`	O
uses	O
a	O
window	O
of	O
3	O
since	O
this	O
dataset	O
has	O
only	O
4	O
rows	O
):	O
#CODE	O

Try	O
this	O
:	O
`	O
dataframe.replace	B-API
(	O
{	O
"	O
rea	O
"	O
:	O
""	O
}	O
,	O
regex=True	O
)`	O

with	O
column	O
dtypes	B-API
:	O
#CODE	O

It	O
is	O
a	O
perfect	O
usecase	O
for	O
`	O
pivot_table	B-API
`	O
:	O
#CODE	O

call	O
`	O
drop_duplicates()	B-API
`	O
after	O
`	O
concat()	B-API
`	O
:	O
#CODE	O

Even	O
if	O
it	O
doesn't	O
default	O
to	O
inplace	O
,	O
shouldn't	O
it	O
provide	O
an	O
inplace	O
parameter	O
the	O
way	O
replace()	B-API
does	O
?	O

Note	O
:	O
you	O
can	O
do	O
this	O
without	O
the	O
lambda	O
:	O
just	O
do	O
`	O
.apply	B-API
(	O
ast.literal_eval	O
)`	O

pattern	O
(	O
such	O
as	O
the	O
index-by-column-then-index-by	O
-	O
`	O
iloc	B-API
`	O
pattern	O
used	O
here	O
)	O
for	O
assignments	O
,	O
since	O
it	O
does	O
not	O

As	O
written	O
,	O
rolling_mean()	B-API
will	O
work	O
.	O

No	O
,	O
it	O
just	O
can't	O
handle	O
the	O
string	O
dtypes	B-API
.	O

The	O
trick	O
here	O
lies	O
in	O
the	O
`	O
.apply()	B-API
`	O
method	O
and	O
the	O
`	O
.groupby()	B-API
`	O
method	O
.	O

`	O
s	O
=	O
df	O
[	O
'	O
m	O
']	O
.replace	B-API
(	O
{	O
'	O
March	O
'	O
:	O
0	O
,	O
'	O
April	O
'	O
:	O
1	O
,	O
'	O
Dec	O
'	O
:	O
3}	O
)`	O
works	O
for	O
line	O
2	O
as	O
well	O
--	O
just	O
for	O
the	O
sake	O
of	O
anyone	O
learning	O
pandas	O
like	O
me	O

Don't	O
focus	O
on	O
having	O
the	O
'	O
right	O
dtype	B-API
'	O
,	O
dtypes	B-API
are	O
strange	O
.	O

I	O
am	O
particularly	O
talking	O
about	O
Pandas	O
version	O
0.11	O
as	O
I	O
am	O
busy	O
replacing	O
my	O
uses	O
of	O
.ix	B-API
with	O
either	O
.loc	B-API
or	O
.iloc	B-API
.	O

Doing	O
tz_localize	B-API
raises	O
an	O
exception	O
if	O
it's	O
already	O
there	O
,	O
and	O
tz_convert	B-API
raises	O
an	O
exception	O
if	O
it's	O
not	O
.	O

For	O
some	O
reason	O
it	O
is	O
related	O
to	O
the	O
line	O
you	O
just	O
removed	O
`	O
labels	O
=	O
[	O
"	O
{	O
left	O
:	O
,.	O
0f	O
}	O
to	O
{	O
right	O
:	O
,.	O
0f}	O
"	O
.format	B-API
(	O
left=yr	O
[	O
0	O
]	O
,	O
right=yr	O
[	O
0	O
]	O
+yr	O
[	O
1	O
]	O
-1	O
)	O
for	O
yr	O
in	O
joint	O
]`	O
.	O

Its	O
already	O
marked	O
as	O
an	O
issue	O
:	O
#URL	O
the	O
numerical	O
instability	O
is	O
due	O
to	O
the	O
naive	O
implementation	O
of	O
the	O
algorithm	O
.	O
for	O
example	O
,	O
rolling_var	B-API
has	O
already	O
been	O
fixed	O
for	O
this	O
.	O
pull	O
requests	O
are	O
welcome	O
!	O

Am	O
I	O
using	O
replace()	B-API
incorrectly	O
?	O

The	O
rolling_mean	B-API
and	O
ewma	B-API
functions	O
in	O
pandas	O
are	O
not	O
meant	O
for	O
randomly	O
spaced	O
x-values	O
,	O
so	O
they	O
are	O
not	O
really	O
appropriate	O
.	O
