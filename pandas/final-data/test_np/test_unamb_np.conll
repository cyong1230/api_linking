`	O
fromiter	B-API
`	O
wants	O
a	O
1d	O
input	O
,	O
e.g.	O
`	O
[	O
1	O
,	O
2	O
,	O
3	O
]`	O
(	O
or	O
the	O
generator	O
equivalent	O
)	O
.	O

read	O
more	O
:	O
take()	B-API

For	O
this	O
I'm	O
using	O
an	O
instance	O
of	O
the	O
`	O
numpy	O
`	O
class	O
`	O
RandomState	B-API
`	O
.	O

You	O
can	O
write	O
a	O
thinly	O
wrapped	O
subclass	O
to	O
`	O
np.ndarray	B-API
`	O
.	O

Using	O
`	O
ndarray.reshape	B-API
`	O
#CODE	O

E.g.	O
this	O
works	O
in	O
the	O
interpreter	O
:	O
`	O
>>>	O
a	O
=	O
np.arange	B-API
(	O
10	O
,	O
dtype=float	O
)	O
.resize	B-API
(	O
1	O
,	O
5	O
)`	O
,	O
because	O
the	O
interpreter	O
doesn't	O
"	O
see	O
"	O
the	O
intermediate	O
value	O
.	O

I	O
attempted	O
your	O
suggestion	O
but	O
got	O
stuck	O
trying	O
to	O
iterate	O
through	O
the	O
existing	O
dtype	B-API
.	O

`	O
numpy.setdiff1d	B-API
(	O
a	O
,	O
a	O
[	O
sel_id	O
])`	O
should	O
do	O
the	O
trick	O
.	O

Instead	O
of	O
disabling	O
the	O
behavior	O
you	O
could	O
try	O
using	O
np.select	B-API
:	O

+1	O
I	O
liked	O
you	O
approach	O
,	O
but	O
how	O
to	O
make	O
`	O
np.copyto()	B-API
`	O
work	O
with	O
a	O
memoryvew	O
?	O

Just	O
import	O
Decimal	O
and	O
for	O
the	O
printing	O
just	O
write	O
print	O
Decimal	O
(	O
ndarray	B-API
[	O
i	O
])	O
.	O

Or	O
,	O
for	O
that	O
matter	O
,	O
numpy.genfromtxt	B-API
.	O

glad	O
to	O
hear	O
it	O
-	O
I	O
only	O
recently	O
found	O
out	O
about	O
`	O
np.einsum	B-API
`	O
myself	O
,	O
and	O
it	O
has	O
rocked	O
my	O
world	O
ever	O
since	O

The	O
`	O
dtype	B-API
`	O
could	O
be	O
deduced	O
from	O
one	O
(	O
or	O
more	O
)	O
of	O
the	O
dictionary	O
items	O
:	O
#CODE	O

I	O
didn't	O
realize	O
`	O
array_split	B-API
`	O
existed	O
!	O

However	O
,	O
in	O
that	O
case	O
,	O
you	O
could	O
just	O
do	O
:	O
(	O
`	O
searchsorted	B-API
`	O
uses	O
bisection	O
)	O
#CODE	O

Btw	O
.	O
you	O
can	O
also	O
implicitly	O
force	O
the	O
`	O
dtype	B-API
`	O
to	O
be	O
`	O
float	O
`	O
when	O
using	O
dots	O
:	O
#CODE	O

dtypes	B-API
.	O

I	O
would	O
prefer	O
using	O
the	O
xor	O
ufunc	O
I	O
think	O
,	O
which	O
is	O
`	O
bitwise_xor	B-API
`	O
(	O
or	O
`	O
logical_xor	B-API
`)	O
:	O
#CODE	O

This	O
is	O
the	O
root	O
of	O
why	O
your	O
`	O
fromarrays	B-API
`	O
works	O
,	O
but	O
not	O
the	O
`	O
append_fields	O
`	O
.	O

The	O
dtype	B-API
should	O
be	O
big	O
endian	O
.	O

parameterArray	O
+=	O
line.split()	O
\nline	O
=	O
self.inputBuffer.next()	O
\	O
nnp.parameterArray	O
=	O
np.array	B-API
(	O
parameterArray	O
)	O

As	O
JoshAdel	O
points	O
out	O
,	O
`	O
vectorize	B-API
`	O
wraps	O
`	O
frompyfunc	B-API
`	O
.	O

Sorry	O
,	O
the	O
line	O
was	O
output	O
[	O
i	O
,	O
j	O
]	O
=	O
np.sum	B-API
(	O
ssd_difference	O
[	O
#URL	O
(	O
)	O
)	O

(	O
or	O
`	O
np.array	B-API
([[	O
1	O
]	O
,	O
[	O
2	O
]	O
,	O
[	O
3	O
]	O
,	O
[	O
4	O
]])	O
.shape	B-API
`)	O

Thank	O
you	O
for	O
the	O
great	O
tipp	O
with	O
`	O
plt.hist	B-API
(	O
img.ravel()	O
)`	O
!	O

The	O
`	O
recarray	B-API
`	O
class	O
accepts	O
an	O
aligned	O
parameter	O
,	O
but	O
looks	O
to	O
lose	O
it	O
in	O
`	O
format_parser	B-API
`	O
.	O

In	O
case	O
someone	O
comes	O
past	O
this	O
,	O
numpy	O
(	O
as	O
of	O
1.8	O
I	O
think	O
)	O
support	O
higher	O
that	O
2D	O
generation	O
of	O
position	O
grids	O
with	O
meshgrid	B-API
.	O

`	O
numpy.random.choice	B-API
`	O
is	O
not	O
implemented	O
in	O
Python	O
but	O
in	O
a	O
`	O
.pyx	O
`	O
file	O
which	O
needs	O
to	O
be	O
compiled	O
to	O
C	O
using	O
Cython	O
.	O

A	O
plain	O
`	O
.copy	B-API
`	O
did	O
work	O
for	O
me	O
.	O

`	O
A	O
[	O
np.ix_	B-API
(	O
x	O
,	O
y	O
)]`	O

einsum	B-API
:	O
5.2	O
s	O

10**423	O
exceeds	O
the	O
largest	O
int	O
representable	O
as	O
an	O
integer	O
(	O
or	O
float	O
)	O
NumPy	O
dtype	B-API
,	O
so	O
there	O
is	O
no	O
point	O
in	O
using	O
NumPy	O
here	O
:	O
`	O
np.iinfo	B-API
(	O
'	O
int64	O
')	O
.max	B-API
<	O
10**423	O
`	O
.	O

Probably	O
,	O
better	O
performance	O
is	O
by	O
using	O
`	O
numpy.fromiter	B-API
`	O
:	O
#CODE	O

Why	O
are	O
the	O
polyfit	B-API
constants	O
from	O
the	O
third	O
case	O
listed	O
as	O
NAN	O
?	O

Try	O
`	O
numpy.array_split	B-API
`	O
.	O

Using	O
np.repeat	B-API
on	O
sub-arrays	O

shows	O
that	O
'	O
region	O
'	O
has	O
an	O
`	O
object	O
`	O
dtype	B-API
:	O
#CODE	O

What	O
I	O
am	O
looking	O
for	O
is	O
something	O
along	O
the	O
original	O
functionality	O
of	O
`	O
np.unique	B-API
`	O
#CODE	O

In	O
my	O
opinion	O
,	O
np.matrix	B-API
should	O
override	O
for	O
addition	O
and	O
subtraction	O
as	O
well	O
.	O

or	O
`	O
np.vstack	B-API
`	O
,	O
`	O
np.dstack	B-API
`	O
`	O
np.r_	B-API
`	O
,	O
`	O
np.c_	B-API
`	O
,	O
`	O
np.concatenate	B-API
`	O
depending	O
on	O
the	O
desired	O
shapes	O
.	O

TypeError	O
when	O
using	O
SymPy	O
matrices	O
for	O
numpy.linalg.eig	B-API

Doing	O
`	O
a.astype	O
(	O
float	O
)`	O
actually	O
creates	O
a	O
*	O
new	O
*	O
ndarray	B-API
which	O
is	O
of	O
type	O
`	O
float	O
`	O
.	O

Trying	O
to	O
vectorize	B-API
the	O
code	O
also	O
resulted	O
in	O
very	O
poor	O
performance	O
,	O

Also	O
look	O
into	O
the	O
genfromtxt	B-API
and	O
loadtxt	B-API
family	O
of	O
Numpy	O
functions	O
.	O

`	O
coll	O
[	O
1	O
]	O
.set_color	B-API
(	O
"	O
r	O
")	O
#	O
this	O
does	O
not	O
work	O
,	O
coll	O
not	O
indexable	O
this	O
way	O
`	O

The	O
`	O
testing.assert_equal	B-API
`	O
approach	O
is	O
almost	O
good	O
,	O
except	O
that	O
it	O
presumably	O
fails	O
if	O
`	O
__debug__	O
`	O
is	O
False	O
!	O

I've	O
just	O
checked	O
and	O
found	O
out	O
that	O
my	O
implementation	O
is	O
about	O
2.x	O
times	O
*	O
faster	O
*	O
than	O
using	O
`	O
numpy.convolve	B-API
`	O
.	O

Not	O
as	O
concise	O
as	O
I	O
wanted	O
(	O
I	O
was	O
experimenting	O
with	O
`	O
mask_indices	B-API
`	O
)	O
,	O
but	O
this	O
will	O
also	O
do	O
the	O
work	O
:	O
#CODE	O

The	O
documentation	O
of	O
`	O
numpy.nonzero()	B-API
`	O
describes	O
how	O
its	O
result	O
must	O
be	O
interpreted	O
.	O

scikits-learn	O
pca	B-API
dimension	O
reduction	O
issue	O

`	O
np.mean	B-API
`	O
can	O
also	O
preserve	O
dimensions	O
if	O
needed	O
.	O

Are	O
there	O
alternatives	O
to	O
do	O
the	O
sorts	O
of	O
things	O
`	O
einsum	B-API
`	O
can	O
do	O
with	O
sparse	O
matrices	O
?	O

Your	O
immediate	O
problem	O
is	O
`	O
numpy.putmask	B-API
`	O
.	O

why	O
not	O
`	O
np.array	B-API
([	O
o.value1	O
for	O
o	O
in	O
objects	O
])`	O
?	O

In	O
a	O
comment	O
to	O
`	O
@USER	O
`	O
s	O
answer	O
I	O
suggested	O
`	O
np.delete	B-API
`	O
.	O

I	O
have	O
a	O
`	O
numpy.ndarray	B-API
`	O
.	O

I	O
believe	O
it	O
comes	O
down	O
to	O
the	O
fact	O
that	O
Python	O
calls	O
a	O
`	O
__getitem__	B-API
`	O
on	O
your	O
objects	O
and	O
treats	O
the	O
entire	O
block	O
of	O
code	O
of	O
`	O
for	O
`	O
loop	O
as	O
an	O
inline	O
statement	O
.	O

In	O
the	O
Notes	O
section	O
to	O
column_stack	B-API
,	O
it	O
points	O
out	O
this	O
:	O

`	O
logical_or	B-API
(	O
a	O
,	O
logical_or	B-API
(	O
b	O
,	O
c	O
))`	O

How	O
about	O
reading	O
them	O
in	O
correctly	O
as	O
numpy.datetime64	O
objects	O
using	O
numpy.loadtxt	B-API
(	O
they	O
are	O
coming	O
from	O
a	O
csv	O
file	O
)	O
?	O

Also	O
-	O
I	O
see	O
that	O
np.getfromtxt()	O
has	O
a	O
'	O
dtype	B-API
'	O
option	O
which	O
allows	O
the	O
user	O
to	O
specify	O
the	O
datatype	O
of	O
each	O
column	O
.	O

No	O
worries	O
,	O
the	O
dtype	B-API
is	O
inferred	O
as	O
`	O
int64	O
`	O
unless	O
you	O
pass	O
it	O
explicitly	O

whats	O
the	O
result	O
of	O
`	O
print	O
a	O
`	O
after	O
`	O
a	O
=	O
np.loadtxt	B-API
`	O

Keep	O
in	O
mind	O
that	O
`	O
np.cov	B-API
`	O
is	O
basically	O
doing	O
`	O
data.dot	O
(	O
data.T	O
)`	O
.	O

If	O
you	O
want	O
to	O
vectorize	B-API
operations	O
,	O
you	O
need	O
to	O
think	O
in	O
terms	O
of	O
these	O
higher	O
dimensional	O
arrays	O
.	O

Does	O
`	O
s2	O
=	O
pd.Series	B-API
(	O
s	O
,	O
dtype	B-API
=o	O
bject	O
)`	O
work	O
?	O

`	O
PyArray_DATA	B-API
`	O
is	O
defined	O
in	O

`	O
a	O
[:	O
,	O
:	O
,	O
5	O
]	O
.shape	B-API
=	O
(	O
10	O
,	O
10	O
,	O
1	O
)`	O

Can	O
you	O
print	O
`	O
datas	O
[	O
0	O
]	O
.shape	B-API
`	O
?	O

actually	O
used	O
is	O
this	O
line	O
within	O
the	O
definition	O
for	O
`	O
np.array_repr	B-API
`	O

That's	O
why	O
`	O
dstack	B-API
`	O
behaves	O
the	O
way	O
it	O
does	O
.	O

>>>	O
x	O
=	O
np.asanyarray	B-API
(	O
[	O
]	O
,	O
dtype=	O
'	O
float64	O
')	O

This	O
doesn't	O
work	O
for	O
floating	O
point	O
types	O
(	O
it	O
will	O
not	O
consider	O
+	O
0.0	O
and	O
-	O
0.0	O
the	O
same	O
value	O
)	O
,	O
and	O
`	O
np.intersect1d	B-API
`	O
uses	O
sorting	O
,	O
so	O
it	O
is	O
has	O
linearithmic	O
,	O
not	O
linear	O
,	O
performance	O
.	O

But	O
off	O
course	O
,	O
isreal	B-API
would	O
be	O
more	O
readable	O
:-)	O

mshgrd	O
=	O
ax.pcolormesh	B-API
(	O
X	O
,	O
Y	O
,	O
Z	O
)	O

Otherwise	O
,	O
the	O
performance	O
advantages	O
of	O
using	O
numpy	O
are	O
quickly	O
nullified	O
,	O
regardless	O
of	O
how	O
you	O
implement	O
your	O
ringbuffer	B-API
.	O

The	O
answer	O
is	O
numpy.clip	B-API
#CODE	O

Can	O
you	O
please	O
go	O
into	O
more	O
depth	O
about	O
nesting	O
a	O
recarray	B-API
in	O
another	O
by	O
using	O
the	O
np.object	O
method	O
?	O

Why	O
do	O
you	O
need	O
`	O
vectorize	B-API
`	O
for	O
that	O
?	O

I	O
did	O
try	O
gc.colletc()	O
without	O
success	O
but	O
adding	O
a	O
clf()	B-API
inside	O
the	O
loop	O
does	O
the	O
trick	O
!	O

not	O
a	O
bad	O
solution	O
;	O
though	O
I	O
am	O
somewhat	O
wary	O
of	O
the	O
performance	O
of	O
random.shuffle	B-API
.	O

date2num	B-API
,	O
ValueError	O
:	O
ordinal	O
must	O
be	O
>	O
=	O
1	O

And	O
you	O
could	O
override	O
`	O
__mul__	B-API
`	O
,	O
`	O
__add__	B-API
`	O
,	O
`	O
__sub__	B-API
`	O
accordingly	O
,	O
but	O
I	O
don't	O
know	O
exactly	O
how	O
numpy-like	O
you	O
actually	O
*	O
need	O
*	O
this	O
to	O
be	O
,	O
so	O
I	O
can't	O
say	O
for	O
sure	O
.	O

`	O
np.array	B-API
=	O
partial	O
(	O
np.array	B-API
,	O
dtype=	O
np.float32	O
)`	O
with	O
`	O
partial	O
`	O
from	O
the	O
`	O
functools	O
`	O
module	O
.	O

A	O
solution	O
that	O
worked	O
uses	O
griddata	B-API
.	O

Numpy	O
1.7.0	O
assert_array_almost_equal	B-API
documentation	O

You	O
can	O
read	O
matlab	O
(	O
.mat	B-API
)	O
files	O
in	O
Python	O
,	O
try	O
this	O
:	O
#CODE	O

Thanks	O
for	O
the	O
idea	O
of	O
genfromtxt()	B-API
.	O

If	O
you	O
are	O
using	O
numpy	O
,	O
for	O
multidimensional	O
lists	O
`	O
numpy.repeat	B-API
`	O
is	O
your	O
best	O
bet	O
.	O

If	O
the	O
following	O
equation	O
is	O
element-wise	O
True	O
,	O
then	O
allclose	B-API
returns	O
`	O
True	O
`	O
:	O
#CODE	O

`	O
np.vstack	B-API
`	O
just	O
vertically	O
stacks	O
the	O
arrays	O
you	O
pass	O
to	O
it	O
,	O
and	O
so	O
something	O
else	O
in	O
your	O
code	O
may	O
be	O
cutting	O
off	O
the	O
rest	O
of	O
the	O
results	O
inadvertently	O
.	O

If	O
you	O
move	O
the	O
line	O
`	O
np_verticies=	O
np.array	B-API
(	O
verticies	O
)`	O
outside	O
of	O
`	O
Fnumpy	O
`	O
and	O
the	O
timed	O
section	O
your	O
results	O
will	O
be	O
very	O
different	O
:	O
#CODE	O

`	O
fromiter	B-API
`'	O
s	O
example	O
is	O
essentially	O
this	O
:	O
`	O
np.fromiter	B-API
((	O
x*x	O
for	O
x	O
in	O
range	O
(	O
5	O
))	O
,	O
int	O
)`	O
.	O

In	O
Python	O
,	O
I	O
have	O
a	O
numpy.array	B-API
of	O
integers	O
`	O
[	O
2	O
,	O
4	O
,	O
7	O
,	O
8	O
,	O
9	O
,	O
10	O
,	O
15	O
,	O
10	O
8]	O
`	O
.	O

I	O
will	O
go	O
with	O
newaxis	B-API
then	O
.	O

pcolormesh	B-API
returns	O
a	O
QuadMesh	B-API
.	O

And	O
when	O
I	O
call	O
each	O
of	O
the	O
instructions	O
inside	O
f()	B-API
individually	O
it	O
gives	O
me	O
an	O
other	O
result	O
(	O
which	O
is	O
correct	O
):	O
#CODE	O

Here's	O
one	O
vectorized	O
approach	O
based	O
on	O
`	O
np.einsum	B-API
`	O
-	O
#CODE	O

What's	O
the	O
`	O
dtype	B-API
`	O
of	O
these	O
arrays	O
?	O

try	O
adding	O
a	O
`	O
show()	B-API
`	O
in	O
the	O
end	O

`	O
pandas.DataFrame	B-API
`	O

You	O
can	O
define	O
your	O
own	O
types	O
by	O
creating	O
a	O
class	O
and	O
writing	O
a	O
`	O
__add__	B-API
`	O
or	O
`	O
__sub__	B-API
`	O
method	O
.	O

On	O
the	O
other	O
hand	O
,	O
if	O
I	O
did	O
with	O
`	O
genfromtxt	B-API
`	O
,	O
the	O
third	O
column	O
is	O
problem	O
because	O
it	O
includes	O
comma	O
inside	O
double-quota	O
.	O

Apparently	O
,	O
if	O
there	O
is	O
no	O
'	O
missing_value	O
'	O
attribute	O
Netcdf4	O
defaults	O
to	O
a	O
missing	O
value	O
appropriate	O
for	O
the	O
dtype	B-API
.	O

do	O
be	O
aware	O
that	O
if	O
you	O
have	O
NaNs	O
,	O
there	O
is	O
an	O
equivalent	O
np.nanstd	B-API
with	O
the	O
similar	O
ddof	O
options	O

[	O
True	O
,	O
True	O
]]	O
,	O
dtype	B-API
=b	O
ool	O
)`	O

@USER	O
true	O
,	O
although	O
`	O
np.array	B-API
([	O
x	O
for	O
bb	O
in	O
b	O
for	O
x	O
in	O
bb	O
])`	O
will	O
do	O
the	O
job	O
.	O

return	O
matrix_power	B-API
(	O
self	O
,	O
other	O
)	O

vector	O
=	O
numpy.array	B-API
(	O
vector	O
);	O

If	O
so	O
then	O
you	O
should	O
have	O
no	O
problem	O
fitting	O
the	O
`	O
numpy.fft.rfftfreq	B-API
`	O
method	O
into	O
your	O
own	O
code	O
.	O

This	O
fails	O
:	O
`	O
einsum	B-API
(	O
'	O
i	O
...,	O
i	O
...	O

Python	O
&	O
Numpy	O
-	O
create	O
dynamic	O
,	O
arbitrary	O
subsets	O
of	O
ndarray	B-API

For	O
example	O
,	O
I	O
have	O
a	O
`	O
ndarray	B-API
`	O
that	O
is	O
:	O
#CODE	O

I	O
went	O
with	O
the	O
np.memmap	B-API
because	O
the	O
performance	O
is	O
similar	O
to	O
hdf5	O
and	O
I	O
already	O
have	O
numpy	O
in	O
production	O
.	O

its	O
np.log	B-API
not	O
m.log	O

what	O
happens	O
if	O
you	O
[	O
`	O
Py_INCREF	O
(	O
self	O
)`]	O
(	O
#URL	O
)	O
after	O
`	O
.base	B-API
`	O
assignment	O
?	O

File	O
"	O
/	O
usr	O
/	O
lib64	O
/	O
python2.6	O
/	O
site-packages	O
/	O
numpy	O
/	O
core	O
/	O
fromnumeric.py	O
"	O
,	O
line	O
806	O
,	O
in	O
searchsorted	B-API

why	O
isn't	O
the	O
`	O
ndarray	B-API
`	O
constructor	O
mentioned	O
here	O
?	O

>>>	O
z	O
=	O
numpy.array	B-API
([	O
1	O
,	O
2	O
]	O

Is	O
there	O
an	O
equivelent	O
to	O
`	O
fseek	O
`	O
when	O
using	O
`	O
fromfile	B-API
`	O
to	O
skip	O
the	O
beginning	O
of	O
the	O
file	O
?	O

The	O
linear	O
algebra	O
functions	O
are	O
generally	O
grouped	O
in	O
`	O
numpy.linalg	B-API
`	O
.	O

np.mean	B-API
:	O
#CODE	O

As	O
others	O
have	O
said	O
,	O
32-bit	O
versions	O
of	O
numpy	O
still	O
support	O
64-bit	O
dtypes	B-API
.	O

`	O
vstack	B-API
`	O
is	O
coercing	O
the	O
type	O
of	O
`	O
d	O
`	O
to	O
the	O
type	O
of	O
`	O
e	O
`	O
.	O

`	O
df.plot	B-API
`	O
returns	O
an	O
AxesSubplot	O
,	O
which	O
has	O
a	O
`	O
axvspan	B-API
`	O
method	O
.	O

With	O
the	O
variables	O
defined	O
above	O
,	O
`	O
np.searchsorted	B-API
(	O
lat	O
,	O
x	O
)`	O
is	O
16x	O
faster	O
than	O
the	O
equivalent	O
call	O
`	O
np.nanargmin	B-API
((	O
lat-x	O
)	O
**2	O
)`	O
on	O
my	O
computer	O
.	O

Pypy	O
with	O
iterators	O
is	O
still	O
solving	O
this	O
about	O
3x	O
faster	O
than	O
CPython	O
+	O
Numpy	O
,	O
even	O
when	O
using	O
`	O
np.searchsorted	B-API
`	O
(	O
see	O
my	O
solution	O
)	O
.	O

and	O
`	O
hstack	B-API
((	O
a	O
,	O
z	O
))`	O
?	O

Have	O
you	O
tried	O
passing	O
`	O
interpolation=	O
'	O
nearest	O
'`	O
to	O
`	O
imshow	B-API
`	O
?	O

`	O
cumsum	B-API
`	O
might	O
not	O
be	O
the	O
best	O
example	O
.	O

I	O
think	O
you're	O
after	O
`	O
plt.axis	B-API
([	O
xmin	O
,	O
xmax	O
,	O
ymin	O
,	O
ymax	O
])`	O
:	O
#CODE	O

Is	O
`	O
(	O
dry	O
,	O
unrch	O
)	O
=	O
((	O
G	O
==	O
3	O
)	O
.sum()	B-API
,	O
(	O
G	O
==	O
1	O
)	O
.sum()	B-API
)`	O
more	O
vectorized	O
?	O

Then	O
,	O
`	O
np.array	B-API
(	O
np.matrix	B-API
(	O
s.strip	O
(	O
'	O
[	O
]')))`	O
will	O
do	O
the	O
same	O
magic	O
.	O

I'm	O
trying	O
to	O
vectorize	B-API
Z	O
,	O
but	O
I'm	O
finding	O
it	O
rather	O
difficult	O
for	O
a	O
triple	O
for	O
loop	O
.	O

How	O
would	O
that	O
be	O
done	O
using	O
np.dot	B-API
?	O

I	O
was	O
surprised	O
how	O
descending	O
sorting	O
of	O
np.array	B-API
seem	O
so	O
un-pythonic	O
.	O

`	O
numpy.genfromtxt	B-API
`	O
accepts	O
generators	O
,	O
so	O
you	O
can	O
chain	O
`	O
genfromtext	O
`	O
and	O
`	O
ifilter	O
`	O
:	O
#CODE	O

I	O
also	O
tried	O
`	O
df.query()	B-API
`	O
,	O
but	O
no	O
much	O
improvement	O
.	O

According	O
to	O
the	O
documentation	O
(	O
e.g.	O
,	O
here	O
)	O
,	O
`	O
PyArray_SimpleNew	B-API
`	O
has	O
a	O
return	O
of	O
type	O
`	O
PyObject	O
*	O
`	O
and	O
thus	O
the	O
above	O
should	O
be	O
perfectly	O
fine	O
.	O

Edit	O
:	O
`	O
np.where	B-API
`	O
is	O
optional	O
,	O
thanks	O
@USER	O
.	O

or	O
with	O
`	O
numpy.concatenate	B-API
`	O
?	O

@USER	O
you	O
can	O
do	O
it	O
,	O
it's	O
easy	O
with	O
`	O
np.histogram	B-API
`	O
.	O

`	O
numpy.base_repr	B-API
`	O
uses	O
this	O
,	O
but	O
only	O
operates	O
on	O
scalars	O
.	O

Python	O
apply_along_axis	B-API
of	O
multiple	O
arrays	O

`	O
numpy.average()	B-API
`	O
has	O
a	O
weights	O
option	O
,	O
but	O
`	O
numpy.std()	B-API
`	O
does	O
not	O
.	O

I	O
wanted	O
to	O
write	O
`	O
M.det()	O
`	O
instead	O
of	O
`	O
numpy.linalg.det	B-API
(	O
M	O
)`	O
,	O

I	O
was	O
working	O
with	O
something	O
like	O
```	O
s	O
=	O
pd.DataFrame	B-API
([	O
'	O
1	O
'	O
,	O
'	O
na	O
'	O
,	O
'	O
3	O
'	O
,	O
'	O
4	O
'])	O
.	O

tested	O
it	O
a	O
bit	O
myself	O
:	O
sympy.sin	O
is	O
much	O
slower	O
than	O
numpy.sin	B-API

I	O
was	O
thinking	O
of	O
something	O
like	O
`	O
frombuffer	B-API
`	O
.	O
