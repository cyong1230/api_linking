i	O
am	O
facing	O
this	O
strange	O
behaviour	O
,	O
i	O
got	O
a	O
HDFStore	B-API
containing	O
DataFrames	O
.	O

What	O
happens	O
if	O
you	O
do	O
`	O
ax.legend()	B-API
`	O
and	O
`	O
plt.draw()	B-API
`	O
?	O

E.g.	O
,	O
you	O
can	O
call	O
`	O
pandas.isnull	B-API
(	O
the_frame	O
)`	O
.	O

do	O
this	O
:	O
``	O
df.ix	B-API
[	O
0	O
,	O
'	O
a	O
']	O
+=	O
1	O
``	O
.	O

Using	O
unstack()	B-API
is	O
one	O
way	O
.	O

Clearly	O
I'm	O
missing	O
something	O
as	O
to	O
why	O
df.loc	B-API
[:	O
,	O
tuple	O
]	O
is	O
different	O
than	O
df	O
[	O
tuple	O
]	O
.	O

datetime	O
dtypes	B-API
in	O
pandas	O
read_csv	B-API

If	O
you're	O
using	O
version	O
`	O
0.17.0	O
`	O
or	O
higher	O
then	O
you	O
can	O
call	O
this	O
using	O
`	O
.dt	B-API
.strftime	B-API
`	O
which	O
is	O
vectorised	O
:	O
#CODE	O

Looks	O
like	O
you	O
need	O
histogram()	B-API
of	O
months	O
.	O

You	O
want	O
`	O
.dt	B-API
.time	B-API
`	O
see	O
the	O
docs	O
for	O
some	O
more	O
examples	O
of	O
things	O
under	O
the	O
`	O
.dt	B-API
`	O
accessor	O
.	O

pd.rolling_apply	B-API
(	O
df.exma	O
,	O
2	O
,	O
(	O
df.alpha	O
*	O
df.exma.shift	O
(	O
1	O
))	O
+	O
((	O
1	O
-	O
df.alpha	O
)	O
*	O
df.outperf	O
))	O

I	O
suggest	O
not	O
using	O
`	O
file	O
`	O
for	O
your	O
`	O
open()	B-API
`	O
object	O
.	O

If	O
you	O
want	O
every	O
value	O
from	O
row	O
2	O
you	O
can	O
just	O
do	O
`	O
df.iloc	B-API
[	O
2	O
]`	O
or	O
`	O
df.iloc	B-API
[	O
2	O
]	O
.values	B-API
`	O
respectively	O
.	O

dtype	B-API
:	O
object	O

Check	O
out	O
the	O
glob	O
module	O
and	O
pandas	O
read_csv()	B-API
and	O
concat()	B-API

`	O
np.dtype	B-API
(	O
'	O
datetime64	O
[	O
ns	O
]')`	O
and	O
`	O
np.dtype	B-API
(	O
'	O
M	O
8[	O
ns	O
]')`	O
:	O
#CODE	O

Doing	O
`	O
pd.crosstab	B-API
(	O
rows	O
=[	O
df	O
[	O
'	O
A	O
']	O
,	O
df	O
[	O
'	O
B	O
']]	O
,	O
cols	O
=[	O
df	O
[	O
'	O
C	O
']]	O
,	O
margins=True	O
,	O
aggfu	O

DataFrame.drop_duplicates	B-API
and	O
DataFrame.drop	B-API
not	O
removing	O
rows	O

`	O
pd.rolling_mean	B-API
(	O
df	O
,	O
num	O
)	O
.dropna()	B-API
.plot()	B-API
`	O

This	O
is	O
a	O
replacement	O
for	O
`	O
np.array_equal	B-API
`	O
which	O
is	O
broken	O
for	O
nan	O
positional	O
detections	O
(	O
and	O
object	O
dtypes	B-API
)	O
.	O

It	O
looks	O
like	O
`	O
pd.unique	O
`	O
does	O
not	O
respect	O
the	O
`	O
datetime64	O
`	O
dtype	B-API
:	O
#CODE	O

df	O
[	O
'	O
NumActivity	O
']	O
=	O
pd.factorize	B-API
(	O
df	O
[	O
'	O
Activity	O
'])	O
[	O
0	O
]	O
+1	O
works	O
.	O

calling	O
`	O
as_matrix()	B-API
`	O
on	O
`	O
df	O
`	O
returns	O
a	O
`	O
numpy.ndarray	B-API
`	O
object	O
#CODE	O

And	O
using	O
pandas.Series.map	B-API
:	O
#CODE	O

works	O
,	O
but	O
I	O
think	O
`	O
df.select_dtypes	B-API
`	O
should	O
be	O
preferred	O
since	O
it	O
uses	O
the	O

Then	O
you	O
can	O
access	O
the	O
relevant	O
rows	O
using	O
groupby's	O
`	O
get_group	B-API
`	O
:	O
#CODE	O

It's	O
not	O
in	O
the	O
online	O
docs	O
,	O
you	O
have	O
to	O
check	O
the	O
`	O
help	O
(	O
pd.bdate_range	B-API
)`	O
:)	O

dtype	B-API
:	O
int64	O
`	O

dtype	B-API
:	O
object	O

df.drop	B-API
([	O
'	O
one	O
'	O
,	O
'	O
two	O
'	O
,	O
'	O
three	O
']	O
,	O
axis=1	O
,	O
inplace=True	O
)	O

I	O
tried	O
make	O
these	O
'	O
filenames	O
'	O
dataFrames	O
using	O
`	O
pd.DataFrame	B-API
`	O
but	O
wasn't	O
able	O
to	O
do	O
so	O
.	O

Try	O
using	O
.loc	B-API
[	O
row_index	O
,	O
col_indexer	O
]	O
=	O
value	O
instead	O
`	O
.	O

Good	O
question	O
,	O
`	O
plt.hist	B-API
(	O
hour_list	O
,	O
bins=	O
np.arange	B-API
(	O
24	O
)	O
-	O
0.5	O
)`	O
will	O
work	O
.	O

what	O
is	O
the	O
-	O
0.00343	O
(	O
ah	O
I	O
see	O
,	O
a	O
consequence	O
of	O
not	O
using	O
right=False	O
)	O
,	O
pd.cut	B-API
very	O
neat	O

2	O
)	O
Alternatively	O
,	O
don't	O
create	O
levels	O
for	O
`	O
aa	O
`	O
and	O
`	O
bb	O
`	O
using	O
`	O
as_index=False	O
`	O
and	O
`	O
pd.merge	B-API
`	O
#CODE	O

`	O
df.groupby	B-API
(	O
level	O
=[	O
'	O
major	O
'	O
,	O
'	O
minor	O
'])	O
.mean()	B-API
.dropna()	B-API
`	O

Argh	O
,	O
that	O
still	O
gives	O
me	O
`	O
dtype	B-API
(	O
'	O
datetime64	O
[	O
us	O
]')`	O
.	O

or	O
better	O
yet	O
,	O
just	O
don't	O
specify	O
a	O
dtype	B-API
:	O
#CODE	O

I	O
was	O
trying	O
to	O
do	O
this	O
with	O
`	O
df	O
[	O
df.shift()	B-API
!	O
=	O
df	O
]	O
.dropna()	B-API
.reset_index	B-API
(	O
drop=True	O
)`	O
but	O
`	O
shift()	B-API
`	O
is	O
not	O
behaving	O
in	O
the	O
way	O
I	O
meant	O
.	O

`	O
median_search_query	O
=	O
np.median	B-API
(	O
df.srch_query_affinity_score	O
)`	O

Example	O
using	O
df.asfreq	B-API
(	O
'	O
Q	O
')	O
:	O
#CODE	O

```	O
In	O
[	O
15	O
]:	O
pd.to_timedelta	B-API
(	O
s.str.replace	O
(	O
'	O
hrs	O
'	O
,	O
'	O
h	O
'))	O

Python	O
Dict	O
,	O
Lambda	O
x	O
,	O
map()	B-API
doesn't	O
work	O

I	O
have	O
tried	O
to	O
modify	O
your	O
answer	O
to	O
make	O
it	O
an	O
example	O
about	O
modifying	O
two	O
columns	O
like	O
I	O
asked	O
(	O
for	O
one	O
the	O
`	O
df.loc	B-API
[:	O
,	O
(	O
'	O
A	O
'	O
,	O
'	O
a	O
')]`	O
works	O
like	O
a	O
charm	O
)	O
.	O

I	O
thought	O
np.ma.average	B-API
is	O
just	O
what	O
I	O
need	O
,	O
but	O
that	O
also	O
gives	O
me	O
NaN	O
as	O
a	O
result	O
.	O

Although	O
```	O
pandas.cut()	B-API
```	O
is	O
the	O
better	O
and	O
more	O
general	O
answer	O
,	O
it	O
looks	O
like	O
in	O
this	O
case	O
you	O
could	O
do	O
```	O
df	O
[	O
'	O
B	O
']	O
=	O
(	O
df.A	O
/	O
500	O
)	O
.astype	B-API
(	O
int	O
)	O
+	O
1	O
```	O
.	O

outcome	O
:	O
displays	O
good	O
in	O
`	O
df.head()	B-API
`	O
,	O
but	O
reverts	O
to	O
scientific	O
notation	O
upon	O
coercion	O
to	O
string	O
concatenation	O
using	O
+	O
operator	O

The	O
`	O
ewma	B-API
`	O
case	O
can	O
be	O
solved	O
similarly	O
:	O
`	O
df.groupby	B-API
(	O
level=0	O
)	O
.apply	B-API
(	O
lambda	O
x	O
:	O
pd.ewma	B-API
(	O
x	O
,	O
com=2	O
))`	O

I	O
didn't	O
realise	O
that	O
`	O
.resample()	B-API
`	O
wasn't	O
inplace	O
!	O

I	O
can't	O
think	O
of	O
a	O
way	O
to	O
overload	O
the	O
`	O
.loc	B-API
`	O
method	O
properly	O
!	O

Do	O
I	O
have	O
to	O
specific	O
the	O
dtypes	B-API
to	O
make	O
this	O
work	O
?	O

It	O
appears	O
that	O
the	O
`	O
applymap	B-API
`	O
is	O
the	O
culprit	O
here	O
:-)	O

"	O
"	O
.join	B-API
(	O
header.split()	O
)	O
.split	B-API
(	O
'	O
')	O

I	O
want	O
df.append	B-API
(	O
df2	O
)	O
in	O
this	O
case	O
to	O
be	O
:	O
#CODE	O

I	O
completely	O
forgot	O
about	O
.loc	B-API

It	O
sounds	O
like	O
maybe	O
you	O
want	O
`	O
pandas.concat	B-API
`	O
?	O

Is	O
there	O
anything	O
in	O
pandas	O
that	O
is	O
the	O
opposite	O
to	O
`	O
.dropna()	B-API
`	O
?	O

Datetimes	O
are	O
handled	O
if	O
they	O
can	O
properly	O
be	O
converted	O
(	O
e.g.	O
they	O
have	O
a	O
dtype	B-API
of	O
'	O
datetime64	O
[	O
ns	O
]'	O
,	O
notably	O
datetimes.date	O
are	O
NOT	O
handled	O
(	O
NaN	O
are	O
a	O
different	O
story	O
and	O
depending	O
on	O
usage	O
can	O
cause	O
the	O
entire	O
column	O
type	O
to	O
be	O
mishandled	O
)	O

The	O
`	O
args	O
`	O
and	O
`	O
kwargs	O
`	O
parameters	O
were	O
added	O
to	O
`	O
rolling_apply	B-API
`	O
in	O
Pandas	O
version	O
0.14.0	O
.	O

try	O
``	O
df	O
[	O
'	O
LastName	O
']	O
=	O
df.apply	B-API
(	O
updateDataframe	O
)``	O
,	O
but	O
even	O
better	O
is	O
:	O
``	O
df.ix	B-API
[	O
df	O
[	O
'	O
LastName	O
']	O
==	O
'	O
Joe	O
'	O
,	O
'	O
LastName	O
']	O
=	O
'	O
Black	O
'``	O

There	O
should	O
be	O
no	O
problem	O
;	O
`	O
plt.plot	B-API
`	O
and	O
`	O
plt.fill_between	B-API
`	O
accept	O
arrays	O
of	O
dtype	B-API
`	O
datetime64	O
[	O
ns	O
]`	O
just	O
fine	O
.	O

You	O
could	O
try	O
pandas	O
pivot()	B-API
.	O

What	O
happens	O
if	O
you	O
do	O
`	O
ax.legend()	B-API
`	O
and	O
`	O
plt.draw()	B-API
`	O
?	O

Pandas	O
Python	O
read_csv	B-API
error_bad_lines	O
producing	O
shell	O
feedback	O

Though	O
in	O
some	O
respects	O
,	O
the	O
np.clip	B-API
or	O
np.max	O
solutions	O
are	O
more	O
easily	O
read	O
,	O
I	O
think	O
this	O
is	O
the	O
most	O
precise	O
answer	O
to	O
my	O
original	O
question	O
.	O

Did	O
you	O
try	O
setting	O
the	O
delimiter	O
to	O
semicolon	O
in	O
your	O
`	O
read_csv	B-API
`	O
call	O
?	O

In	O
[	O
8]	O
:	O
%timeit	O
df	O
[	O
'	O
r	O
']	O
=	O
df	O
[[	O
'	O
minor	O
'	O
,	O
'	O
major	O
']]	O
.abs()	B-API
.max	B-API
(	O
axis=1	O
)	O

I	O
guess	O
my	O
confusion	O
stems	O
from	O
the	O
fact	O
that	O
the	O
Series.value_counts	B-API
doesn't	O
seem	O
to	O
fit	O
into	O
the	O
arguments	O
required	O
by	O
the	O
df.apply	B-API
method	O
.	O

The	O
problem	O
is	O
that	O
`	O
a	O
`	O
is	O
dtype	B-API
`	O
object	O
`	O
.	O

try	O
`	O
video_base	O
=	O
pd.merge	B-API
(	O
df_one	O
,	O
df_two	O
[[	O
'	O
count_watched_yeterday	O
']]	O
,	O
how=	O
'	O
left	O
'	O
,	O
left_index=True	O
,	O
right_index=True	O
)`	O

ax.xaxis.set_major_locator	O
(	O
MultipleLocator	B-API
(	O
10	O
))	O

Actually	O
I	O
think	O
you	O
want	O
:	O
`	O
pd.concat	B-API
([	O
df_may	O
,	O
df_jun	O
]	O
,	O
axis=0	O
,	O
ignore_index=True	O
)`	O

Maybe	O
there	O
is	O
a	O
better	O
approach	O
thats	O
takes	O
advantage	O
of	O
features	O
of	O
the	O
Pandas.DataFrame	B-API
class	O
?	O

Try	O
`	O
df.loc	B-API
[	O
'	O
a	O
']`	O
instead	O
.	O

Then	O
this	O
should	O
work	O
:	O
`	O
df	O
[	O
'	O
Gene.Symbol	O
']	O
=	O
df	O
[	O
'	O
Gene.Symbol	O
']	O
.str	B-API
.strip()	B-API
.str	B-API
.upper()	B-API
`	O

then	O
[	O
`	O
df.groupy	O
(	O
'	O
key	O
')	O
.agg	B-API
(	O
...	O
)`]	O
(	O
#URL	O
)	O
might	O
be	O
what	O
you	O
are	O
looking	O
for	O
.	O

DataFrame.apply	B-API
in	O
python	O
pandas	O
alters	O
both	O
original	O
and	O
duplicate	O
DataFrames	O

you	O
might	O
want	O
to	O
try	O
`	O
df.iloc	B-API
[	O
0	O
]`	O
rather	O
than	O
`	O
df.iloc	B-API
(	O
0	O
)`	O
.	O

and	O
,	O
`	O
ts.asfreq	O
(	O
'	O
H	O
'	O
,	O
method=	O
'	O
ffill	B-API
')`	O
to	O
have	O
hourly	O
frequency	O
.	O

I	O
tried	O
something	O
like	O
`	O
set_index	B-API
`	O
,	O
`	O
pd.factorize()	B-API
`	O
and	O
`	O
index_col	O
`	O
but	O
they	O
do	O
not	O
work	O
.	O

So	O
df	O
=	O
df.reindex()	B-API
results	O
in	O
the	O
same	O
indexing	O
...	O

I	O
think	O
this	O
solution	O
will	O
execute	O
faster	O
than	O
using	O
iterrows()	B-API
,	O
but	O
I'm	O
not	O
sure	O
.	O

One	O
option	O
using	O
`	O
df.reindex	B-API
`	O
:	O
#CODE	O

I	O
am	O
using	O
dtype	B-API
as	O
suggested	O
in	O
the	O
answer	O
there	O
.	O

You	O
might	O
be	O
interested	O
in	O
`	O
pd.cut	B-API
`	O
:	O
#CODE	O

df.groupby	B-API
(	O
'	O
A	O
')	O
.size()	B-API
.apply	B-API
(	O
lambda	O
x	O
:	O
float	O
(	O
x	O
)	O
/	O
df.groupby	B-API
(	O
'	O
A	O
')	O
.size()	B-API
.sum()	B-API
*100	O
)	O

`	O
df.apply()	B-API
`	O
works	O
off	O
a	O
single	O
row	O
,	O
`	O
shift()	B-API
`	O
doesnt	O
seem	O
to	O
work	O
.	O

Could	O
you	O
try	O
this	O
:	O
`	O
df	O
[	O
'	O
GC	O
content	O
']	O
=	O
df	O
[[	O
'	O
oligo_sequence	O
']]	O
.apply	B-API
(	O
lambda	O
row	O
:	O
GC	O
(	O
row	O
)	O
,	O
axis=1	O
)`	O

And	O
,	O
`	O
pd.eval()	B-API
`	O
works	O
well	O
with	O
expressions	O
containing	O
large	O
arrays	O
#CODE	O

The	O
eventual	O
goal	O
being	O
to	O
arrange	O
hierarchically	O
to	O
weekday	B-API
hour-range	O
,	O
something	O
like	O
:	O
#CODE	O

Reading	O
about	O
`	O
applymap	B-API
`	O
I	O
wondered	O
if	O
there	O
is	O
a	O
similar	O
way	O
of	O
defining	O
and	O
applying	O
operators	O
that	O
work	O
on	O
pairs	O
of	O
dataframes	O
.	O

Executing	O
your	O
code	O
with	O
pandas	O
0.16.2	O
yielded	O
the	O
two	O
columns	O
with	O
dtype	B-API
datetime64	O
[	O
ns	O
]	O
.	O

`	O
df	O
[	O
'	O
price_trend	O
']	O
.apply	B-API
(	O
lambda	O
x	O
:[	O
i.split	O
(	O
'	O
:	O
')	O
for	O
i	O
in	O
x	O
])`	O
#CODE	O

Here	O
the	O
new	O
value	O
AND	O
the	O
existing	O
dtype	B-API
of	O
the	O
column	O
matters	O
.	O

how	O
about	O
using	O
the	O
`	O
pd.DataFrame.drop_duplicates()	B-API
`	O
method	O
?	O

dtype	B-API
:	O
timedelta64	O
[	O
ns	O
]```	O

`	O
gg	O
[	O
'	O
cumt	O
']	O
=	O
gg.apply	O
(	O
lambda	O
x	O
:	O
x	O
[	O
'	O
tavg	O
']	O
+	O
x	O
[	O
'	O
tavg	O
']	O
.shift	B-API
(	O
1	O
)	O
[	O
1	O
:]	O
)`	O

"	O
"	O
.join	B-API
(	O
header.split()	O
)	O
.split	B-API
(	O
'	O
')	O

print	O
'	O
\nAfter	O
replace\n	O
'	O
,	O
df.replace	B-API
(	O
{	O
'	O
c1	O
'	O
:	O
c1_fromto	O
,	O
'	O
c2	O
'	O
:	O
c2_fromto	O
}	O
)	O

Profiling	O
shows	O
the	O
culprit	O
is	O
obviously	O
`	O
B.ix	O
[	O
row	O
[	O
0	O
]]	O
.irow	B-API
(	O
np.searchsorted	B-API
(	O
B.ts	O
[	O
row	O
[	O
0	O
]]	O
,	O
row	O
[	O
2	O
])))`	O
.	O
