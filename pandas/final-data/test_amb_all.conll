Minor	O
:	O
`	O
notnull	B-API
`	O
is	O
also	O
a	O
method	O
of	O
DataFrames	O
.	O

I	O
want	O
to	O
apply	O
a	O
function	O
f	O
(	O
lat1	O
,	O
lon1	O
,	O
lat2	O
,	O
lon2	O
)	O
which	O
calculates	O
the	O
distance	O
between	O
two	O
points	O
(	O
defined	O
using	O
lat1	O
,	O
lon1	O
,	O
lat2	O
,	O
lon2	O
)	O
.	O

For	O
all	O
110k+	O
records	O
in	O
`	O
df1	O
`	O
do	O
you	O
want	O
to	O
apply	O
your	O
distance	O
function	O
for	O
every	O
record	O
in	O
`	O
df2	O
`	O
?	O

I	O
chose	O
to	O
use	O
map	B-API
and	O
list	O
comprehensions	O
because	O
they	O
will	O
be	O
faster	O
than	O
a	O
standard	O
`	O
for	O
each	O
`	O

However	O
I	O
took	O
this	O
into	O
account	O
and	O
used	O
map	B-API
,	O
and	O
nested	O
comprehensions	O
which	O
are	O
going	O
to	O
be	O
faster	O
than	O
a	O
for	O
loop	O
.	O

Keep	O
getting	O
:	O
KeyError	O
:	O
'	O
cannot	O
use	O
a	O
single	O
bool	O
to	O
index	O
into	O
setitem	O
'	O
on	O
this	O
line	O
of	O
code	O
in	O
the	O
second	O
chunk	O
I	O
posted	O
.	O

i	O
have	O
to	O
merge	O
them	O
in	O
to	O
the	O
same	O
cell	O
before	O
applying	O
this	O
method	O
.	O

Or	O
is	O
there	O
are	O
way	O
to	O
marge	O
the	O
columns	O
in	O
pandas	O
?	O

I	O
have	O
two	O
TimeSeries	O
with	O
some	O
overlapping	O
dates	O
/	O
indices	O
and	O
I'd	O
like	O
to	O
merge	O
them	O
.	O

I	O
have	O
an	O
excel	O
file	O
(	O
.xls	O
format	O
)	O
with	O
5	O
sheets	O
,	O
I	O
want	O
to	O
replace	O
the	O
contents	O
of	O
sheet	O
5	O
with	O
contents	O
of	O
my	O
pandas	O
data	O
frame	O
.	O

So	O
,	O
I	O
decided	O
to	O
do	O
this	O
task	O
in	O
VBA	O
and	O
drop	O
python	O
completely	O
.	O

It	O
could	O
be	O
I'm	O
not	O
using	O
the	O
right	O
keywords	O
,	O
so	O
if	O
you	O
have	O
suggestions	O
,	O
that	O
could	O
also	O
help	O
.	O

plus	O
the	O
selected	O
rows	O
usage	O
x	O
2	O
,	O
which	O
will	O
happen	O
when	O
you	O
concat	O
the	O
rows	O

after	O
the	O
concat	B-API
the	O
usage	O
will	O
go	O
down	O
to	O
selected	O
rows	O
usage	O

See	O
example	O
here	O
:	O
#URL	O
Not	O
sure	O
this	O
will	O
solve	O
it	O
,	O
but	O
that	O
will	O
do	O
the	O
query	O
in	O
chunks	O
,	O
and	O
you	O
can	O
aggregate	O
or	O
merge	O
them	O
in	O
pandas	O

Try	O
a	O
`	O
dropna	B-API
`	O
or	O
use	O
`	O
missing=	O
'	O
drop	O
'`	O
to	O
Logit	O
.	O

You	O
might	O
also	O
check	O
that	O
the	O
right	O
hand	O
side	O
is	O
full	O
rank	O
`	O
np.linalg.matrix_rank	B-API
(	O
data	O
[	O
train_cols	O
]	O
.values	B-API
)`	O

append	O
pandas.DataFrame.GroupBy	B-API
results	O
into	O
another	O
dataframe	O

You	O
need	O
to	O
append	O
the	O
intermediate	O
DataFrames	O
to	O
a	O
list	O
and	O
then	O
concatenate	O
the	O
results	O
.	O

I	O
am	O
taking	O
the	O
second	O
dataframe	O
and	O
doing	O
some	O
calculations	O
with	O
it	O
to	O
append	O
to	O
the	O
first	O
dataframe	O
.	O

However	O
it	O
does	O
not	O
appear	O
that	O
what	O
I	O
am	O
appending	O
to	O
the	O
first	O
data	O
frame	O
is	O
actually	O
happening	O
.	O

Could	O
you	O
use	O
concat	B-API
instead	O
?	O

`	O
m=	O
m.concat	O
([	O
a0	O
,	O
a1	O
,	O
a2	O
,	O
a3	O
,	O
a4	O
,	O
a5	O
,	O
a6	O
,	O
a7	O
,	O
a8	O
,	O
a9	O
]	O
,	O
ignore_index=True	O
)`	O

I	O
get	O
an	O
error	O
trying	O
to	O
use	O
this	O
...	O

AttributeError	O
:	O
'	O
DataFrame	O
'	O
object	O
has	O
no	O
attribute	O
'	O
concat	B-API
'	O

[	O
`	O
append	B-API
`]	O
(	O
#URL	O
)	O
does	O
*	O
not	O
*	O
operate	O
in	O
place	O
.	O

But	O
for	O
a	O
start	O
I	O
would	O
just	O
be	O
happy	O
to	O
get	O
the	O
first	O
result	O
.	O

I	O
suspect	O
that	O
I	O
need	O
to	O
use	O
searchsort	O
and	O
asof	B-API
,	O
but	O
I	O
am	O
not	O
quite	O
sure	O
how	O
to	O
do	O
that	O
with	O
.	O

You're	O
looking	O
for	O
a	O
near	O
timestamp	O
,	O
where	O
`	O
asof	B-API
`	O
searches	O
for	O
the	O
latest	O
timestamp	O
.	O

It	O
is	O
only	O
applied	O
to	O
a	O
time	O
series	O
,	O
so	O
you	O
would	O
have	O
to	O
apply	O
`	O
reset_index	B-API
`	O
to	O
your	O
`	O
DataFrame	O
`	O

You're	O
going	O
to	O
have	O
to	O
iterate	O
over	O
your	O
list	O
,	O
get	O
copies	O
of	O
them	O
filtered	O
and	O
then	O
concat	O
them	O
all	O
together	O
#CODE	O

A	O
solution	O
without	O
loop	O
but	O
`	O
merge	B-API
`	O
:	O
#CODE	O

If	O
there	O
are	O
no	O
blanks	O
some	O
columns	O
convert	O
to	O
`	O
TRUE	O
/	O
FALSE	O
`	O
,	O
others	O
leave	O
as	O
`	O
Yes	O
/	O
No	O
`	O
but	O
dtype	B-API
is	O
bool	B-API
.	O

`	O
fhs	O
=	O
fhs.drop	O
([	O
1002	O
])`	O
to	O
drop	O
that	O
row	O
and	O
data	O
types	O
are	O
still	O
good	O
.	O

first	O
column	O
comes	O
into	O
df	O
as	O
Yes	O
,	O
No	O
,	O
Yes	O
,	O
Yes	O
type	O
bool	O
xxxx	O
below	O

3rd	O
column	O
comes	O
into	O
df	O
as	O
FALSE	O
,	O
FALSE	O
,	O
TRUE	O
,	O
TRUE	O
type	O
bool	O

print	O
(	O
len	B-API
(	O
upregulated	O
)	O
,	O
end=	O
'	O
\n	O
')	O

remove	O
overlay	O
text	O
from	O
pandas	O
boxplot	O

I	O
am	O
trying	O
to	O
remove	O
the	O
overlay	O
text	O
on	O
my	O
boxplot	O
I	O
created	O
using	O
pandas	O
.	O

The	O
code	O
to	O
generate	O
it	O
is	O
as	O
follows	O
(	O
minus	O
a	O
few	O
other	O
modifications	O
):	O

I	O
just	O
want	O
to	O
remove	O
the	O
"	O
boxplot	O
grouped	O
by	O
0	O
...	O

I	O
know	O
how	O
to	O
create	O
a	O
new	O
column	O
with	O
`	O
apply	B-API
`	O
or	O
`	O
np.where	B-API
`	O
based	O
on	O
the	O
values	O
of	O
another	O
column	O
,	O
but	O
a	O
way	O
of	O
selectively	O
changing	O
the	O
values	O
of	O
an	O
existing	O
column	O
is	O
escaping	O
me	O
;	O
I	O
suspect	O
`	O
df.ix	B-API
`	O
is	O
involved	O
?	O

@USER	O
For	O
indexing	O
with	O
boolean	O
vectors	O
this	O
is	O
perfectly	O
fine	O
,	O
if	O
you	O
want	O
to	O
add	O
in	O
other	O
forms	O
of	O
indexing	O
you	O
would	O
want	O
`	O
loc	B-API
`	O
.	O

For	O
instance	O
:	O
`	O
df.loc	B-API
[	O
df.name.str.contains	O
(	O
'	O
e$	O
')	O
,	O
'	O
flag	O
']	O
=	O
'	O
Blue	O
'`	O
.	O

use	O
``	O
apply	B-API
``	O
ONLY	O
as	O
a	O
last	O
resort	O
(	O
e.g.	O
you	O
can't	O
do	O
vectorized	O
things	O
)	O
.	O
even	O
if	O
you	O
have	O
a	O
very	O
complicated	O
function	O
to	O
do	O
,	O
you	O
can	O
often	O
do	O
vectorized	O
calculations	O
on	O
most	O
of	O
it	O
,	O
saving	O
the	O
last	O
for	O
``	O
apply	B-API
``	O
,	O
which	O
is	O
essentially	O
a	O
loop	O
.	O

Using	O
apply	B-API
took	O
172ms	O
versus	O
39ms	O
using	O
Jeff's	O
method	O
,	O
I	O
can	O
also	O
confirm	O
that	O
it	O
made	O
negligle	O
difference	O
whether	O
the	O
apply	B-API
was	O
called	O
inside	O
or	O
outside	O
the	O
function	O
but	O
it	O
does	O
modify	O
the	O
df	O
so	O
you	O
didn't	O
need	O
to	O
return	O
the	O
df	O
as	O
it	O
was	O
being	O
modified	O
inside	O
the	O
function	O

And	O
then	O
sometimes	O
different	O
solutions	O
(	O
in	O
this	O
case	O
using	O
`	O
apply	B-API
`)	O
come	O
up	O
on	O
google	O
/	O
stackoverflow	O
and	O
yet	O
again	O
I	O
can	O
NOT	O
verify	O
that	O
there	O
is	O
no	O
better	O
solution	O
as	O
I	O
dont	O
have	O
the	O
insight	O
into	O
the	O
library	O
.	O

I	O
kindof	O
disagree	O
with	O
using	O
df	O
as	O
the	O
variable	O
name	O
here	O
,	O
I	O
also	O
think	O
I'd	O
just	O
use	O
len	B-API
:	O
`	O
df.groupby	B-API
(	O
"	O
Name	O
")	O
.filter	B-API
(	O
lambda	O
x	O
:	O
len	B-API
(	O
x	O
)	O
>	O
2	O
)`	O

Merge	O
existing	O
dataframe	O
into	O
fixed	O
size	O
new	O
dataframe	O

Then	O
I	O
want	O
merge	B-API
these	O
kinds	O
of	O
table	O
into	O
new	O
dataframe	O

How	O
could	O
I	O
merge	O
them	O
in	O
that	O
way	O
?	O

Inconsistent	O
behavior	O
of	O
apply	B-API
with	O
operator.itemgetter	O
v.s.	O
applymap	B-API
operator.itemgetter	O

`	O
apply	B-API
`	O
gives	O
wrong	O
result	O
#CODE	O

apply	B-API
is	O
being	O
passed	O
an	O
entire	O
row	O
which	O
is	O
a	O
series	O
of	O
2	O
elements	O
which	O
are	O
lists	O
;	O
the	O
last	O
list	O
is	O
returned	O
and	O
coerced	O
to	O
a	O
series	O
.	O
embedded	O
lists	O
as	O
elements	O
are	O
not	O
a	O
good	O
idea	O
in	O
general	O
.	O

The	O
reason	O
I	O
am	O
asking	O
,	O
is	O
because	O
I	O
suspect	O
(	O
?	O
)	O
it	O
is	O
faster	O
to	O
create	O
a	O
zero	O
filled	O
dataframe	O
,	O
and	O
then	O
replace	O
each	O
element	O
as	O
needed	O
.	O

So	O
it	O
might	O
be	O
faster	O
to	O
create	O
an	O
empty	O
dataframe	O
with	O
nxm	O
dimensions	O
and	O
then	O
replace	O
elements	O
as	O
needed	O
(	O
by	O
copying	O
a	O
list	O
to	O
each	O
column	O
)	O
.	O

in	O
general	O
creating	O
an	O
empty	O
frame	O
,	O
then	O
filling	O
it	O
column	O
by	O
column	O
is	O
not	O
very	O
efficient	O
;	O
use	O
a	O
dict	O
/	O
list	O
instead	O
,	O
or	O
create	O
sub-frames	O
and	O
concat	O
them	O

Are	O
you	O
trying	O
to	O
shift	O
ends	O
by	O
one	O
(	O
month	O
)	O
?	O

My	O
initial	O
suggestion	O
was	O
to	O
do	O
the	O
shift	B-API
after	O
you've	O
reindexed	O
(	O
since	O
you're	O
about	O
to	O
do	O
that	O
anyway	O
):	O
#CODE	O

the	O
shift	B-API
index	O
looks	O
like	O
a	O
better	O
fix	O
,	O
still	O
would	O
like	O
to	O
know	O
if	O
there	O
is	O
a	O
simple	O
date	O
add	O
function	O
,	O
which	O
is	O
how	O
I'd	O
do	O
it	O
in	O
sql	O
,	O
that	O
could	O
apply	O
?	O

I'd	O
still	O
like	O
to	O
know	O
if	O
there	O
is	O
a	O
simple	O
DateAdd	O
type	O
function	O
that	O
I	O
could	O
use	O
that	O
might	O
also	O
apply	O
for	O
use	O
elsewhere	O
if	O
needed	O
?	O

Alternatively	O
you	O
could	O
use	O
`	O
apply	B-API
`	O
(	O
but	O
this	O
will	O
usually	O
be	O
slower	O
):	O
#CODE	O

Since	O
you	O
are	O
using	O
the	O
"	O
trailing	O
row	O
"	O
you	O
are	O
going	O
to	O
need	O
to	O
use	O
`	O
shift	B-API
`	O
:	O
#CODE	O

thanks	O
shift	B-API
is	O
what	O
i	O
was	O
looking	O
for	O
.	O
now	O
i	O
can	O
find	O
examples	O
in	O
the	O
Pandas	O
book	O

I	O
have	O
been	O
searching	O
for	O
hours	O
,	O
literally	O
the	O
entire	O
day	O
on	O
how	O
to	O
generate	O
a	O
pivot	O
table	O
in	O
Python	O
.	O

What	O
I	O
want	O
is	O
to	O
take	O
a	O
csv	O
file	O
,	O
extract	O
the	O
first	O
column	O
and	O
generate	O
a	O
pivot	O
table	O
using	O
the	O
count	O
or	O
frequency	O
of	O
the	O
numbers	O
in	O
that	O
column	O
,	O
and	O
sort	O
descending	O
#CODE	O

These	O
columns	O
all	O
contain	O
an	O
identical	O
kind	O
of	O
data	O
,	O
and	O
I'd	O
like	O
to	O
stack	O
them	O
into	O
a	O
single	O
series	O
,	O
ergo	O
:	O
#CODE	O

From	O
here	O
,	O
I	O
can't	O
quite	O
figure	O
out	O
how	O
to	O
reindex	O
my	O
series	O
such	O
that	O
the	O
indexes	O
go	O
from	O
0	O
to	O
`	O
len	B-API
(	O
s	O
)`	O
.	O

But	O
it	O
could	O
be	O
an	O
unexpected	O
system	O
difference	O
--	O
I	O
am	O
using	O
Python	O
2.7.3	O
on	O
an	O
Ubuntu	O
machine	O
.	O

An	O
alternative	O
you	O
might	O
try	O
is	O
to	O
replace	O
exit()	O
with	O
os._exit	O
(	O
os.EX_OK	O
)	O
.	O

I	O
think	O
it	O
uses	O
`	O
patsy	O
`	O
in	O
the	O
backend	O
to	O
translate	O
the	O
formula	O
expression	O
,	O
and	O
intercept	O
is	O
added	O
automatically	O
.	O

Trying	O
to	O
append	O
this	O
to	O
a	O
new	O
datastore	O
.	O

The	O
datastore	O
does	O
not	O
exist	O
so	O
I	O
use	O
the	O
following	O
to	O
create	O
and	O
append	O
the	O
data	O
;	O
#CODE	O

I'm	O
not	O
looking	O
to	O
concatenate	O
strings	O
,	O
just	O
shift	O
everything	O
over	O
.	O

I	O
saw	O
a	O
method	O
using	O
"	O
R	O
"	O
and	O
melt	B-API
,	O
however	O
I	O
would	O
like	O
to	O
stick	O
with	O
python	O
/	O
pandas	O
if	O
possible	O
.	O

I	O
cannot	O
post	O
real	O
request	O
for	O
security	O
reason	O
.	O

By	O
the	O
way	O
the	O
code	O
works	O
without	O
"	O
append	B-API
"	O
within	O
for	O
loop	O
.	O

At	O
first	O
I	O
tried	O
using	O
pivot	B-API
(	O
with	O
timestamp	O
as	O
an	O
index	O
)	O
,	O
but	O
that	O
didn't	O
work	O
because	O
of	O
those	O
duplicates	O
.	O

I	O
don't	O
want	O
to	O
drop	O
them	O
,	O
since	O
the	O
other	O
data	O
is	O
different	O
and	O
should	O
not	O
be	O
lost	O
.	O

Since	O
index	O
contains	O
no	O
duplicates	O
,	O
I	O
thought	O
maybe	O
I	O
can	O
pivot	O
over	O
it	O
and	O
after	O
that	O
merge	O
the	O
result	O
into	O
the	O
original	O
DataFrame	O
,	O
but	O
I	O
was	O
wondering	O
if	O
there	O
is	O
an	O
easier	O
more	O
intuitive	O
solution	O
.	O

As	O
your	O
`	O
get_dummies	B-API
`	O
returns	O
a	O
df	O
this	O
will	O
be	O
aligned	O
already	O
with	O
your	O
existing	O
df	O
so	O
just	O
`	O
concat	B-API
`	O
column-wise	O
:	O
#CODE	O

You	O
can	O
drop	O
the	O
'	O
cat	O
'	O
column	O
by	O
doing	O
`	O
df.drop	B-API
(	O
'	O
cat	O
'	O
,	O
axis=1	O
)`	O

You	O
can	O
see	O
that	O
the	O
array	O
is	O
masked	O
and	O
that	O
some	O
of	O
the	O
first	O
few	O
rows	O
show	O
examples	O
of	O
`	O
--	O
`	O
in	O
there	O
.	O

So	O
I	O
drop	O
the	O
last	O
field	O
(	O
`	O
refGage	O
`)	O
and	O
it	O
works	O
,	O
so	O
I	O
think	O
it's	O
masked	O
values	O
which	O
only	O
appear	O
in	O
that	O
field	O
.	O

I	O
used	O
df.ix()	B-API
to	O
replace	O
the	O
filled-in	O
tokens	O
for	O
what	O
was	O
masked	O
out	O
.	O

Next	O
,	O
you	O
can	O
use	O
a	O
dictionary	O
comprehension	O
together	O
with	O
`	O
loc	B-API
`	O
to	O
select	O
the	O
relevant	O
`	O
group_no	O
`	O
dataframe	O
.	O

To	O
get	O
the	O
last	O
group	O
number	O
,	O
I	O
get	O
the	O
last	O
value	O
using	O
`	O
iat	B-API
`	O
for	O
location	O
based	O
indexing	O
.	O

Then	O
apply	O
your	O
method	O
:	O
#CODE	O

Notice	O
that	O
if	O
you	O
unstack	B-API
the	O
`	O
id	O
`	O
index	O
level	O
of	O
`	O
df	O
`	O
then	O
you	O
get	O
:	O
#CODE	O

I'm	O
not	O
used	O
to	O
working	O
with	O
`	O
lists	O
`	O
in	O
columns	O
of	O
Pandas	O
and	O
don't	O
know	O
how	O
to	O
get	O
the	O
intersection	O
of	O
`	O
lists	O
`	O
from	O
two	O
columns	O
in	O
a	O
`	O
dataframe	O
`	O
,	O
then	O
get	O
the	O
index	O
of	O
where	O
the	O
words	O
appear	O
,	O
then	O
apply	O
plus	O
signs	O
to	O
the	O
front	O
of	O
each	O
found	O
index	O
.	O

Or	O
maybe	O
easier	O
would	O
be	O
a	O
string	O
replacement	O
on	O
`	O
df	O
[	O
'	O
Keyword	O
']`	O
using	O
the	O
words	O
from	O
`	O
StemmedAG	O
`	O
?	O

You	O
can	O
use	O
`	O
pivot	B-API
`	O
#CODE	O

Cool	O
I	O
didn't	O
know	O
about	O
pivot	B-API
either	O
...	O

Instead	O
of	O
creating	O
it	O
,	O
we	O
can	O
append	O
it	O
to	O
initial	O
StartDate	O
.	O

However	O
,	O
the	O
DptCityDptCountry	O
might	O
be	O
different	O
but	O
if	O
another	O
ID	O
matches	O
with	O
the	O
StartDate	O
and	O
DptCityDptCountry	O
,	O
it	O
will	O
be	O
added	O
up	O
i.e.	O
#CODE	O

Then	O
use	O
apply	B-API
and	O
return	O
a	O
series	O
indexed	O
on	O
the	O
expanded	O
set	O
of	O
dates	O
for	O
each	O
row	O
(	O
Series	O
of	O
Series	O
=	O
DataFrame	O
)	O
.	O

So	O
for	O
each	O
of	O
the	O
7	O
rows	O
in	O
the	O
DataFrame	O
,	O
I	O
get	O
a	O
series	O
indexed	O
on	O
the	O
expanded	O
date	O
range	O
.	O

Then	O
its	O
just	O
clever	O
stacking	O
,	O
naming	O
,	O
and	O
reset_index	B-API
.	O

Also	O
,	O
if	O
you	O
want	O
to	O
have	O
the	O
ticklabels	O
/	O
tickmarks	O
of	O
the	O
x-axis	O
connected	O
to	O
the	O
"	O
middle	O
axis	O
"	O
(	O
also	O
while	O
panning	O
/	O
zooming	O
)	O
,	O
then	O
it's	O
easiest	O
to	O
insert	O
an	O
extra	O
spine	O
;	O
take	O
a	O
look	O
at	O
[	O
`	O
mpl_toolkits.axisartist	B-API
`]	O
(	O
#URL	O
)	O
for	O
some	O
examples	O
of	O
this	O
.	O

print	O
(	O
'	O
Stock	O
:	O
'	O
,	O
col	O
,	O
'	O
max	O
diff	B-API
:	O
'	O
,	O
sl.max()	O
-	O
sl.min()	O
)`	O

Then	O
merge	O
back	O
to	O
the	O
original	O
dataframe	O
to	O
have	O
your	O
aggregates	O
displayed	O
against	O
each	O
row	O
:	O
#CODE	O

Unfortunately	O
im	O
getting	O
an	O
issue	O
when	O
trying	O
to	O
do	O
the	O
rename	O
.	O

The	O
true	O
/	O
false	O
column	O
does	O
not	O
have	O
a	O
column	O
name	O
,	O
so	O
how	O
would	O
I	O
rename	O
it	O
and	O
then	O
merge	O
it	O
back	O
into	O
the	O
original	O
dataframe	O
?	O

I	O
am	O
using	O
the	O
below	O
code	O
which	O
gives	O
me	O
the	O
summary	O
of	O
count	O
in	O
the	O
pivot	O
table	O
,	O
#CODE	O

but	O
what	O
i	O
want	O
is	O
the	O
%	O
of	O
row	O
calculation	O
as	O
in	O
excel	O
pivot	O
when	O
you	O
right	O
click	O
the	O
pivot	O
and	O
select	O
"	O
show	O
value	O
as	O
->	O
%	O
of	O
Row	O
Total	O
"	O
.	O

Since	O
my	O
Document	O
is	O
a	O
non-numeric	O
value	O
i	O
was	O
not	O
able	O
to	O
get	O
it	O
.	O

i	O
am	O
trying	O
to	O
manipulate	O
the	O
pivot	O
data	O
which	O
will	O
give	O
me	O
the	O
row	O
total	O
,	O
not	O
the	O
data	O
from	O
the	O
dataframe	O
and	O
what	O
i	O
wanted	O
is	O
"	O
%	O
of	O
row	O
total	O
"	O
.	O

you	O
can	O
actually	O
just	O
pass	O
`	O
aggfunc=len	O
`	O
,	O
since	O
`	O
len	B-API
`	O
is	O
already	O
a	O
function	O
:)	O

Hi	O
maxymoo	O
in	O
the	O
link	O
you	O
have	O
given	O
they	O
are	O
manipulating	O
one	O
of	O
the	O
column	O
from	O
the	O
dataframe	O
,	O
but	O
my	O
question	O
is	O
different	O
i	O
am	O
trying	O
to	O
manipulate	O
the	O
pivot	O
data	O
which	O
will	O
give	O
me	O
the	O
row	O
total	O
and	O
what	O
i	O
wanted	O
is	O
"	O
%	O
of	O
row	O
total	O
"	O
.	O

Then	O
you	O
can	O
basically	O
use	O
the	O
solution	O
@USER	O
linked	O
to	O
,	O
but	O
you	O
need	O
to	O
use	O
`	O
iloc	B-API
`	O
or	O
similar	O
b	O
/	O
c	O
the	O
table	O
columns	O
are	O
a	O
little	O
complicated	O
now	O
(	O
being	O
a	O
multi-indexed	O
result	O
of	O
the	O
pivot	O
table	O
)	O
.	O

Unfortunately	O
,	O
if	O
I	O
try	O
to	O
resample	O
,	O
I	O
get	O
an	O
error	O
#CODE	O

Are	O
you	O
ask	O
for	O
a	O
process	O
to	O
interpolate	O
,	O
or	O
a	O
process	O
to	O
aggregate	O
,	O
or	O
both	O
?	O

Firstly	O
,	O
prepare	O
a	O
function	O
to	O
map	O
the	O
day	O
to	O
week	O
#CODE	O

Assume	O
now	O
your	O
initialized	O
new	O
dataframe	O
is	O
`	O
result	O
`	O
,	O
you	O
can	O
now	O
do	O
a	O
join	B-API
#CODE	O

The	O
`	O
Nan	O
`	O
is	O
what	O
you	O
need	O
to	O
interpolate	O
.	O

Turns	O
out	O
the	O
key	O
is	O
to	O
resample	O
a	O
groupby	B-API
object	O
like	O
so	O
:	O
#CODE	O

Then	O
,	O
I	O
append	O
a	O
row	O
of	O
missing	O
values	O
.	O

Finally	O
,	O
I	O
can	O
insert	O
values	O
into	O
this	O
DataFrame	O
one	O
cell	O
at	O
a	O
time	O
.	O

This	O
approach	O
works	O
perfectly	O
fine	O
,	O
with	O
the	O
exception	O
that	O
the	O
append	B-API
statement	O
inserts	O
an	O
additional	O
column	O
to	O
my	O
DataFrame	O
.	O

The	O
append	B-API
is	O
trying	O
to	O
append	O
a	O
column	O
to	O
your	O
dataframe	O
.	O

The	O
column	O
it	O
is	O
trying	O
to	O
append	B-API
is	O
not	O
named	O
and	O
has	O
two	O
None	O
/	O
Nan	O
elements	O
in	O
it	O
which	O
pandas	O
will	O
name	O
(	O
by	O
default	O
)	O
as	O
column	O
named	O
0	O
.	O

In	O
order	O
to	O
do	O
this	O
successfully	O
,	O
the	O
column	O
names	O
coming	O
into	O
the	O
append	B-API
for	O
the	O
data	O
frame	O
must	O
be	O
consistent	O
with	O
the	O
current	O
data	O
frame	O
column	O
names	O
or	O
else	O
new	O
columns	O
will	O
be	O
created	O
(	O
by	O
default	O
)	O
#CODE	O

have	O
merged	O
2	O
dataframes	O
with	O
left	O
join	B-API
.	O
works	O
as	O
I	O
expected	O
until	O
I	O
attempt	O
to	O
use	O
the	O
generated	O
value	O
in	O
a	O
simple	O
string	O
concatenation	O
.	O

I	O
am	O
ultimately	O
trying	O
to	O
merge	O
two	O
dataframes	O
together	O
,	O
but	O
I	O
am	O
running	O
into	O
an	O
issue	O
when	O
I	O
try	O
to	O
specify	O
the	O
column	O
on	O
which	O
they	O
should	O
be	O
merged	O
.	O

Conform	O
the	O
index	O
to	O
another	O
frequency	O
.	O

Then	O
its	O
straightforward	O
to	O
resample	O
to	O
another	O
frequency	O
.	O

In	O
the	O
second	O
chunk	O
you	O
are	O
resampling	O
and	O
the	O
result	O
is	O
a	O
Series	O
of	O
monthly	O
frequency	O
so	O
it	O
would	O
appear	O
that	O
the	O
daily	O
information	O
is	O
lost	O
.	O

Then	O
you	O
resample	O
and	O
somehow	O
the	O
days	O
are	O
there	O
?	O

I	O
want	O
to	O
use	O
a	O
combination	O
of	O
map	B-API
&	O
lambda	O
functions	O
to	O
do	O
this	O

the	O
map	B-API
function	O
does	O
not	O
append	O
to	O
NN	O
.	O

Have	O
you	O
tried	O
using	O
`	O
concat	B-API
`	O
and	O
a	O
generator	O
expression	O
instead	O
:	O
#CODE	O

Can	O
Pandas	O
find	O
all	O
the	O
lines	O
that	O
join	O
any	O
pair	O
of	O
dots	O
and	O
don't	O
intersect	O
any	O
of	O
the	O
given	O
lines	O
without	O
iteration	O
?	O

I'm	O
a	O
Stata	O
user	O
and	O
in	O
Stata	O
,	O
I'd	O
be	O
using	O
replace	B-API
command	O
conditional	O
on	O
regexm	O
.	O

I'm	O
trying	O
to	O
learn	O
Python	O
and	O
it's	O
been	O
a	O
difficult	O
journey	O
!	O

We	O
then	O
apply	O
another	O
function	O
to	O
this	O
that	O
converts	O
the	O
str	O
numbers	O
to	O
ints	O
,	O
puts	O
these	O
in	O
a	O
list	O
and	O
returns	O
the	O
smallest	O
value	O
:	O
#CODE	O

this	O
is	O
an	O
approach	O
that	O
I	O
hadn't	O
thought	O
about	O
and	O
one	O
that	O
I'm	O
likely	O
to	O
employ	O
down	O
the	O
road	O
.	O
for	O
age	O
,	O
I	O
wanted	O
the	O
series	O
[	O
62	O
,	O
55	O
,	O
67	O
]	O
at	O
the	O
end	O
,	O
and	O
the	O
problem	O
I'm	O
having	O
now	O
is	O
that	O
I	O
can't	O
target	O
just	O
row2	O
when	O
I	O
apply	O
split	B-API
(	O
'	O
')	O
.	O

return	O
min	B-API
(	O
list	O
(	O
map	B-API
(	O
int	O
,	O
x	O
)))`	O
to	O
`	O
def	O
highest	O
(	O
x	O
):	O

return	O
max	B-API
(	O
list	O
(	O
map	B-API
(	O
int	O
,	O
x	O
)))`	O

I	O
want	O
to	O
apply	O
df	O
[	O
'	O
age	O
']	O
=d	O
f	O
[	O
'	O
e0	O
']	O
[(	O
df	O
[	O
'	O
e0	O
']	O
.str	B-API
.match	B-API
(	O
pattern7	O
)=	O
=1	O
)]	O
.apply	B-API
(	O
lambda	O
x	O
:	O
str	O
(	O
x	O
)	O
.split	B-API
(	O
'	O
')	O
[	O
1	O
])	O
to	O
only	O
rows	O
for	O
which	O
df	O
[	O
'	O
e0	O
']	O
.str	B-API
.match	B-API
(	O
pattern7	O
)=	O
=1	O
)	O
so	O
as	O
to	O
not	O
overwrite	O
what	O
was	O
already	O
in	O
the	O
age	O
column	O
...	O

Suppose	O
I	O
have	O
two	O
DataFrames	O
a	O
b	O
where	O
a	O
is	O
larger	O
than	O
b	O
and	O
has	O
all	O
NaNs	O
.	O

I	O
wish	O
to	O
merge	O
the	O
values	O
from	O
b	O
into	O
a	O
.	O

the	O
w	O
variable	O
will	O
not	O
surpass	O
len	B-API
(	O
seq	O
)	O
.	O

For	O
example	O
instead	O
of	O
looping	O
trough	O
every	O
element	O
in	O
a	O
numpy	O
array	O
to	O
do	O
some	O
processing	O
you	O
can	O
apply	O
a	O
numpy	O
function	O
directly	O
on	O
the	O
array	O
and	O
get	O
the	O
results	O
in	O
seconds	O
rather	O
than	O
hours	O
.	O
as	O
an	O
example	O
:	O
#CODE	O

Computing	O
`	O
len	B-API
(	O
seq	O
)`	O
inside	O
the	O
loop	O
is	O
not	O
necessary	O
,	O
since	O
its	O
value	O
is	O
not	O
changing	O
.	O

You	O
don't	O
really	O
need	O
the	O
`	O
if	O
`	O
statement	O
,	O
since	O
in	O
your	O
code	O
it	O
always	O
evaluate	O
to	O
true	O
(	O
`	O
w	O
in	O
range	O
(	O
len	B-API
(	O
seq	O
))`	O
means	O
`	O
w	O
`	O
maximium	O
value	O
will	O
be	O
`	O
len	B-API
(	O
seq	O
)	O
-1	O
`)	O
.	O

I	O
tried	O
pivot	B-API
but	O
it	O
returns	O
an	O
error	O

Hmm	O
My	O
dataframe	O
had	O
12	O
rows	O
but	O
when	O
i	O
tried	O
the	O
unstack	B-API
operation	O
the	O
resulting	O
dataframe	O
has	O
only	O
6	O
rows	O
not	O
exactly	O
what	O
i	O
want.My	O
resulting	O
dataframe	O
should	O
also	O
have	O
12	O
rows	O

For	O
example	O
,	O
say	O
`	O
Jul-03	O
`	O
data	O
,	O
row	O
`	O
0	O
,	O
6	O
,	O
9	O
`	O
are	O
all	O
records	O
about	O
the	O
same	O
`	O
snapDate	O
`	O
with	O
instance	O
`	O
XX	O
`	O
.	O

So	O
doing	O
a	O
pivot	B-API
would	O
reshape	O
these	O
3	O
rows	O
to	O
only	O
one	O
row	O
because	O
those	O
data	O
have	O
been	O
moved	O
to	O
columns	O
.	O

Hi	O
I	O
went	O
ahead	O
and	O
changed	O
the	O
datatype	O
of	O
AvgWaitInMs	O
to	O
int	O
and	O
the	O
pivot	B-API
worked	O

What	O
I	O
would	O
like	O
to	O
do	O
is	O
slice	O
each	O
group	O
down	O
to	O
3	O
hours	O
max	O
and	O
append	O
something	O
to	O
the	O
6	O
and	O
9	O
length	O
groups	O
to	O
denote	O
that	O
it	O
is	O
the	O
same	O
page	O
like	O
the	O
following	O
:	O
#CODE	O

So	O
,	O
I	O
truncated	O
my	O
data	O
set	O
in	O
the	O
question	O
to	O
make	O
it	O
easier	O
to	O
read	O
and	O
thinking	O
that	O
whatever	O
solution	O
came	O
would	O
also	O
apply	O
..	O

If	O
'	O
data	O
'	O
is	O
a	O
pd.DataFrame	B-API
and	O
you	O
iterate	O
over	O
range	O
(	O
0	O
,	O
len	B-API
(	O
data	O
))	O
and	O
then	O
add	O
data	O
to	O
your	O
list	O
'	O
all_info	O
'	O
,	O
you	O
simply	O
add	O
the	O
whole	O
DataFrame	O
'	O
data	O
'	O
i	O
times	O
to	O
the	O
list	O
.	O

Python	O
pandas	O
:	O
retrieve	O
the	O
field	O
associated	O
to	O
the	O
min	O
of	O
another	O
(	O
cross	O
apply	O
equivalent	O
)	O

In	O
SQL	O
I	O
was	O
used	O
to	O
doing	O
this	O
with	O
a	O
cross	O
apply	O
.	O

PS	O
other	O
than	O
calculating	O
the	O
min	O
first	O
,	O
then	O
doing	O
a	O
join	B-API
on	O
primary	O
key	O
and	O
date	O

I	O
can	O
do	O
this	O
in	O
two	O
steps	O
:	O
1	O
)	O
group	O
by	O
primary	O
key	O
and	O
calculate	O
min	O
(	O
date	O
)	O
2	O
)	O
do	O
an	O
inner	O
join	B-API
between	O
the	O
starting	O
table	O
and	O
the	O
table	O
calculated	O
in	O
the	O
previous	O
step	O
,	O
on	O
primary	O
key	O
and	O
date	O
,	O
to	O
retrieve	O
the	O
amount	O

Call	O
`	O
resample	B-API
`	O
and	O
pass	O
the	O
rule	O
as	O
'	O
10Min	O
'	O
:	O
#CODE	O

The	O
quickest	O
way	O
I	O
know	O
how	O
to	O
wrangle	O
this	O
thing	O
into	O
a	O
long	O
form	O
dataframe	O
is	O
using	O
`	O
stack	B-API
`	O
and	O
then	O
`	O
reset_index	B-API
`	O
:	O
#CODE	O

Maybe	O
my	O
real	O
question	O
is	O
"	O
why	O
isn't	O
`	O
melt	B-API
`	O
a	O
DataFrame	O
method	O
?	O

This	O
works	O
pretty	O
well	O
:	O
`	O
pd.melt	B-API
(	O
wide_df.reset_index()	O
,	O
"	O
subject	O
")`	O
,	O
but	O
it	O
feels	O
like	O
it	O
would	O
be	O
easier	O
to	O
read	O
as	O
chained	O
method	O
calls	O
that	O
can	O
be	O
read	O
in	O
linear	O
order	O
.	O

not	O
sure	O
why	O
their	O
isn't	O
a	O
``	O
melt	B-API
``	O
on	O
DataFrame	O
,	O
could	O
/	O
should	O
be	O
.	O

bool	O
operator	O
in	O
for	O
Timestamp	O
in	O
Series	O
does	O
not	O
work	O

Is	O
there	O
a	O
way	O
to	O
drop	O
columns	O
in	O
a	O
Dataframe	O
with	O
column	O
names	O
having	O
a	O
particular	O
letter	O
as	O
I	O
wasn't	O
able	O
to	O
find	O
any	O
information	O
on	O
this	O
?	O

I	O
want	O
to	O
drop	O
all	O
column	O
headers	O
having	O
the	O
letter	O
`	O
F	O
`	O
in	O
them	O
.	O

I	O
was	O
planning	O
on	O
doing	O
it	O
using	O
`	O
df.drop	B-API
([	O
df.columns	B-API
[[	O
column_names	O
]]]	O
,	O
axis=1	O
)`	O
,	O
but	O
there	O
are	O
so	O
many	O
that	O
I	O
was	O
wondering	O
if	O
there	O
is	O
an	O
easier	O
way	O
to	O
do	O
this	O
.	O

Rolling	B-API
argmax	B-API
in	O
pandas	O

I	O
have	O
a	O
pandas	O
TimeSeries	O
and	O
would	O
like	O
to	O
apply	O
the	O
argmax	B-API
function	O
to	O
a	O
rolling	B-API
window	O
.	O

However	O
,	O
due	O
to	O
casting	O
to	O
float	O
from	O
rolling_apply	B-API
,	O
if	O
I	O
apply	O
`	O
numpy.argmax()	B-API
`	O
,	O
I	O
only	O
obtain	O
the	O
index	O
of	O
the	O
slice	O
of	O
the	O
ndarray	O
.	O

Is	O
there	O
a	O
way	O
to	O
apply	O
a	O
rolling	B-API
argmax	B-API
to	O
a	O
Series	O
/	O
DataFrame	O
?	O

Here	O
is	O
a	O
work-around	O
,	O
essentially	O
doing	O
the	O
apply	B-API
'	O
manually	O
'	O
,	O
should	O
be	O
pretty	O
efficient	O
actually	O
.	O

You	O
could	O
do	O
a	O
`	O
shift	B-API
`	O
first	O
:	O
#CODE	O

Merge	O
csv's	O
with	O
some	O
common	O
columns	O
and	O
fill	O
in	O
Nans	O

pandas	O
-	O
resample	B-API
-	O
upsampling	O
before	O
downsampling	O

My	O
objective	O
is	O
to	O
resample	O
this	O
data	O
frame	O
with	O
a	O
fixed	O
time	O
window	O
(	O
e.g.	O
:	O
1	O
second	O
)	O
using	O
last	O
for	O
regularization	O
when	O
upsampling	O
and	O
the	O
mean	O
for	O
downsampling	O
.	O

Is	O
this	O
possible	O
at	O
all	O
using	O
pandas	O
resample	B-API
function	O
?	O

You	O
can't	O
mix	O
upsample	O
/	O
downsample	O
in	O
a	O
single	O
`	O
resample	B-API
`	O
operation	O
.	O

I'm	O
not	O
sure	O
why	O
the	O
order	O
of	O
operations	O
would	O
matter	O
to	O
you	O
as	O
long	O
as	O
you	O
get	O
the	O
desired	O
results	O
.	O

Thanks	O
for	O
your	O
answer	O
,	O
it	O
was	O
not	O
clear	O
to	O
me	O
that	O
you	O
had	O
to	O
make	O
multiple	O
calls	O
to	O
resample	B-API
.	O

You	O
can	O
then	O
concat	O
this	O
back	O
to	O
get	O
the	O
'	O
I	O
'	O
column	O
back	O
:	O
#CODE	O

Actually	O
setting	O
index_col=	O
'	O
I	O
'	O
when	O
reading	O
allows	O
to	O
avoid	O
the	O
concat	B-API
!	O

As	O
a	O
follow	O
up	O
to	O
this	O
post	O
,	O
I	O
would	O
like	O
to	O
concatenate	O
a	O
number	O
of	O
columns	O
based	O
on	O
their	O
index	O
but	O
I	O
am	O
encountering	O
some	O
problems	O
.	O

In	O
this	O
example	O
I	O
get	O
an	O
Attribute	O
error	O
related	O
to	O
the	O
map	B-API
function	O
.	O

Help	O
around	O
this	O
error	O
would	O
be	O
appreciated	O
as	O
would	O
code	O
that	O
does	O
the	O
equivalent	O
concatenation	O
of	O
columns	O
.	O

note	O
that	O
support	O
for	O
`	O
filter	B-API
(	O
None	O
,	O
iterable	O
)`	O
ceased	O
in	O
Python	O
3	O
,	O
need	O
to	O
do	O
`	O
filter	B-API
(	O
bool	O
,	O
iterable	O
)`	O
there	O

I	O
have	O
found	O
workaround	O
which	O
is	O
extremely	O
slow	O
due	O
to	O
the	O
"	O
in	O
python	O
"	O
apply	B-API
:	O
#CODE	O

How	O
to	O
drop	O
extra	O
copy	O
of	O
duplicate	O
index	O
of	O
Pandas	O
Series	O
?	O

So	O
how	O
to	O
drop	O
extra	O
duplicate	O
rows	O
of	O
series	O
,	O
keep	O
the	O
unique	O
rows	O
and	O
only	O
one	O
copy	O
of	O
the	O
duplicate	O
rows	O
in	O
an	O
efficient	O
way	O
?	O

One	O
way	O
would	O
be	O
using	O
`	O
drop	B-API
`	O
and	O
`	O
index.get_duplicates	B-API
`	O
:	O
#CODE	O

Not	O
totally	O
drop	O
the	O
duplicated	O
ones	O
.	O

You	O
can	O
groupby	B-API
the	O
index	O
and	O
apply	O
a	O
function	O
that	O
returns	O
one	O
value	O
per	O
index	O
group	O
.	O

@USER	O
sorry	O
,	O
"	O
arbitrary	O
"	O
of	O
length	O
len	B-API
(	O
s	O
)	O
:)	O
.	O

Below	O
is	O
my	O
snippet	O
:	O
import	O
pandas	O
as	O
pd	O
;	O
idx_tp	O
=	O
[(	O
'	O
600809	O
'	O
,	O
'	O
20061231	O
')	O
,	O
(	O
'	O
600809	O
'	O
,	O
'	O
20070331	O
')	O
,	O
(	O
'	O
600809	O
'	O
,	O
'	O
20070630	O
')	O
,	O
(	O
'	O
600809	O
'	O
,	O
'	O
20070331	O
')]	O
;	O
dt	B-API
=	O
[	O
'	O
demo	O
'	O
,	O
'	O
demo	O
'	O
,	O
'	O
demo	O
'	O
,	O
'	O
demo	O
']	O
;	O
idx	O
=	O
pd.MultiIndex.from_tuples	B-API
(	O
idx_tp	O
,	O
names	O
=	O
[	O
'	O
STK_ID	O
'	O
,	O
'	O
RPT_Date	O
'])	O
;	O
s	O
=	O
pd.Series	B-API
(	O
dt	B-API
,	O
index=idx	O
);	O
#	O
s.groupby	O
(	O
s.index	O
)	O
.first()	B-API
will	O
crash	O
on	O
my	O
machine	O

Edit	O
:	O
another	O
solution	O
which	O
is	O
faster	O
is	O
to	O
use	O
`	O
value_counts	B-API
`	O
(	O
and	O
normalize	B-API
):	O
#CODE	O

I	O
had	O
thought	O
this	O
was	O
more	O
concisely	O
written	O
as	O
a	O
`	O
resample	B-API
`	O
,	O
if	O
you	O
use	O
a	O
DatetimeIndex	B-API
:	O

len	B-API
(	O
Series.unique()	B-API
)	O
might	O
be	O
even	O
faster	O
.	O

Interestingly	O
,	O
len	B-API
(	O
Series.unique()	B-API
)	O
is	O
usually	O
much	O
faster	O
than	O
Series.nunique()	B-API
.	O

Next	O
,	O
these	O
3	O
columns	O
should	O
be	O
combined	O
into	O
one	O
column	O
-	O
the	O
mean	O
of	O
the	O
order	O
numbers	O
-	O
but	O
I	O
do	O
know	O
how	O
to	O
do	O
that	O
part	O
(	O
with	O
apply	B-API
and	O
axis=1	O
)	O
.	O

I	O
would	O
like	O
to	O
normalize	O
my	O
data	O
by	O
dividing	O
every	O
row	O
by	O
the	O
first	O
value	O
of	O
that	O
very	O
row	O
.	O

I	O
am	O
just	O
getting	O
stuck	O
on	O
"	O
setting	O
with	O
chained	O
indexing	O
"	O
and	O
setting	O
with	O
iloc	B-API
/	O
loc	B-API
/	O
ix	B-API
.	O

I	O
can't	O
figure	O
out	O
how	O
to	O
represent	O
this	O
using	O
iloc	B-API
,	O
loc	B-API
and	O
ix	B-API
.	O

Python	O
2.7	O
&	O
Pandas	O
:	O
How	O
to	O
replace	O
values	O
at	O
12:00	O
with	O
values	O
from	O
11:55	O
?	O

How	O
do	O
I	O
explicitly	O
say	O
'	O
replace	O
the	O
values	O
at	O
19:40	O
:	O
00	O
with	O
the	O
values	O
at	O
19:35	O
:	O
00	O
?	O

Python	O
merge	O
excel	O
documents	O
with	O
dynamic	O
columns	O

However	O
,	O
since	O
they	O
are	O
not	O
100%	O
identical	O
,	O
I	O
cannot	O
simply	O
merge	O
them	O
together	O
and	O
upload	O
it	O
into	O
a	O
database	O
without	O
messing	O
up	O
the	O
data	O
.	O

If	O
a	O
large	O
proportion	O
of	O
them	O
are	O
similar	O
,	O
and	O
this	O
is	O
a	O
one-off	O
operation	O
it	O
may	O
be	O
worth	O
your	O
while	O
coding	O
the	O
solution	O
for	O
the	O
majority	O
and	O
handling	O
the	O
other	O
documents	O
(	O
or	O
groups	O
of	O
them	O
if	O
they	O
are	O
similar	O
)	O
separately	O
.	O

Any	O
recommendations	O
to	O
a	O
db	O
that	O
would	O
allow	O
me	O
to	O
dump	O
a	O
few	O
thousand	O
excel	O
documents	O
and	O
then	O
create	O
join	U
queries	O
to	O
the	O
VIN	O
column	O
?	O

I	O
am	O
doing	O
a	O
transformation	O
on	O
a	O
variable	O
from	O
a	O
pandas	O
dataframe	O
and	O
then	O
I	O
would	O
like	O
to	O
replace	O
the	O
column	O
with	O
my	O
new	O
values	O
.	O

The	O
problem	O
seems	O
to	O
be	O
that	O
after	O
the	O
transformation	O
,	O
the	O
length	O
of	O
the	O
array	O
is	O
not	O
the	O
same	O
as	O
the	O
length	O
of	O
my	O
dataframe's	O
index	O
.	O

When	O
I	O
check	O
the	O
length	O
,	O
these	O
lengths	O
seem	O
to	O
disagree	O
.	O

The	O
len	B-API
(	O
array	O
)	O
says	O
it	O
is	O
2	O
but	O
when	O
I	O
call	O
the	O
stats.boxcox	U
it	O
says	O
it	O
is	O
50000	O
.	O

Print	O
out	O
`	O
len	B-API
(	O
df	O
)`	O
and	O
`	O
len	B-API
(	O
stats.boxcox	U
(	O
df.variable	O
))`	O
.	O

How	O
to	O
calculate	O
the	O
count	O
of	O
column	O
values	O
less	O
than	O
95	O
on	O
each	O
row	O
on	O
pandas	O
pivot	O
table	O

I	O
am	O
new	O
to	O
pandas	O
pivot	O
tables	O
,	O
how	O
to	O
get	O
the	O
count	O
of	O
column	O
values	O
less	O
than	O
95	O
for	O
a	O
row	O
on	O
pandas	O
pivot	O
table	O
#CODE	O

My	O
decorated	O
DataFrames	O
return	O
new	O
and	O
similarly	O
decorated	O
DataFrames	O
when	O
I	O
use	O
methods	O
such	O
as	O
copy	B-API
and	O
groupby.agg	B-API
.	O

I.e.	O
,	O
how	O
can	O
I	O
have	O
my	O
decorated	O
DataFrames	O
replace	O
the	O
stock	O
DataFrames	O
?	O

Still	O
not	O
getting	O
the	O
hang	O
of	O
pandas	O
,	O
I	O
am	O
attempting	O
to	O
join	O
two	O
data	O
frames	O
in	O
Pandas	O
using	O
merge	B-API
.	O

I	O
have	O
read	O
in	O
the	O
CSVs	O
into	O
two	O
data	O
frames	O
(	O
named	O
dropData	O
and	O
deosData	O
in	O
the	O
code	O
below	O
)	O
.	O

The	O
deosData	O
file	O
is	O
an	O
entire	O
year	O
s	O
worth	O
of	O
observations	O
that	O
I	O
am	O
trying	O
to	O
match	O
up	O
with	O
corresponding	O
entries	O
in	O
dropData	O
.	O

I	O
have	O
gone	O
through	O
the	O
documentation	O
for	O
the	O
merge	B-API
function	O
and	O
have	O
tried	O
the	O
following	O
code	O
in	O
various	O
iterations	O
,	O
so	O
far	O
I	O
have	O
only	O
been	O
able	O
to	O
have	O
a	O
blank	O
data	O
frame	O
with	O
correct	O
header	O
row	O
,	O
or	O
have	O
the	O
two	O
data	O
frames	O
merged	O
on	O
the	O
0	O
--	O
(	O
N-1	O
)	O
indexing	O
that	O
is	O
assigned	O
by	O
default	O
:	O

After	O
searching	O
on	O
SE	O
and	O
the	O
Doc	O
s	O
I	O
have	O
tried	O
resetting	O
the	O
index	O
,	O
ignoring	O
the	O
index	O
columns	O
,	O
copying	O
the	O
Date_Time	O
column	O
as	O
a	O
separate	O
index	O
and	O
trying	O
to	O
merge	O
on	O
the	O
new	O
column	O
,	O
I	O
have	O
tried	O
using	O
on=None	O
,	O
left_on	O
and	O
right_on	O
as	O
permutations	O
of	O
Date_Time	O
to	O
no	O
avail	O
.	O

I	O
have	O
checked	O
the	O
column	O
data	O
types	O
,	O
Date_Time	O
in	O
both	O
are	O
dtype	B-API
Objects	O
,	O
I	O
do	O
not	O
know	O
if	O
this	O
is	O
the	O
source	O
of	O
the	O
error	O
,	O
since	O
the	O
only	O
issues	O
I	O
could	O
find	O
searching	O
revolved	O
around	O
matching	O
different	O
dtypes	B-API
to	O
each	O
other	O
.	O

What	O
I	O
am	O
looking	O
to	O
do	O
is	O
have	O
the	O
two	O
data	O
frames	O
merge	O
where	O
the	O
two	O
'	O
Date_Time	O
'	O
columns	O
intersect	O
.	O

and	O
then	O
do	O
your	O
merge	U
.	O

You	O
can	O
use	O
`	O
join	B-API
`	O
,	O
but	O
you	O
first	O
need	O
to	O
set	O
the	O
index	O
:	O
#CODE	O

You	O
can	O
also	O
do	O
`	O
groupby	B-API
(	O
...,	O
as_index=False	O
)`	O
,	O
though	O
buggy	O
with	O
apply	B-API
in	O
0.12	O
,	O
fixed	O
in	O
0.13	O
.	O

I've	O
converted	O
the	O
last	O
step	O
to	O
no	O
longer	O
be	O
a	O
loop	O
and	O
instead	O
save	O
directly	O
to	O
a	O
list	O
.	O

AFAIK	O
,	O
you	O
would	O
have	O
to	O
separate	O
the	O
two	O
parts	O
and	O
append	O
as	O
lists	O
since	O
the	O
columns	O
of	O
interest	O
are	O
different	O
and	O
converting	O
to	O
a	O
dictionary	O
would	O
include	O
the	O
`	O
NaN	O
`	O
s	O
otherwise	O
.	O

When	O
using	O
the	O
pure	O
XlsxWriter	O
I	O
can	O
apply	O
formats	O
to	O
cells	O
what	O
also	O
works	O
nice	O
.	O

Basically	O
how	O
would	O
I	O
apply	O
`	O
df	O
[	O
'	O
col1	O
']	O
.str	B-API
.contains	B-API
(	O
'	O
^	O
')`	O
to	O
an	O
entire	O
dataframe	O
at	O
once	O
and	O
filter	O
down	O
to	O
any	O
rows	O
that	O
have	O
records	O
containing	O
the	O
match	O
?	O

Pandas	O
:	O
apply	O
different	O
functions	O
to	O
different	O
columns	O

i	O
am	O
looking	O
to	O
apply	O
multiply	O
masks	O
on	O
each	O
column	O
of	O
a	O
pandas	O
dataset	O
(	O
respectively	O
to	O
it's	O
properties	O
)	O
in	O
python	O
.	O

how	O
can	O
i	O
apply	O
the	O
concat_mask	O
on	O
df	O
,	O
so	O
that	O
i	O
select	O
rows	O
,	O
in	O
which	O
all	O
Boolean	O
criteria	O
are	O
matched	O
(	O
are	O
True	O
)	O
?	O

.	O
Can	O
You	O
insert	O
that	O
into	O
your	O
answer	O
?	O

In	O
the	O
proper	O
code	O
i	O
actually	O
iterate	O
throw	O
all	O
columns	O
and	O
apply	O
various	O
of	O
diffenrent	O
conditions	O
to	O
mask	O
each	O
column	O
.	O

If	O
you	O
return	O
a	O
Series	O
of	O
the	O
(	O
split	O
)	O
location	O
,	O
you	O
can	O
merge	O
(	O
`	O
join	B-API
`	O
to	O
merge	O
on	O
index	O
)	O
the	O
resulting	O
DF	O
directly	O
with	O
your	O
value	O
column	O
.	O

If	O
I'm	O
not	O
mistaken	O
,	O
it	O
only	O
works	O
if	O
`	O
df	O
`	O
has	O
index	O
that	O
is	O
`	O
range	O
(	O
len	B-API
(	O
df	O
))`	O
,	O
right	O
?	O

`	O
join	B-API
`	O
is	O
shorthand	O
for	O
merging	O
on	O
index	O
with	O
both	O
frames	O
,	O
so	O
the	O
indices	O
need	O
only	O
be	O
consistent	O
(	O
which	O
it	O
will	O
be	O
here	O
as	O
the	O
apply	B-API
and	O
col	O
selection	O
don't	O
affect	O
it	O
)	O
.	O

How	O
to	O
resample	O
a	O
dataframe	O
with	O
different	O
functions	O
applied	O
to	O
each	O
column	O
?	O

You	O
can	O
also	O
downsample	O
using	O
the	O
`	O
asof	B-API
`	O
method	O
of	O
`	O
pandas.DateRange	U
`	O
objects	O
.	O

@	O
Wes	O
McKinney	O
this	O
should	O
be	O
`	O
resample	B-API
`	O
in	O
0.8	O
,	O
isn't	O
it	O
?	O

Therefore	O
,	O
I	O
join	B-API
the	O
index	O
of	O
`	O
count_df	O
`	O
(	O
`	O
left_index=True	O
`)	O
with	O
the	O
`	O
CompanyName	O
`	O
column	O
of	O
`	O
df	O
`	O
(	O
`	O
right_on=	O
"	O
CompanyName	O
"`)	O
.	O

You	O
can	O
drop	O
the	O
extraneous	O
column	O
using	O
`	O
df.drop	B-API
`	O
:	O
#CODE	O

(	O
3	O
)	O
save	O
the	O
header	O
columns	O
for	O
concat	B-API
later	O
#CODE	O

(	O
5	O
)	O
output	O
:	O
concat	B-API
[	O
header	O
data	O
]	O
.	O
write	O
output	O
#CODE	O

groupby	B-API
after	O
concat	B-API
,	O
column	O
missing	O
in	O
the	O
group	O
mean	O

concat	B-API
two	O
dataframe	O
,	O
then	O
groupby	B-API
'	O
type	O
'	O
and	O
calculate	O
the	O
mean	O
,	O
columns	O
of	O
second	O
df	O
,	O
i.e.	O
d1~d10	O
,	O
showing	O
in	O
the	O
concat'ed	O
dataframe	O
but	O
not	O
in	O
the	O
grouped	O
mean	O
.	O

I	O
want	O
to	O
create	O
a	O
new	O
DataFrame	O
such	O
that	O
each	O
row	O
is	O
created	O
from	O
the	O
original	O
df	O
but	O
rows	O
with	O
loc	O
counts	O
greater	O
than	O
2	O
are	O
excluded	O
.	O

That	O
is	O
,	O
the	O
new	O
df	O
is	O
created	O
by	O
looping	O
through	O
the	O
old	O
df	O
,	O
counting	O
the	O
number	O
of	O
loc	O
rows	O
that	O
have	O
come	O
before	O
,	O
and	O
including	O
/	O
excluding	O
the	O
row	O
based	O
on	O
this	O
count	O
.	O

The	O
output	O
excludes	O
the	O
4th	O
row	O
in	O
the	O
original	O
df	O
because	O
its	O
loc	O
count	O
is	O
greater	O
than	O
2	O
(	O
i.e.	O
3	O
)	O
.	O

Also	O
,	O
be	O
careful	O
with	O
your	O
column	O
names	O
,	O
since	O
`	O
loc	O
`	O
clashes	O
with	O
the	O
`	O
.loc	B-API
`	O
method	O
.	O

So	O
you	O
get	O
a	O
string	O
back	O
:)	O
.	O

You	O
can	O
use	O
eval	B-API
(	O
""	O
[	O
1.5	O
,	O
2.5	O
,	O
3.5	O
]"")	O
,	O
but	O
I	O
hear	O
it's	O
bad	O
practice	O
.	O

You	O
can	O
map	O
your	O
lists	O
to	O
strings	O
by	O
using	O
`"	O
,	O
"	O
.join	B-API
(	O
your_list	O
)`	O
given	O
that	O
you	O
only	O
use	O
floats	O
.	O

merge	B-API
the	O
dataframe	O
on	O
ID	O
#CODE	O

The	O
`	O
merge	B-API
`	O
did	O
the	O
trick	O
,	O
but	O
I	O
thought	O
it	O
was	O
more	O
usefull	O
to	O
just	O
do	O
a	O
`	O
dfMerged.dropna()	O
`	O
after	O
the	O
merge	B-API
and	O
that	O
will	O
be	O
the	O
set	O
with	O
the	O
difference	O
.	O

yes	O
,	O
essentially	O
,	O
the	O
answer	O
was	O
really	O
about	O
the	O
`	O
merge	B-API
`	O
method	O
,	O
which	O
allows	O
you	O
to	O
sql-like	O
joins	O
.	O

Instead	O
,	O
I	O
get	O
an	O
error	O
telling	O
me	O
that	O
equiv	O
is	O
not	O
a	O
callable	O
function	O
.	O

Fair	O
enough	O
,	O
it's	O
a	O
dictionary	O
,	O
but	O
even	O
if	O
I	O
wrap	O
it	O
in	O
a	O
function	O
I	O
still	O
get	O
frustration	O
.	O

So	O
I	O
tried	O
to	O
use	O
a	O
map	B-API
function	O
that	O
seems	O
to	O
work	O
with	O
other	O
operations	O
,	O
but	O
it	O
also	O
is	O
defeated	O
by	O
use	O
of	O
a	O
dictionary	O
:	O
#CODE	O

ok	O
,	O
revised	O
the	O
answer	O
;	O
you	O
can	O
do	O
almost	O
anything	O
inside	O
the	O
apply	U
FYI	O

In	O
order	O
to	O
normalize	O
data	O
in	O
a	O
pandas	O
DataFrame	O
I	O
wrote	O
the	O
following	O
functions	O
:	O
#CODE	O

If	O
you	O
want	O
the	O
values	O
themselves	O
,	O
you	O
can	O
`	O
groupby	B-API
`	O
'	O
Column1	O
'	O
and	O
then	O
call	O
`	O
apply	B-API
`	O
and	O
pass	O
the	O
`	O
list	U
`	O
method	O
to	O
apply	O
to	O
each	O
group	O
.	O

You	O
could	O
`	O
groupby	B-API
`	O
on	O
`	O
Column1	O
`	O
and	O
then	O
take	O
`	O
Column3	O
`	O
to	O
`	O
apply	B-API
(	O
list	O
)`	O
and	O
call	O
`	O
to_dict	B-API
`	O
?	O

Pandas	O
-	O
How	O
can	O
I	O
set	O
rules	O
for	O
selecting	O
which	O
duplicates	O
to	O
drop	O

What	O
I	O
want	O
to	O
do	O
is	O
drop	O
the	O
values	O
that	O
have	O
the	O
same	O
index	O
(	O
date	O
time	O
)	O
,	O
but	O
I	O
want	O
to	O
make	O
a	O
rule	O
like	O
:	O

I	O
have	O
tried	O
using	O
groupby	B-API
and	O
apply	B-API
in	O
several	O
different	O
ways	O
but	O
I	O
cant	O
get	O
it	O
to	O
work	O
.	O

You	O
could	O
use	O
`	O
del	O
df	O
[	O
'	O
dist	O
']`	O
to	O
drop	O
the	O
dist	O
column	O
when	O
you	O
no	O
longer	O
need	O
it	O
.	O

Though	O
I	O
was	O
wondering	O
if	O
you	O
could	O
do	O
it	O
immediately	O
using	O
lambda	O
,	O
apply	B-API
and	O
groupby	B-API
.	O

I	O
am	O
sorry	O
I	O
am	O
trying	O
to	O
insert	O
code	O
into	O
comments	O
I	O
cant	O
do	O
it	O

All	O
I	O
am	O
doing	O
at	O
the	O
moment	O
is	O
loading	O
the	O
.csv	O
as	O
a	O
dataframe	O
and	O
then	O
writing	O
it	O
to	O
the	O
db	O
using	O
`	O
df.to_sql	B-API
(	O
table_name	O
,	O
engine	O
,	O
index=False	O
,	O
if_exists=	O
'	O
append	B-API
'	O
,	O
chunksize=1000	O
)`	O

I	O
want	O
to	O
transform	O
it	O
into	O
a	O
single	O
column	O
data	O
with	O
index	O
being	O
year-month	O
.	O

I	O
try	O
to	O
stack	O
my	O
original	O
data	O
but	O
it	O
becomes	O
a	O
time	O
series	O
,	O
which	O
has	O
the	O
year	O
mix	O
with	O
my	O
values	O
.	O

`	O
set_index	B-API
`	O
to	O
`	O
Year	O
`	O
first	O
,	O
and	O
then	O
`	O
stack	B-API
`	O
.	O

OLS	O
solution	O
using	O
pinv	B-API
/	O
svd	B-API
#CODE	O

The	O
bad	O
days	O
are	O
eliminated	O
,	O
and	O
the	O
good	O
ones	O
are	O
kept	O
.	O

shape	O
mismatch	O
:	O
value	O
array	O
of	O
shape	B-API
(	O
1000	O
,	O
)	O
could	O
not	O
be	O
broadcast	O
to	O
indexing	O
result	O
of	O
shape	B-API
(	O
1000,3,255,255	O
)	O

@USER	O
Well	O
in	O
this	O
case	O
,	O
`	O
searchsorted	B-API
`	O
is	O
basically	O
looking	O
for	O
places	O
or	O
indices	O
where	O
elements	O
from	O
`	O
message	O
`	O
exists	O
in	O
the	O
keys	O
of	O
`	O
codes	O
`	O
.	O

@USER	O
--	O
I	O
had	O
a	O
hard	O
time	O
remembering	O
how	O
`	O
translate	O
`	O
and	O
`	O
maketrans	O
`	O
work	O
for	O
quite	O
a	O
while	O
too	O
,	O
but	O
I've	O
gotten	O
used	O
to	O
it	O
.	O

Edit	O
:	O
if	O
you're	O
using	O
a	O
version	O
of	O
numpy	O
>	O
=	O
1.8.0	O
,	O
then	O
`	O
np.linalg.eigvals	B-API
`	O
operates	O
over	O
the	O
last	O
two	O
dimensions	O
of	O
whatever	O
array	O
you	O
hand	O
it	O
,	O
so	O
if	O
you	O
reshape	O
your	O
input	O
to	O
an	O
`	O
(	O
n_subarrays	O
,	O
nrows	O
,	O
ncols	O
)`	O
array	O
you'll	O
only	O
have	O
to	O
call	O
`	O
eigvals	B-API
`	O
once	O
:	O
#CODE	O

`	O
reshape	B-API
`	O
returns	O
a	O
view	O
of	O
the	O
original	O
array	O
,	O
not	O
a	O
copy	O
,	O
so	O
the	O
conversion	O
to	O
3D	O
only	O
requires	O
altering	O
the	O
`	O
shape	O
`	O
and	O
`	O
strides	O
`	O
attributes	O
of	O
the	O
array	O
,	O
without	O
having	O
to	O
copy	O
any	O
of	O
the	O
actual	O
data	O
.	O

sum	O
this	O
new	O
array	O
along	O
particular	O
axes	O
;	O
and	O
then	O
maybe	O

Calling	O
`	O
reshape	B-API
`	O
returns	O
a	O
view	O
,	O
so	O
it	O
doesn't	O
incur	O
any	O
big	O
copying	O
costs	O
or	O
anything	O
like	O
that	O
.	O

so	O
at	O
some	O
point	O
in	O
the	O
execution	O
it	O
will	O
max	O
my	O
memory	O
.	O

Note	O
that	O
extension	O
to	O
even	O
higher	O
combinatorics	O
should	O
be	O
trivial	O
,	O
along	O
the	O
lines	O
presented	O
;	O
but	O
keep	O
an	O
eye	O
on	O
the	O
n	O
used	O
in	O
that	O
case	O
.	O

These	O
functions	O
return	O
a	O
list	O
,	O
which	O
I	O
convert	O
to	O
a	O
numpy	O
array	O
and	O
then	O
sum	O
over	O
.	O

Can	O
it	O
be	O
because	O
of	O
the	O
many	O
zeros	O
in	O
the	O
initial	O
table	O
?	O

I	O
also	O
understand	O
that	O
sum	B-API
(	O
A	O
,	O
axis=1	O
)	O
will	O
sum	O
each	O
row	O
.	O

But	O
what	O
I	O
really	O
want	O
to	O
do	O
,	O
is	O
to	O
bin	O
`	O
array	O
[:	O
,	O
1	O
]`	O
by	O
day	O
(	O
as	O
derived	O
by	O
the	O
unix	O
timestamps	O
in	O
array	O
[:	O
,	O
0	O
])	O
,	O
and	O
plot	O
these	O
as	O
a	O
stacked	O
histogram	O
,	O
with	O
each	O
(	O
colored	O
)	O
stack	O
representing	O
a	O
day	O
.	O

It's	O
interesting	O
to	O
see	O
that	O
when	O
I	O
go	O
back	O
to	O
`	O
nloop=1000	O
`	O
,	O
`	O
nreps=3	O
`	O
I	O
actually	O
see	O
a	O
slightly	O
*	O
greater	O
*	O
rate	O
of	O
cache	O
misses	O
for	O
the	O
row	O
sum	O
(	O
17%	O
vs	O
13%	O
)	O
,	O
even	O
though	O
it's	O
faster	O
than	O
the	O
column	O
sum	O
.	O

You	O
can	O
concatenate	O
arrays	O
in	O
`	O
numpy	O
`	O
.	O

If	O
you	O
are	O
100%	O
sure	O
that	O
l2	O
would	O
only	O
be	O
one	O
column	O
then	O
you	O
can	O
reshape	O
that	O
array	O
to	O
make	O
it	O
one	O
dimensional	O
before	O
doing	O
the	O
subtraction	O
.	O

You	O
won't	O
be	O
able	O
to	O
create	O
a	O
2D	O
array	O
that	O
way	O
,	O
and	O
@USER	O
method	O
of	O
returning	O
a	O
1D	O
array	O
that	O
you	O
reshape	O
afterwards	O
is	O
a	O
sure	O
go	O
.	O

I	O
have	O
a	O
square	O
matrix	O
A	O
(	O
could	O
be	O
any	O
size	O
)	O
and	O
I	O
want	O
to	O
take	O
the	O
upper	O
triangular	O
part	O
and	O
place	O
those	O
values	O
in	O
an	O
array	O
without	O
the	O
values	O
below	O
the	O
center	O
diagonal	O
(	O
k=0	O
)	O
.	O

You	O
can	O
mimic	O
this	O
behavior	O
with	O
a	O
simple	O
function	O
to	O
flatten	O
a	O
list	O
:	O
#CODE	O

So	O
`	O
popt	O
`	O
,	O
according	O
to	O
the	O
documentation	O
,	O
returns	O
*	O
"	O
Optimal	O
values	O
for	O
the	O
parameters	O
so	O
that	O
the	O
sum	O
of	O
the	O
squared	O
error	O
of	O
f	O
(	O
xdata	O
,	O
popt	O
)	O
-	O
ydata	O
is	O
minimized	O
"	O
.	O

And	O
I'd	O
like	O
indices	O
`	O
i	O
`	O
such	O
that	O
,	O
#CODE	O

But	O
,	O
`	O
resize	B-API
`	O
looks	O
like	O
it	O
just	O
might	O
be	O
the	O
thing	O
I'm	O
looking	O
for	O
...	O

`	O
rfft	B-API
`	O
,	O
apart	O
from	O
repeated	O
terms	O
excluded	O
,	O
and	O
an	O
almost	O
2x	O
speed-up	O
,	O
returns	O
the	O
exact	O
same	O
you	O
would	O
get	O
from	O
`	O
fft	B-API
`	O
.	O

Plus	O
,	O
if	O
I	O
have	O
4	O
dimensions	O
,	O
I	O
thought	O
I	O
should	O
have	O
4	O
eigenvalues	O
and	O
not	O
150	O
like	O
the	O
eig	B-API
gives	O
me	O
.	O

If	O
I	O
run	O
your	O
code	O
to	O
generate	O
`	O
d	O
`	O
and	O
`	O
dx	O
`	O
with	O
`	O
eig	B-API
`	O
I	O
get	O
the	O
following	O
:	O
#CODE	O

In	O
other	O
words-	O
it	O
is	O
not	O
just	O
taking	O
a	O
min	O
or	O
max	O
.	O

D	O
[	O
I+1	O
,	O
J+1	O
]	O
=	O
map	B-API
(	O
norm	O
,	O
x	O
[	O
I	O
]	O
-y	O
[	O
J	O
])	O
+	O
np.minimum	B-API
(	O
np.minimum	B-API
(	O
D	O
[	O
I	O
,	O
J	O
]	O
,	O
D	O
[	O
I	O
,	O
J+1	O
])	O
,	O
D	O
[	O
I+1	O
,	O
J	O
])	O
?	O

`	O
dot	B-API
`	O
just	O
has	O
tighter	O
code	O
for	O
a	O
specific	O
combination	O
of	O
dimensions	O
.	O

numpy	O
sum	B-API
does	O
not	O
agree	O

Since	O
you	O
are	O
only	O
adding	O
many	O
`	O
1	O
`	O
s	O
you	O
can	O
convert	O
`	O
diff	O
`	O
to	O
`	O
bool	O
`	O
:	O
#CODE	O

It	O
isn't	O
mathematically	O
possible	O
to	O
represent	O
0	O
on	O
a	O
log	O
scale	O
,	O
so	O
the	O
first	O
value	O
will	O
have	O
to	O
either	O
be	O
masked	O
or	O
clipped	O
to	O
a	O
very	O
small	O
positive	O
number	O
.	O

possible	O
duplicate	O
of	O
[	O
Efficiently	O
count	O
the	O
number	O
of	O
occurrences	O
of	O
unique	O
subarrays	O
in	O
NumPy	O
?	O
]	O
(	O
#URL	O
)	O

Or	O
you	O
could	O
mask	O
the	O
x	O
value	O
as	O
well	O
,	O
so	O
the	O
indices	O
were	O
consistent	O
between	O
x	O
and	O
y	O
#CODE	O

Here	O
the	O
`	O
outer	B-API
`	O
method	O
of	O
the	O
`	O
multiply	B-API
`	O
ufunc	O
is	O
used	O
to	O
create	O
the	O
new	O
20x20	O
array	O
.	O

I	O
have	O
a	O
3D	O
numpy	O
array	O
consisting	O
of	O
1's	O
and	O
zeros	O
defining	O
open	O
versus	O
filled	O
space	O
in	O
a	O
porous	O
solid	O
(	O
it's	O
currently	O
a	O
numpy	O
Int64	O
array	O
)	O
.	O

You	O
are	O
attempting	O
to	O
broadcast	O
a	O
4-D	O
array	O
together	O
with	O
a	O
3-D	O
array	O
.	O

Scipy	O
NDimage	O
correlate	O
:	O
unbearably	O
slow	O

I	O
know	O
that	O
I	O
can	O
reshape	O
the	O
array	O
to	O
a	O
100	O
x	O
2	O
array	O
of	O
grid	O
points	O
:	O
#CODE	O

You	O
probably	O
could	O
get	O
`	O
append	B-API
`	O
to	O
work	O
,	O
but	O
it	O
just	O
does	O
a	O
step	O
by	O
step	O
concatenate	O
,	O
which	O
is	O
slower	O
.	O

This	O
produces	O
a	O
random	O
permutation	O
of	O
each	O
column's	O
indices	O
.	O

As	O
it	O
happens	O
,	O
the	O
histogram	O
is	O
enough	O
for	O
the	O
former	O
.	O

I	O
see	O
how	O
the	O
symmetry	O
of	O
the	O
trace	O
lets	O
you	O
replace	O
the	O
final	O
`	O
dot	B-API
`	O
.	O

In	O
that	O
question	O
,	O
I	O
sought	O
to	O
sum	O
values	O
in	O
a	O
numpy	O
structured	O
array	O
based	O
on	O
multiple	O
criteria	O
,	O
including	O
matches	O
in	O
a	O
list	O
.	O

to	O
delete	O
the	O
lines	O
that	O
had	O
zeros	O
in	O
them	O
!	O

Fill	O
scipy	O
/	O
numpy	O
matrix	O
based	O
on	O
indices	O
and	O
values	O

It	O
looks	O
like	O
a	O
vector	O
product	O
followed	O
by	O
a	O
sum	O
along	O
the	O
resulting	O
array	O
.	O

The	O
trick	O
is	O
that	O
this	O
convolve	B-API
function	O
can	O
be	O
used	O
in-place	O
so	O
the	O
double	O
for	O
loop	O
:	O
#CODE	O

But	O
this	O
reshape	B-API
should	O
produce	O
a	O
`	O
(	O
n	O
,	O
1	O
,	O
1	O
)`	O
array	O
,	O
not	O
your	O
`	O
(	O
1	O
,	O
1	O
,	O
1	O
,...	O
)`	O
array	O
.	O

For	O
an	O
extreme	O
example	O
,	O
consider	O
a	O
sequence	O
that	O
consists	O
of	O
9	O
zeros	O
followed	O
by	O
the	O
result	O
of	O
a	O
coin	O
toss	O
,	O
9	O
zeros	O
and	O
another	O
coin	O
toss	O
,	O
etc	O
.	O

If	O
so	O
then	O
`	O
np.array	B-API
(	O
a	O
)`	O
is	O
a	O
2d	O
array	O
,	O
and	O
you	O
can	O
sum	O
over	O
`	O
axis=1	O
`	O
.	O

I	O
am	O
trying	O
to	O
create	O
a	O
lat	O
/	O
lon	O
grid	O
that	O
contains	O
an	O
array	O
of	O
found	O
indices	O
where	O
two	O
conditions	O
are	O
met	O
for	O
a	O
lat	O
/	O
lon	O
combination	O
.	O

This	O
NAMBE	O
is	O
the	O
absolute	O
difference	O
between	O
a	O
base	O
vector	O
and	O
another	O
vector	O
,	O
divided	O
by	O
the	O
base	O
vector	O
and	O
multiplied	O
by	O
a	O
hundred	O
,	O
in	O
pseudo-code	O
notation	O
:	O
#CODE	O

this	O
my	O
code	O
to	O
and	O
i	O
want	O
to	O
use	O
histogram	O
data	O
to	O
plot	O
scatter	O
where	O
y	O
axis	O
is	O
counts	O
center	O
from	O
the	O
histogram	O
,	O
is	O
there	O
any	O
direct	O
command	O
or	O
way	O
to	O
do	O
this	O
?	O

Please	O
compile	O
with	O
`	O
cython	O
-a	O
`	O
,	O
then	O
show	O
us	O
the	O
C	O
code	O
that	O
the	O
`	O
a	O
[	O
0	O
]	O
+=	O
sum	O
`	O
line	O
turns	O
into	O
.	O

The	O
revised	O
question	O
is	O
still	O
a	O
duplicate	O
,	O
see	O
[	O
this	O
question	O
]	O
(	O
#URL	O
)	O
,	O
and	O
[	O
this	O
question	O
]	O
(	O
#URL	O
)	O
for	O
finding	O
the	O
indices	O
.	O

ValueError	O
:	O
operands	O
could	O
not	O
be	O
broadcast	O
together	O
with	O
different	O
shapes	O
in	O
numpy	O
?	O

There	O
are	O
thousands	O
of	O
numbers	O
below	O
the	O
ones	O
shown	O
here	O
.	O

Assuming	O
you	O
want	O
to	O
align	O
all	O
the	O
arrays	O
to	O
the	O
left	O
,	O
and	O
pad	O
to	O
the	O
right	O
with	O
zeros	O
,	O
then	O
you	O
could	O
first	O
find	O
the	O
maximum	O
length	O
with	O
#CODE	O

How	O
to	O
do	O
the	O
same	O
If	O
I	O
want	O
to	O
apply	O
norm	O
column-wise	O
to	O
a	O
matrix	O
?	O

The	O
easiest	O
approach	O
is	O
to	O
reshape	O
to	O
data	O
to	O
a	O
long	O
format	O
using	O
`	O
.stack	B-API
`	O
,	O
which	O
can	O
be	O
be	O
passed	O
straight	O
into	O
rolling	O
mean	O
.	O

It's	O
pretty	O
low-level	O
,	O
and	O
mostly	O
focused	O
on	O
how	O
to	O
address	O
the	O
more	O
difficult	O
problem	O
of	O
how	O
to	O
pass	O
C++	O
data	O
to	O
and	O
from	O
NumPy	O
without	O
copying	O
,	O
but	O
here's	O
how	O
you'd	O
do	O
a	O
copied	O
std	O
::	O
vector	O
return	O
with	O
that	O
:	O
#CODE	O

`	O
std	O
=	O
RMS	O
(	O
data	O
-	O
mean	O
)`	O
.	O

This	O
generalized	O
diagonal	O
would	O
be	O
defined	O
as	O
those	O
elements	O
of	O
the	O
array	O
whose	O
0th	O
and	O
2nd	O
index	O
coincide	O
,	O
and	O
would	O
have	O
shape	O
(	O
3	O
,	O
3	O
,	O
7	O
)	O
.	O

I	O
have	O
a	O
given	O
array	O
`	O
[	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
1	O
,	O
1	O
,	O
2	O
,	O
1	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
1	O
,	O
0	O
,	O
1	O
,	O
2	O
,	O
1	O
,	O
0	O
,	O
2	O
,	O
3	O
`]	O
(	O
arbitrary	O
elements	O
from	O
0-5	O
)	O
and	O
I	O
want	O
to	O
have	O
a	O
counter	O
for	O
the	O
occurence	O
of	O
zeros	O
in	O
a	O
row	O
.	O

To	O
see	O
the	O
benefits	O
of	O
this	O
,	O
you	O
need	O
to	O
use	O
`	O
z	O
,	O
p	O
,	O
k	O
=	O
butter	O
(	O
output=	O
'	O
zpk	O
')`	O
and	O
then	O
work	O
with	O
poles	O
and	O
zeros	O
instead	O
of	O
numerator	O
and	O
denominator	O
.	O

In	O
that	O
case	O
you	O
would	O
"	O
extrapolate	O
"	O
zeros	O
to	O
the	O
left	O
and	O
the	O
right	O
.	O

can	O
numpy	O
interpret	O
column	O
of	O
indices	O
like	O
matlab	O
does	O

To	O
get	O
the	O
diagonal	O
elements	O
you	O
can	O
get	O
their	O
indices	O
with	O
`	O
np.triu_indices	B-API
`	O
(	O
or	O
,	O
for	O
the	O
lower	O
triangle	O
,	O
`	O
np.tril_indices	B-API
`)	O
and	O
then	O
index	O
by	O
them	O
.	O

The	O
question	O
states	O
that	O
the	O
input	O
array	O
is	O
of	O
shape	O
`	O
(	O
128	O
,	O
36	O
,	O
8)	O
`	O
and	O
we	O
are	O
interested	O
in	O
finding	O
unique	O
subarrays	O
of	O
length	O
`	O
8	O
`	O
in	O
the	O
last	O
dimension	O
.	O

What	O
does	O
work	O
,	O
however	O
is	O
nesting	O
append	B-API
and	O
concatenate	B-API
#CODE	O

(	O
`	O
b	O
`	O
will	O
be	O
broadcast	O
along	O
(	O
?	O
)	O
the	O
first	O
axis	O
)	O
#CODE	O

As	O
he	O
points	O
out	O
,	O
the	O
`	O
[	O
0	O
]	O
[	O
1	O
]`	O
element	O
is	O
what	O
you'd	O
want	O
for	O
`	O
cov	B-API
(	O
a	O
,	O
b	O
)`	O
.	O

returns	O
`	O
1	O
`	O
,	O
making	O
the	O
sum	O
not	O
commutative	O
!	O

But	O
as	O
I	O
have	O
a	O
log	O
of	O
values	O
(	O
10000+	O
)	O
,	O
this	O
will	O
be	O
quite	O
slow	O
.	O

@USER	O
-	O
good	O
point	O
.	O
anyway	O
,	O
`	O
diff	B-API
`	O
works	O
on	O
python	O
lists	O
too	O
.	O

It	O
will	O
also	O
work	O
if	O
they	O
are	O
both	O
arrays	O
that	O
can	O
be	O
broadcast	O
.	O

It's	O
column	O
stack	O
that	O
requires	O
equal	O
length	O
strings	O
.	O

In	O
the	O
end	O
it	O
is	O
usually	O
not	O
too	O
complicated	O
,	O
especially	O
if	O
you	O
use	O
[	O
`	O
mgrid	B-API
`]	O
(	O
#URL	O
)	O
or	O
similar	O
to	O
get	O
the	O
indices	O
.	O

The	O
absolute	O
error	O
will	O
be	O
at	O
most	O
1	O
/	O
2	O
ULP	O
,	O
2	O
-150	O
.	O

AttributeError	O
:	O
'	O
Add	O
'	O
object	O
has	O
no	O
attribute	O
'	O
log	O
'	O
Python	O

Or	O
,	O
you	O
could	O
initialize	O
an	O
array	O
of	O
all	O
zeros	O
if	O
you	O
know	O
the	O
size	O
of	O
the	O
array	O
ahead	O
of	O
time	O
.	O

Are	O
you	O
checking	O
shape	O
or	O
number	O
of	O
nonzero	O
values	O
?	O

Something	O
like	O
`	O
eigvals	O
,	O
eigvecs	O
=	O
la.eigh	O
(	O
mat	B-API
)`	O
`	O
principal	O
=	O
eigvecs	O
[:	O
,	O
eigvals.argmax()	O
]`	O
`	O
if	O
(	O
principal	O
>	O
=	O
0	O
)	O
.all()	O
or	O
(	O
pricipal	O
<=	O
0	O
)	O
.all()	O
:	O
print	O
'	O
all	O
the	O
same	O
'`	O
?	O

I	O
also	O
want	O
bins	O
to	O
have	O
a	O
width	O
of	O
.5	O
so	O
that	O
I	O
can	O
have	O
a	O
bin	O
from	O
10.5	O
to	O
11	O
or	O
24	O
to	O
24.5	O
etc	O
...	O
because	O
otherwise	O
,	O
python	O
outputs	O
the	O
histogram	O
with	O
the	O
bins	O
random	O
and	O
undetermined	O
.	O

Maximum	O
is	O
always	O
bigger	O
than	O
the	O
minimum	O
(	O
more	O
to	O
the	O
right	O
on	O
a	O
1d	O
axis	O
,	O
not	O
by	O
absolute	O
value	O
)	O
.	O

should	O
give	O
the	O
sum	O
of	O
the	O
columns	O
.	O

Suppose	O
,	O
You	O
wanna	O
check	O
how	O
many	O
times	O
you	O
will	O
get	O
six	O
if	O
you	O
roll	O
dice	O
10	O
times	O
.	O

With	O
this	O
option	O
,	O
the	O
result	O
will	O
broadcast	O
correctly	O

Do	O
you	O
mean	O
`	O
indices	O
=	O
np.where	B-API
(	O
a	O
==	O
a.max()	O
)`	O
in	O
line	O
3	O
?	O

The	O
problem	O
I	O
have	O
much	O
later	O
on	O
in	O
the	O
code	O
is	O
that	O
if	O
one	O
of	O
these	O
parameters	O
isn't	O
in	O
the	O
ASCII	O
file	O
it	O
throws	O
errors	O
up	O
so	O
I	O
have	O
to	O
keep	O
adding	O
in	O
ones	O
I	O
don't	O
need	O
.	O

`	O
append	B-API
`	O
adds	O
them	O
to	O
the	O
end	O
of	O
the	O
list	O
,	O
which	O
is	O
exactly	O
what	O
you	O
want	O
.	O

I	O
have	O
two	O
3dim	O
numpy	O
matrices	O
and	O
I	O
want	O
to	O
do	O
a	O
dot	O
product	O
according	O
to	O
one	O
axis	O
without	O
using	O
a	O
loop	O
in	O
theano	O
.	O

you	O
have	O
at	O
most	O
4	O
in	O
that	O
dimension	O
(	O
see	O
your	O
reshape	O
line	O
)	O
,	O
so	O
the	O
index	O
it	O
will	O
count	O
are	O
0	O
and	O
2	O
(	O
1	O
and	O
3	O
are	O
skipped	O
,	O
and	O
3	O
is	O
the	O
last	O
element	O
)	O
.	O

Once	O
we	O
have	O
the	O
indices	O
to	O
sort	O
`	O
data	O
`	O
,	O
to	O
get	O
a	O
sorted	O
copy	O
of	O
the	O
array	O
it	O
is	O
faster	O
to	O
use	O
the	O
indices	O
than	O
to	O
re-sort	O
the	O
array	O
:	O
#CODE	O

I	O
hope	O
this	O
will	O
help	O
you	O
perform	O
your	O
transpose	O
and	O
column-wise	O
operations	O

It	O
is	O
better	O
to	O
specify	O
that	O
I'm	O
looking	O
for	O
something	O
that	O
performs	O
the	O
log-sum-exp	O
trick	O
,	O
doing	O
a	O
simply	O
succession	O
of	O
exp	O
elem-wise	O
,	O
summing	O
the	O
rows	O
and	O
doing	O
a	O
log	O
elem-wise	O
is	O
trivial	O
in	O
`	O
scipy.sparse	O
`	O
.	O

Scipy	O
uses	O
`	O
int32	O
`	O
to	O
store	O
`	O
indptr	O
`	O
and	O
`	O
indices	O
`	O
for	O
the	O
sparse	O
formats	O
.	O

But	O
not	O
able	O
to	O
plot	O
it	O
as	O
a	O
graph	O
(	O
something	O
like	O
a	O
histogram	O
)	O
...	O
that	O
is	O
the	O
problem	O
.	O

It	O
gave	O
error	O
testing	O
doesnot	O
have	O
attribute	O
append	O
as	O
its	O
of	O
None	O
Type	O
.	O

In	O
both	O
cases	O
,	O
you	O
can	O
access	O
individual	O
elements	O
by	O
indices	O
,	O
like	O
`	O
R	O
[	O
0	O
]`	O
(	O
which	O
would	O
give	O
you	O
a	O
specific	O
object	O
,	O
a	O
`	O
np.void	O
`	O
,	O
that	O
still	O
gives	O
you	O
the	O
possibility	O
to	O
access	O
the	O
fields	O
separately	O
)	O
,	O
or	O
by	O
slices	O
`	O
R	O
[	O
1	O
:	O
-1	O
]`	O
...	O

I	O
think	O
you	O
can	O
have	O
a	O
sum	O
over	O
a	O
sliding	O
window	O
(	O
or	O
a	O
rolling	O
window	O
)	O
or	O
a	O
mean	O
over	O
a	O
sliding	O
window	O
.	O

I	O
got	O
your	O
point	O
and	O
I	O
find	O
it	O
more	O
logical	O
,	O
but	O
when	O
trying	O
the	O
code	O
you've	O
suggested	O
to	O
get	O
rid	O
of	O
the	O
second	O
error	O
I	O
got	O
another	O
error	O
:	O
`	O
AttributeError	O
:	O
flatten	B-API
`	O

`	O
dot	B-API
`	O
does	O
many	O
things	O
under	O
the	O
hood	O
,	O
it	O
is	O
apparent	O
that	O
`	O
np.dot	B-API
(	O
A	O
,	O
x	O
)`	O
is	O
not	O
calling	O
BLAS	O
and	O
is	O
somehow	O
defaulting	O
over	O
to	O
numpy's	O
internal	O
GEMM	O
routine	O
.	O

Below	O
is	O
some	O
code	O
which	O
uses	O
a	O
callback	O
to	O
print	O
out	O
the	O
current	O
azimuthal	O
and	O
elevation	O
angles	O
,	O
as	O
well	O
as	O
append	O
them	O
to	O
a	O
list	O
for	O
further	O
use	O
later	O
.	O

It's	O
super	O
alex	O
,	O
here	O
to	O
answer	O
NumPy	O
questions	O
in	O
the	O
blink	O
of	O
an	O
eye	O
:)	O

Your	O
solution	O
of	O
searching	O
the	O
eigenvalues	O
for	O
the	O
ones	O
you	O
want	O
seems	O
plausible	O
enough	O
.	O

If	O
d	O
is	O
larger	O
than	O
8	O
or	O
9	O
,	O
then	O
bases	O
will	O
be	O
sufficiently	O
long	O
that	O
you	O
probably	O
would	O
be	O
better	O
off	O
going	O
with	O
the	O
other	O
version	O
using	O
the	O
dot	O
product	O
.	O

I'm	O
not	O
sure	O
which	O
indices	O
i	O
need	O
to	O
change	O
to	O
achieve	O
the	O
minimum	O
and	O
not	O
the	O
maximum	O
values	O
.	O

The	O
dimension	O
of	O
`	O
result	O
`	O
has	O
been	O
set	O
earlier	O
to	O
the	O
correct	O
dimension	O
,	O
so	O
can	O
check	O
it	O
,	O
but	O
it	O
would	O
be	O
nice	O
to	O
only	O
use	O
the	O
length	O
of	O
`	O
indices	O
`	O
to	O
determine	O
it	O
.	O

Alternatively	O
,	O
what	O
about	O
applying	O
the	O
same	O
function	O
without	O
indices	O
along	O
the	O
depth	O
axes	O
?	O

Here's	O
an	O
O	O
(	O
n	O
log	O
n	O
)	O
algorithm	O
for	O
your	O
problem	O
.	O

You	O
need	O
to	O
add	O
axes	O
to	O
`	O
coeffs	O
`	O
so	O
it	O
will	O
broadcast	O
in	O
the	O
dimension	O
(	O
s	O
)	O
you	O
want	O
.	O

If	O
you	O
want	O
to	O
search	O
for	O
a	O
certain	O
rank	O
on	O
B	O
randomly	O
,	O
you	O
need	O
to	O
start	O
off	O
with	O
a	O
valid	O
B	O
with	O
max	O
rank	O
,	O
and	O
rotate	O
a	O
random	O
column	O
j	O
of	O
a	O
random	O
B	O
i	O
by	O
a	O
random	O
amount	O
.	O

I	O
want	O
to	O
save	O
some	O
histogram	O
data	O
in	O
a	O
csv	O
file	O
.	O

I	O
want	O
to	O
read	O
a	O
mat	O
file	O
back	O
in	O
python	O
but	O
I	O
have	O
trouble	O
going	O
back	O
to	O
a	O
graph	O
,	O
because	O
the	O
mat	O
file	O
gives	O
a	O
numpy.ndarray	B-API
type	O
file	O
and	O
I	O
need	O
a	O
sparse	O
matrix	O
to	O
reconstruct	O
my	O
graph	O
.	O

numpy	O
makes	O
it	O
easy	O
to	O
translate	O
python	O
objects	O
into	O
numpy	O
ndarrays	O
,	O
and	O
will	O
even	O
pick	O
an	O
appropriate	O
resulting	O
data	O
type	O
if	O
one	O
is	O
not	O
specified	O
:	O
#CODE	O

This	O
`	O
T	O
`	O
and	O
`	O
X	O
`	O
broadcast	O
together	O
just	O
fine	O
,	O
for	O
example	O
`	O
T*X	O
`	O
works	O
.	O

I	O
have	O
a	O
numpy	O
matrix	O
A	O
and	O
I	O
need	O
a	O
function	O
that	O
will	O
count	O
(	O
A	O
[	O
i	O
,	O
j	O
]	O
/	O
sum	O
of	O
all	O
elements	O
in	O
i-th	O
column	O
)	O
-	O
A	O
[	O
i	O
,	O
j	O
]	O
/	O
sum	O
of	O
all	O
elements	O
in	O
j-th	O
row	O

This	O
also	O
works	O
if	O
,	O
instead	O
of	O
a	O
single	O
index	O
,	O
you	O
provide	O
an	O
array	O
of	O
indices	O
:	O
#CODE	O

How	O
to	O
solve	O
nonlinear	O
equation	O
without	O
sympy	O
(	O
max	O
and	O
min	O
)	O
?	O

Bivariate	O
Legendre	O
Polynomial	O
Fitting	O
to	O
find	O
orthogonal	O
coefficents	O

I	O
have	O
a	O
big	O
n-square	O
diagonal	O
matrix	O
,	O
in	O
the	O
scipy's	O
sparse	O
DIA	O
format	O

To	O
find	O
the	O
most	O
frequent	O
value	O
of	O
a	O
flat	O
array	O
,	O
use	O
`	O
unique	B-API
`	O
,	O
`	O
bincount	B-API
`	O
and	O
`	O
argmax	B-API
`	O
:	O
#CODE	O

The	O
funny	O
thing	O
is	O
in	O
the	O
above	O
function	O
If	O
i	O
pass	O
an	O
extra	O
argument	O
and	O
just	O
divide	O
sum	O
by	O
it	O
,	O
then	O
the	O
times	O
are	O
the	O
same	O
again	O
.	O

are	O
the	O
same	O
as	O
the	O
ones	O
posted	O
in	O
the	O
examples	O
of	O
this	O
web	O
page	O
.	O

How	O
to	O
remove	O
rings	O
from	O
convolve	O
healpix	O
map	O
?	O

With	O
the	O
information	O
of	O
the	O
full	O
stack	O
trace	O
report	O
the	O
bug	O
to	O
the	O
ubuntu	O
team	O
.	O

fastest	O
way	O
to	O
get	O
lookup	O
table	O
indices	O
with	O
numpy	O

Well	O
,	O
a	O
few	O
more	O
,	O
anyway	O
:	O
`	O
cos	B-API
`	O
,	O
`	O
pi	B-API
`	O
,	O
`	O
diag	B-API
`	O

I	O
implemented	O
a	O
LOWESS	O
smoother	O
(	O
which	O
is	O
the	O
curve	O
you	O
see	O
)	O
with	O
a	O
tight	O
fit	O
to	O
eliminate	O
noise	O
,	O
since	O
the	O
real	O
waveforms	O
have	O
a	O
non-trivial	O
noise	O
component	O
,	O
and	O
then	O
tried	O
doing	O
a	O
rolling	O
max	O
with	O
a	O
window	O
over	O
the	O
data	O
,	O
but	O
I	O
can't	O
get	O
anything	O
solid	O
.	O

But	O
sum	B-API
function	O
from	O
numpy	O
doesn't	O
suport	O
"	O
1:3	O
"	O

(	O
the	O
`	O
np.nonzero	B-API
`	O
should	O
return	O
a	O
tuple	O
with	O
one	O
element	O
,	O
an	O
array	O
of	O
indices	O
)	O
.	O

Can	O
the	O
"	O
small	O
values	O
of	O
derivative	O
"	O
be	O
small	O
with	O
respect	O
to	O
the	O
sin	O
curve	O
?	O

6	O
columns	O
,	O
92370574	O
rows	O
,	O
2496502	O
locations	O
,	O
37	O
months	O
each	O
,	O
unique	O
amounts	O
for	O
each	O
value	O
.	O

Note	O
that	O
where	O
possible	O
,	O
`	O
reshape	B-API
`	O
will	O
give	O
you	O
a	O
view	O
of	O
the	O
array	O
.	O

Here	O
you	O
append	O
only	O
a	O
REFERENCE	O
to	O
your	O
only	O
one	O
existing	O
`	O
energy	O
`	O
array	O
.	O

And	O
you	O
can	O
combine	O
the	O
summation	O
and	O
multiplication	O
into	O
a	O
dot	O
product	O
:	O
#CODE	O

For	O
example	O
,	O
`	O
a	O
`	O
is	O
generated	O
from	O
`	O
a	O
=	O
z	O
[	O
z	O
!	O
=0	O
]`	O
;	O
`	O
a	O
`	O
then	O
changes	O
through	O
some	O
processing	O
,	O
and	O
now	O
I	O
need	O
to	O
insert	O
`	O
nan	O
`	O
s	O
where	O
there	O
were	O
originally	O
zeros	O
.	O

I	O
frequently	O
use	O
the	O
numpy.where	B-API
function	O
to	O
gather	O
a	O
tuple	O
of	O
indices	O
of	O
a	O
matrix	O
having	O
some	O
property	O
.	O

I	O
suspect	O
the	O
original	O
formula	O
was	O
right	O
but	O
you	O
didn't	O
encode	O
it	O
right	O
in	O
Python	O
.	O

This	O
gets	O
me	O
the	O
sum	O
of	O
all	O
red	O
combined	O
in	O
original	O
-	O
all	O
red	O
combined	O
in	O
mutated	O
.	O

`	O
p2	O
=	O
einsum	B-API
(	O
'	O
nk	O
,	O
nk	O
->	O
n	O
'	O
,	O
p1	O
,	O
delta	O
)`	O
is	O
the	O
pairwise	O
dot	O
product	O
of	O
the	O
rows	O
of	O
`	O
p1	O
`	O
and	O
`	O
delta	O
`	O
.	O

I	O
did	O
the	O
reshape	B-API
,	O
just	O
so	O
that	O
both	O
arrays	O
are	O
same	O
shape	O
,	O
but	O
I	O
do	O
not	O
think	O
you	O
really	O
need	O
the	O
reshaping	O
,	O
with	O
the	O
list	O
comprehension	O
the	O
shape	O
of	O
array	O
you	O
get	O
is	O
`	O
(	O
length	O
of	O
string	O
,	O
)`	O

Also	O
,	O
I	O
expect	O
the	O
positions	O
of	O
the	O
zeros	O
to	O
be	O
relatively	O
sparse	O
(	O
~1%	O
of	O
all	O
bit	O
positions	O
)	O
.	O

Slicing	O
arrays	O
with	O
meshgrid	B-API
/	O
array	O
indices	O
in	O
Numpy	O

(	O
An	O
nonzero	O
exit	O
status	O
usually	O
indicates	O
an	O
error	O
on	O
Unix	O
style	O
systems	O
.	O
A	O
couple	O
programs	O
are	O
different	O
,	O
e.g.	O
,	O
`	O
diff	B-API
`	O
.	O
)	O
Try	O
examining	O
the	O
`	O
stderr	O
`	O
produced	O
by	O
the	O
subprocess	O
to	O
see	O
what	O
error	O
messages	O
are	O
printed	O
there	O
.	O

To	O
achieve	O
exactly	O
what	O
you	O
are	O
asking	O
for	O
I	O
would	O
apply	O
a	O
`	O
[	O
3x3	O
]`	O
box-filter	O
on	O
the	O
image	O
and	O
than	O
I	O
would	O
resize	O
the	O
matrix	O
using	O
nearest	O
neighbor	O
interpolation	O
.	O

Is	O
there	O
a	O
quick	O
way	O
to	O
reshape	O
my	O
`	O
csr_matrix	O
`	O
without	O
copying	O
everything	O
in	O
it	O
?	O

The	O
catch	O
is	O
that	O
I	O
need	O
to	O
keep	O
the	O
colors	O
exactly	O
the	O
way	O
they	O
are	O
(	O
background	O
:	O
I'm	O
resizing	O
a	O
map	O
where	O
provinces	O
are	O
color-coded	O
)	O
,	O
and	O
so	O
I	O
cannot	O
just	O
perform	O
a	O
resize	O
with	O
bicubic	O
interpolation	O
,	O
because	O
that	O
will	O
also	O
interpolate	O
the	O
pixel	O
colors	O
while	O
smoothing	O
.	O

You	O
should	O
"	O
flatten	O
"	O
the	O
array	O
of	O
arrays	O
first	O
.	O
unfortunately	O
,	O
there's	O
no	O
builtin	O
method	O
,	O
see	O
#URL	O

then	O
concatenate	O
the	O
saved	O
objects	O
whit	O
this	O
code	O
:	O
#CODE	O

For	O
something	O
like	O
a	O
dot	O
product	O
,	O
pandas	O
`	O
DataFrames	O
`	O
are	O
generally	O
going	O
to	O
be	O
slower	O
than	O
a	O
numpy	O
array	O
since	O
pandas	O
is	O
doing	O
**	O
a	O
lot	O
more	O
stuff	O
**	O
aligning	O
labels	O
,	O
potentially	O
dealing	O
with	O
heterogenous	O
types	O
,	O
and	O
so	O
on	O
.	O

I	O
want	O
to	O
pass	O
an	O
array	O
of	O
indices	O
and	O
column	O
names	O
and	O
get	O
a	O
list	O
of	O
objects	O
that	O
are	O
found	O
in	O
the	O
corresponding	O
index	O
and	O
column	O
name	O
.	O

From	O
this	O
you	O
would	O
expect	O
the	O
total	O
sum	O
to	O
be	O
`	O
100,679,697	O
=	O
200*	O
(	O
1,000,000	O
-	O
499,097	O
)	O
+	O
499,097	O
`	O

The	O
histogram	O
way	O
is	O
not	O
the	O
fastest	O
,	O
and	O
can't	O
tell	O
the	O
difference	O
between	O
an	O
arbitrarily	O
small	O
separation	O
of	O
points	O
and	O
`	O
2	O
*	O
sqrt	B-API
(	O
2	O
)	O
*	O
b	O
`	O
(	O
where	O
`	O
b	O
`	O
is	O
bin	O
width	O
)	O
.	O

}	O
for	O
n=1	O
,	O
2	O
,	O
3	O
,	O
4	O
,	O
5	O
,	O
6	O
(	O
using	O
Sum	B-API
(	O
c_n	O
exp	B-API
(	O
i	O
2	O
pi	O
n	O
x	O
)	O
)	O
as	O
Fourier	O
series	O
)	O
.	O

I	O
think	O
I	O
can	O
t	O
just	O
simple	O
sum	O
the	O
"	O
seq	O
*	O
"	O
array	O
,	O
because	O
instead	O
of	O
a	O
chord	O
I	O
will	O
get	O
noise	O
.	O

I	O
presume	O
you	O
want	O
to	O
transpose	O
first	O
:	O
#CODE	O

Oh	O
,	O
that's	O
interesting	O
you	O
can	O
do	O
it	O
with	O
stack	B-API
.	O

In	O
this	O
case	O
,	O
using	O
numpy	O
outer	B-API
operations	O
allow	O
you	O
to	O
compute	O
the	O
multiplications	O
and	O
sums	O
at	O
the	O
`	O
C	O
`	O
loop	O
speed	O
.	O

The	O
most	O
efficient	O
way	O
is	O
likely	O
to	O
use	O
'	O
np.empty()	B-API
'	O
to	O
allocate	O
the	O
space	O
/	O
memory	O
for	O
your	O
end	O
dataset	O
and	O
then	O
load	O
data	O
&	O
broadcast	O
within	O
that	O
using	O
slice	O
indexing	O
.	O

Ok	O
,	O
with	O
your	O
histogram	O
I	O
get	O
at	O
least	O
the	O
total	O
number	O
of	O
each	O
pair	O
.	O

This	O
is	O
because	O
python's	O
sum	O
is	O
basically	O
summing	O
a	O
for	O
loop	O
over	O
the	O
object	O
.	O

Then	O
the	O
entire	O
shape	O
changes	O
from	O
(	O
x	O
,	O
y	O
)	O
to	O
merely	O
(	O
x	O
,	O
)	O
and	O
I	O
get	O
'	O
too	O
many	O
indices	O
'	O
errors	O
when	O
I	O
try	O
to	O
use	O
masks	O
.	O

If	O
reps	O
has	O
length	O
d	O
,	O
the	O
result	O
will	O
have	O
dimension	O
of	O
max	B-API
(	O
d	O
,	O
A.ndim	O
)	O
.	O

I	O
want	O
to	O
do	O
this	O
by	O
dividing	O
each	O
histogram	O
by	O
its	O
maximum	O
value	O
so	O
all	O
the	O
distributions	O
have	O
the	O
same	O
scale	O
.	O

An	O
obvious	O
path	O
would	O
be	O
to	O
transpose	O
the	O
array	O
so	O
that	O
the	O
indices	O
that	O
I	O
am	O
selecting	O
would	O
come	O
up	O
first	O
.	O

Now	O
,	O
for	O
mean	O
calculations	O
,	O
those	O
numeric	O
IDs	O
could	O
be	O
used	O
as	O
`"	O
weights	O
"`	O
for	O
binning	O
with	O
`	O
np.bincount	B-API
`	O
,	O
giving	O
us	O
the	O
sum	O
of	O
data	O
elements	O
corresponding	O
to	O
each	O
`	O
ID	O
`	O
.	O

However	O
,	O
what	O
I	O
need	O
is	O
a	O
string	O
containing	O
all	O
the	O
elements	O
in	O
the	O
list	O
linked	O
by	O
'	O
;	O
'	O
,	O
not	O
the	O
list	O
itself	O
,	O
so	O
it	O
seems	O
like	O
I	O
have	O
to	O
sum	O
all	O
the	O
elements	O
in	O
asString	O
with	O
another	O
iteration	O
?	O

the	O
output	O
I	O
need	O
:	O
`	O
S	O
=	O
[	O
2	O
,	O
5	O
,	O
8	O
,	O
11	O
,	O
14	O
]`	O
I	O
thought	O
something	O
like	O
:	O
`	O
S1	O
=	O
np.array	B-API
(	O
L	O
[:	O
]	O
[	O
1	O
,	O
0	O
])`	O
should	O
work	O
but	O
whatever	O
I	O
try	O
I	O
have	O
the	O
error	O
like	O
:	O
`	O
TypeError	O
:	O
list	O
indices	O
must	O
be	O
integers	O
,	O
not	O
tuple	O
`	O
.	O

I	O
need	O
it	O
because	O
in	O
the	O
next	O
part	O
I	O
will	O
sum	O
up	O
this	O
large	O
np.array	B-API
with	O
some	O
delta_array	O
that	O
has	O
the	O
same	O
shape	O
.	O

Used	O
reshape	B-API
to	O
make	O
rows	O
into	O
columns	O
.	O

I	O
understand	O
that	O
you	O
could	O
create	O
an	O
array	O
of	O
zeros	O
and	O
iteratively	O
change	O
the	O
values	O
in	O
each	O
column	O
,	O
but	O
I	O
also	O
understand	O
this	O
is	O
not	O
an	O
efficient	O
method	O
.	O

I'm	O
trying	O
to	O
implement	O
the	O
univariate	O
gradient	O
descent	O
algorithm	O
in	O
python	O
.	O

numpy	O
glossary	O
says	O
the	O
sum	O
along	O
axis	O
argument	O
`	O
axis=1	O
`	O
sums	O
over	O
rows	O
:	O
"	O
we	O
can	O
sum	O
each	O
row	O
of	O
an	O
array	O
,	O
in	O
which	O
case	O
we	O
operate	O
along	O
columns	O
,	O
or	O
axis	O
1	O
"	O
.	O

It	O
also	O
prints	O
out	O
the	O
new	O
indices	O
signature	O
.	O

At	O
first	O
,	O
your	O
`	O
result	O
`	O
does	O
not	O
look	O
like	O
a	O
complex	O
FFT	O
output	O

debug	O
performance	O
diff	O
of	O
Same	O
code	O
on	O
nearly	O
same	O
cpu	O
/	O
ram	O

The	O
HTML	O
file	O
generated	O
by	O
Cython	O
indicates	O
that	O
the	O
bottleneck	O
is	O
the	O
dot	O
products	O
(	O
which	O
is	O
expected	O
of	O
course	O
)	O
.	O

`	O
numpy.unique	B-API
`	O
with	O
`	O
return_index=True	O
`	O
will	O
give	O
you	O
a	O
list	O
of	O
indices	O
to	O
take	O
from	O
.	O

I	O
forgot	O
exactly	O
why	O
,	O
but	O
there	O
is	O
a	O
good	O
reason	O
why	O
you	O
calculate	O
it	O
as	O
the	O
ratio	O
between	O
these	O
two	O
averages	O
,	O
instead	O
of	O
directly	O
averaging	O
`	O
fft	B-API
(	O
y	O
)	O
/	O
fft	B-API
(	O
x	O
)`	O
.	O

Do	O
you	O
really	O
want	O
this	O
'	O
roll	B-API
'	O
?	O

By	O
adding	O
a	O
nonzero	O
number	O
at	O
the	O
end	O
of	O
the	O
array	O
,	O
you	O
can	O
still	O
use	O
np.nonzero	B-API
to	O
get	O
your	O
desired	O
outcome	O
.	O

which	O
simply	O
sorts	O
the	O
terms	O
and	O
then	O
takes	O
the	O
ones	O
which	O
aren't	O
equal	O
to	O
the	O
previous	O
one	O
.	O

4	O
:	O
I	O
am	O
not	O
sure	O
about	O
the	O
indices	O
,	O
by	O
writing	O
couple	O
of	O
code	O
lines	O
I	O
just	O
able	O
to	O
get	O
cluster	O
indices	O
based	O
on	O
fclusterdata	O
.	O

Matlab	O
gives	O
me	O
a	O
norm	O
=	O
2	O
for	O
your	O
matrix	O
.	O

I	O
first	O
generated	O
a	O
labelled	O
array	O
of	O
unique	O
IDs	O
for	O
each	O
discrete	O
region	O
,	O
calculated	O
sizes	O
for	O
each	O
ID	O
,	O
masked	O
the	O
size	O
array	O
to	O
focus	O
only	O
on	O
size	O
==	O
1	O
blobs	O
,	O
then	O
index	O
the	O
original	O
array	O
and	O
set	O
IDs	O
with	O
a	O
size	O
==	O
1	O
to	O
0	O
:	O
#CODE	O

absolute	B-API
(	O
a	O
-	O
b	O
)	O
=	O
(	O
atol	O
+	O
rtol	O
*	O
absolute	B-API
(	O
b	O
))	O

Then	O
I	O
reshape	O
this	O
to	O
form	O
a	O
2D	O
numpy	O
array	O
.	O

n=5	O
(	O
min	O
length	O
of	O
sequence	O
)	O

I	O
have	O
written	O
a	O
function	O
which	O
contains	O
nested	O
loops	O
and	O
a	O
conditional	O
statement	O
;	O
the	O
purpose	O
of	O
the	O
loop	O
is	O
to	O
return	O
a	O
list	O
of	O
indices	O
for	O
the	O
nearest	O
elements	O
in	O
array	O
x	O
when	O
compared	O
to	O
array	O
y	O
.	O

I	O
also	O
want	O
to	O
color	O
the	O
1D	O
histogram	O
bars	O
according	O
to	O
the	O
same	O
normalization	O
.	O

If	O
you	O
are	O
calling	O
it	O
with	O
an	O
empty	O
matrix	O
for	O
[	O
low	O
,	O
high	O
]	O
it	O
will	O
just	O
use	O
whatever	O
the	O
max	O
and	O
min	O
values	O
in	O
the	O
array	O
are	O
.	O

Creating	O
a	O
class	O
deriving	O
from	O
`	O
ndarray	B-API
`	O
and	O
overriding	O
indexing	O
such	O
that	O
the	O
absolute	O
indices	O
are	O
used	O
.	O

One	O
solution	O
is	O
to	O
sort	O
both	O
arrays	O
(	O
adding	O
an	O
index	O
column	O
so	O
that	O
the	O
sorted	O
arrays	O
still	O
contains	O
the	O
original	O
indices	O
)	O
.	O

Use	O
`	O
reshape	B-API
`	O
:	O
#CODE	O

What's	O
wrong	O
with	O
the	O
normal	O
div	O
/	O
mod	O
operations	O
?	O

You	O
can	O
use	O
`	O
argmin	B-API
`	O
to	O
find	O
the	O
False	O
values	O
,	O
and	O
this	O
will	O
be	O
faster	O
and	O
take	O
less	O
memory	O
than	O
using	O
nonzero	B-API
,	O
but	O
this	O
is	O
linear	O
in	O
the	O
length	O
of	O
`	O
a	O
`	O
.	O

I'd	O
like	O
it	O
to	O
be	O
like	O
8x10^8	O
or	O
.8x10	O
^9	O
to	O
save	O
space	O
instead	O
of	O
putting	O
all	O
those	O
zeros	O
.	O

The	O
one	O
I	O
pointed	O
out	O
in	O
a	O
comment	O
to	O
other	O
answer	O
as	O
to	O
encode	O
the	O
binary	O
representation	O
of	O
the	O
array	O
as	O
a	O
Base64	O
text	O
block	O
.	O

due	O
to	O
broadcasting	O
,	O
you	O
don't	O
need	O
to	O
repeat	O
duplicate	O
indices	O
,	O
thus	O
:	O
#CODE	O

Maybe	O
`	O
flatten()	B-API
`	O
the	O
original	O
array	O
,	O
then	O
use	O
your	O
1D	O
solution	O
,	O
finally	O
calculate	O
the	O
real	O
nD	O
indices	O
using	O
the	O
original	O
shape	O
?	O

Note	O
that	O
the	O
diagonal	O
is	O
always	O
zero	O
since	O
`	O
mahalanobis	O
(	O
x	O
,	O
x	O
)`	O
equals	O
zero	O
for	O

possible	O
duplicate	O
of	O
[	O
NumPy	O
min	B-API
/	O
max	B-API
in-place	O
assignment	O
]	O
(	O
#URL	O
)	O

Once	O
the	O
tree	O
structure	O
has	O
been	O
built	O
,	O
go	O
back	O
and	O
collect	O
all	O
the	O
branches	O
and	O
leaves	O
into	O
the	O
array	O
structure	O
and	O
by	O
definition	O
,	O
they	O
will	O
be	O
unique	O
.	O

I	O
wrote	O
the	O
following	O
code	O
but	O
the	O
output	O
only	O
contains	O
the	O
ids	O
(	O
single	O
column	O
)	O
.	O

Maximum	O
is	O
always	O
bigger	O
than	O
the	O
minimum	O
(	O
more	O
to	O
the	O
right	O
on	O
a	O
1d	O
axis	O
,	O
not	O
by	O
absolute	O
value	O
)	O
.	O

Note	O
that	O
`	O
unq_count	O
`	O
doesn't	O
count	O
the	O
occurrences	O
of	O
the	O
last	O
unique	O
item	O
,	O
because	O
that	O
is	O
not	O
needed	O
to	O
split	O
the	O
index	O
array	O
.	O

If	O
yes	O
,	O
you	O
can	O
use	O
the	O
Linux	O
terminal	O
to	O
strip	O
quotes	O
from	O
the	O
ends	O
of	O
the	O
rows	O
quickly	O
.	O

The	O
append	B-API
method	O
for	O
a	O
numpy	O
array	O
returns	O
a	O
copy	O
of	O
the	O
array	O
with	O
new	O
items	O
added	O
to	O
the	O
end	O
.	O

I	O
want	O
to	O
get	O
the	O
norm	B-API
of	O
this	O
array	O
using	O
numpy	O
.	O

The	O
only	O
problem	O
here	O
is	O
that	O
I	O
think	O
it	O
will	O
append	O
directly	O
to	O
the	O
column	O
,	O
when	O
I	O
would	O
prefer	O
it	O
to	O
append	O
to	O
a	O
new	O
column	O
.	O

You	O
don't	O
need	O
to	O
import	O
string	O
,	O
and	O
you	O
don't	O
need	O
to	O
loop	O
through	O
all	O
the	O
lines	O
and	O
append	O
text	O
or	O
count	O
the	O
characters	O
.	O

The	O
transpose	O
of	O
the	O
transpose	O
of	O
a	O
matrix	O
==	O
that	O
matrix	O
,	O
or	O
,	O
[	O
A^T	O
]	O
^T	O
==	O
A	O
.	O

Currently	O
I	O
am	O
looping	O
through	O
the	O
arrays	O
and	O
using	O
numpy.dstack	B-API
to	O
stack	O
the	O
1000	O
arrays	O
into	O
a	O
rather	O
large	O
3d	O
array	O
...	O
and	O
then	O
will	O
calculate	O
the	O
mean	O
across	O
the	O
3rd	O
(	O
?	O
)	O
dimension	O
.	O

If	O
you	O
strip	O
all	O
these	O
out	O
and	O
just	O
call	O
lapack	O
in	O
your	O
for	O
loop	O
(	O
since	O
you	O
already	O
know	O
the	O
dimensions	O
of	O
your	O
matrix	O
and	O
maybe	O
know	O
that	O
it's	O
real	O
,	O
not	O
complex	O
)	O
,	O
things	O
run	O
MUCH	O
faster	O
(	O
Note	O
that	O
I've	O
made	O
my	O
array	O
larger	O
)	O
:	O
#CODE	O

First	O
,	O
you	O
have	O
a	O
binomial	O
response	O
:	O
having	O
or	O
not	O
having	O
a	O
particular	O
behavior	O
.	O

The	O
call	O
to	O
`	O
np.sqrt	B-API
`	O
,	O
which	O
is	O
a	O
Python	O
function	O
call	O
,	O
is	O
killing	O
your	O
performance	O
You	O
are	O
computing	O
the	O
square	O
root	O
of	O
scalar	O
floating	O
point	O
value	O
,	O
so	O
you	O
should	O
use	O
the	O
`	O
sqrt	B-API
`	O
function	O
from	O
the	O
C	O
math	O
library	O
.	O

This	O
would	O
call	O
the	O
function	O
`	O
np.loadtxt	B-API
`	O
which	O
would	O
load	O
the	O
file	O
`	O
GPBUSD1d.txt	O
'`	O
and	O
transpose	O
(	O
"	O
unpack	O
")	O
it	O
.	O

You	O
can't	O
change	O
the	O
typing	O
of	O
the	O
array	O
in-place	O
(	O
unless	O
I'm	O
grossly	O
mistaken	O
)	O
,	O
but	O
you	O
can	O
floor	B-API
.	O

Finally	O
I	O
just	O
transpose	O
the	O
dataframe	O
to	O
get	O
ids	O
as	O
rows	O
and	O
categories	O
as	O
columns	O
.	O

The	O
following	O
way	O
of	O
obtaining	O
the	O
unique	O
elements	O
in	O
all	O
sub-arrays	O
is	O
very	O
fast	O
:	O
#CODE	O

You	O
can't	O
use	O
the	O
numpy	O
reshape	B-API
for	O
a	O
simple	O
reason	O
:	O
you	O
have	O
data	O
duplicity	O
in	O
your	O
original	O
array	O
(	O
time	O
and	O
positions	O
)	O
and	O
not	O
in	O
the	O
result	O
you	O
want	O
.	O

So	O
it	O
does	O
not	O
make	O
much	O
sense	O
to	O
me	O
to	O
reshape	O
it	O
to	O
a	O
"	O
1d-matrix	O
"	O
.	O

Now	O
create	O
5-bit	O
bitstrings	O
from	O
each	O
integer	O
and	O
join	O
them	O
together	O
:	O
#CODE	O

It	O
would	O
probably	O
be	O
just	O
as	O
much	O
work	O
to	O
translate	O
the	O
top	O
Matlab	O
routine	O
from	O
Maurits	O
.	O

In	O
the	O
particular	O
case	O
of	O
your	O
example	O
,	O
where	O
your	O
unique	O
values	O
are	O
sequential	O
integers	O
,	O
you	O
can	O
use	O
`	O
find_objects	O
`	O
directly	O
.	O

axis=1	O
refers	O
to	O
working	O
on	O
rows	O
in	O
this	O
2d	O
case	O
(	O
axis=0	O
,	O
in	O
contrast	O
,	O
would	O
be	O
getting	O
you	O
the	O
max	B-API
in	O
each	O
column	O
)	O

There	O
are	O
many	O
other	O
`	O
ufunc	O
`	O
,	O
and	O
other	O
iteration	O
modes	O
-	O
`	O
accumulate	B-API
`	O
,	O
`	O
reduceat	B-API
`	O
.	O

All	O
diagonal	O
elements	O
will	O
be	O
of	O
the	O
form	O
`	O
s_i	O
**	O
2	O
/	O
s_i	O
**	O
2	O
==	O
1	O
`	O
.	O

@USER	O
In	O
the	O
example	O
above	O
,	O
I	O
get	O
the	O
following	O
error	O
:	O
Non-broadcastable	O
operand	O
with	O
shape	O
(	O
100	O
)	O
doesn't	O
match	O
the	O
broadcast	B-API
shape	O
(	O
100,100	O
)	O

is	O
calculated	O
such	O
that	O
all	O
but	O
the	O
diagonal	O
#CODE	O

To	O
compute	O
the	O
number	O
of	O
unique	O
elements	O
in	O
a	O
numpy	O
array	O
,	O
you	O
can	O
use	O
`	O
unique	B-API
(	O
x	O
)	O
.size	O
`	O
or	O
`	O
len	B-API
(	O
unique	B-API
(	O
x	O
))`	O
(	O
see	O
`	O
numpy.unique	B-API
`	O
)	O
.	O

Or	O
would	O
that	O
basically	O
require	O
implementing	O
the	O
outer	O
loop	O
in	O
Cython	O
?	O

For	O
a	O
tensor	O
it	O
is	O
not	O
clear	O
how	O
to	O
define	O
an	O
inverse	O
or	O
a	O
transpose	O
.	O

Second	O
,	O
you	O
are	O
doing	O
transpose	B-API
the	O
hard	O
way	O
.	O

Where	O
does	O
log	B-API
(	O
b	O
,	O
2	O
)	O
come	O
from	O
?	O

(	O
The	O
values	O
in	O
the	O
corners	O
correspond	O
to	O
the	O
diagonal	O
elements	O
.	O
)	O

I	O
tried	O
using	O
the	O
scipy.stat	O
module	O
by	O
creating	O
my	O
numbers	O
with	O
`	O
np.random.normal	B-API
`	O
,	O
since	O
it	O
only	O
takes	O
data	O
and	O
not	O
stat	O
values	O
like	O
mean	O
and	O
std	O
dev	O
(	O
is	O
there	O
any	O
way	O
to	O
use	O
these	O
values	O
directly	O
)	O
.	O

The	O
asymptotic	O
complexity	O
of	O
both	O
of	O
the	O
`	O
matrix_rank	B-API
`	O
and	O
`	O
det	B-API
`	O
calls	O
are	O
therefore	O
O	O
(	O
n^3	O
)	O
,	O
the	O
complexity	O
of	O
LU	O
decomposition	O
.	O

I	O
think	O
the	O
np.std()	B-API
is	O
just	O
universal	O
std	B-API
.	O

Golub	O
and	O
Van	O
Loan	O
also	O
provide	O
a	O
way	O
of	O
storing	O
a	O
matrix	O
in	O
diagonal	O
dominant	O
form	O
.	O

I	O
see	O
no	O
reason	O
why	O
`	O
numpy	O
`	O
would	O
need	O
to	O
make	O
a	O
copy	O
for	O
an	O
operation	O
like	O
this	O
,	O
as	O
long	O
as	O
it	O
does	O
the	O
necessary	O
checks	O
for	O
overlaps	O
(	O
though	O
of	O
course	O
as	O
others	O
have	O
noted	O
,	O
`	O
resize	B-API
`	O
may	O
itself	O
have	O
to	O
allocate	O
a	O
new	O
block	O
of	O
memory	O
)	O
.	O

I	O
found	O
another	O
stack	O
question	O
about	O
this	O
here	O
,	O
but	O
I	O
am	O
not	O
entirely	O
sure	O
how	O
it	O
was	O
resolved	O
,	O
I'm	O
still	O
a	O
little	O
confused	O
.	O

Maybe	O
`	O
floor	B-API
(	O
arange	B-API
(	O
0	O
,	O
10	O
,	O
0.1	O
))`	O
?	O

In	O
python	O
,	O
I	O
would	O
like	O
to	O
convolve	O
the	O
two	O
matrices	O
along	O
the	O
second	O
axis	O
only	O
.	O

`	O
view	B-API
`	O
is	O
basically	O
taking	O
your	O
two	O
coordinates	O
as	O
a	O
single	O
variable	O
that	O
can	O
be	O
used	O
to	O
find	O
the	O
unique	O
coordinates	O
.	O

Keep	O
in	O
mind	O
that	O
machine	O
precision	O
for	O
a	O
32-bit	O
double	O
is	O
~	O
10^-16	O
,	O
which	O
will	O
be	O
an	O
absolute	O
limiting	O
factor	O
.	O

Also	O
,	O
if	O
there	O
is	O
then	O
I	O
could	O
just	O
append	O
to	O
the	O
b	O
and	O
c	O
arrays	O
each	O
time	O
instead	O
of	O
overwriting	O
and	O
starting	O
from	O
scratch	O
each	O
loop	O
.	O

Use	O
`	O
multiprocessing.Process	O
(	O
target	O
=	O
somefunc	O
,	O
args	O
=	O
(	O
sa	O
,	O
)`	O
(	O
and	O
`	O
start	O
`	O
,	O
maybe	O
`	O
join	B-API
`)	O
to	O
call	O
`	O
somefunc	O
`	O
in	O
a	O
separate	O
process	O
,	O
passing	O
the	O
shared	O
array	O
.	O

Take	O
a	O
look	O
a	O
the	O
concatenate	B-API
function	O
.	O

Unlike	O
Joe	O
Kington's	O
answer	O
,	O
the	O
benefit	O
of	O
this	O
is	O
that	O
you	O
don't	O
need	O
to	O
know	O
the	O
original	O
shape	O
of	O
the	O
data	O
in	O
the	O
`	O
.mat	O
`	O
file	O
,	O
i.e.	O
no	O
need	O
to	O
reshape	O
upon	O
reading	O
in	O
.	O

but	O
I	O
think	O
,	O
finding	O
the	O
local	O
max	O
can	O
be	O
simplified	O
to	O
:	O
#CODE	O

@USER	O
`	O
swapaxes	B-API
`	O
seemed	O
to	O
be	O
indistinguishable	O
from	O
`	O
transpose	B-API
(	O
0	O
,	O
2	O
,	O
1	O
)`	O
.	O

Do	O
gradient	B-API
actually	O
compute	O
really	O
a	O
gradient	O
?	O

I	O
would	O
suggest	O
to	O
first	O
program	O
it	O
with	O
`	O
np.nditer	B-API
`	O
and	O
then	O
translate	O
it	O
into	O
C	O
.	O

As	O
you	O
can	O
see	O
,	O
using	O
the	O
join	B-API
function	O
on	O
the	O
list	O
(	O
`	O
binary_list	O
`)	O
works	O
properly	O
,	O
but	O
on	O
the	O
equivalent	O
numpy	O
array	O
(	O
`	O
binary_split_array	O
`)	O
it	O
doesn't	O
:	O
we	O
can	O
see	O
the	O
string	O
returned	O
is	O
only	O
72	O
characters	O
long	O
instead	O
of	O
80	O
.	O

@USER	O
.B	O
.	O
the	O
above	O
question	O
is	O
significantly	O
different	O
from	O
mine	O
;	O
it	O
asks	O
for	O
both	O
min	B-API
and	O
max	B-API
,	O
and	O
it	O
is	O
for	O
2D	O
matrix	O

This	O
will	O
join	O
the	O
rows	O
and	O
write	O
them	O
to	O
a	O
new	O
csv	O
:	O
#CODE	O

The	O
reason	O
I	O
have	O
`	O
-det	O
(	O
mat	O
)`	O
in	O
the	O
energy	O
function	O
is	O
because	O
the	O
simulated	O
annealing	O
algorithm	O
does	O
minimization	O
.	O

Also	O
is	O
`	O
x	O
`	O
unique	O
?	O

Pandas	O
append	B-API
filtered	O
row	O
to	O
another	O
DataFrame	O

Again	O
,	O
the	O
code	O
notes	O
that	O
set	O
of	O
combinations	O
is	O
not	O
unique	O
;	O
but	O
it	O
does	O
have	O
a	O
unique	O
subset	O
,	O
namely	O
[[	O
2	O
3	O
]	O
,	O
[	O
0	O
1	O
]]	O
,	O
which	O
as	O
you	O
just	O
revealed	O
,	O
you	O
do	O
consider	O
a	O
valid	O
combination	O
.	O

That	O
concatenate	B-API
action	O
should	O
be	O
pretty	O
fast	O
.	O

If	O
you	O
want	O
to	O
pass	O
in	O
the	O
transpose	O
,	O
you'll	O
need	O
to	O
set	O
`	O
rowvar	O
`	O
to	O
zero	O
.	O

You	O
can	O
override	O
this	O
behavior	O
by	O
using	O
the	O
arguments	O
`	O
vmin	O
`	O
and	O
`	O
vmax	O
`	O
(	O
or	O
`	O
norm	O
`)	O
of	O
`	O
imshow	B-API
`	O
.	O

@USER	O
,	O
`	O
cs	O
`	O
is	O
sorted	O
and	O
`	O
searchsorted()	B-API
`	O
exploits	O
that	O
to	O
do	O
a	O
binary	O
search	O
-	O
only	O
`	O
O	O
(	O
log	B-API
(	O
len	B-API
(	O
weights	O
)))`	O
comparisons	O
are	O
needed	O
.	O

Think	O
`	O
flatten	B-API
`	O
without	O
the	O
copy	O
.	O

In	O
your	O
case	O
it	O
looks	O
like	O
the	O
weight	O
arrays	O
will	O
have	O
the	O
same	O
dimension	O
as	O
'	O
A	O
'	O
,	O
so	O
you	O
reshape	O
them	O
accordingly	O
and	O
multiply	O
dx	O
and	O
dy	O
by	O
their	O
individual	O
weight	O
vectors	O
.	O

Does	O
this	O
mean	O
the	O
standard	O
error	O
of	O
the	O
gradient	O
or	O
intercept	O
?	O

Also	O
,	O
the	O
algo	O
has	O
a	O
lot	O
of	O
matrices	O
manipulation	O
(	O
fft	B-API
,	O
filters	O
,	O
etc	O
.	O
)	O
,	O
so	O
using	O
numpy	O
/	O
scipy	O
should	O
result	O
in	O
faster	O
run	O
time	O
.	O

You	O
can	O
broadcast	O
that	O
into	O
an	O
array	O
using	O
expressions	O
,	O
for	O
example	O
#CODE	O

If	O
I	O
use	O
the	O
above	O
test	O
on	O
the	O
absolute	O
values	O
of	O
the	O
angles	O
to	O
be	O
tested	O
,	O
everything	O

The	O
returned	O
gradient	O
hence	O
has	O

"	O
In	O
the	O
first	O
case	O
the	O
gradient	O
is	O
1	O
mV	O
/	O
ms	O
,	O
in	O
the	O
second	O
case	O
it	O
is	O
50	O
mV	O
/	O
ms	O
.	O

If	O
True	O
,	O
uses	O
the	O
old	O
behavior	O
from	O
Numeric	O
,	O
(	O
correlate	B-API
(	O
a	O
,	O
v	O
)	O
==	O
correlate	B-API
(	O
v	O
,	O
a	O
)	O
,	O
and	O
the	O
conjugate	O
is	O
not	O
taken	O
for	O
complex	O
arrays	O
)	O
.	O

Why	O
don't	O
you	O
just	O
compress	O
the	O
files	O
with	O
the	O
built-in	O
`	O
gzip	O
`	O
module	O
?	O

So	O
you	O
need	O
to	O
write	O
some	O
function	O
that	O
convert	O
a	O
poly	O
parameters	O
array	O
to	O
a	O
latex	O
string	O
,	O
here	O
is	O
an	O
example	O
:	O
#CODE	O

In	O
your	O
example	O
,	O
the	O
square	O
root	O
is	O
calculated	O
by	O
evaluating	O
the	O
the	O
module	O
and	O
the	O
argument	O
of	O
your	O
complex	O
number	O
(	O
essentially	O
via	O
the	O
log	B-API
function	O
,	O
which	O
returns	O
log	B-API
(	O
module	O
)	O
+	O
i	O
phase	O
)	O
.	O

I	O
am	O
trying	O
to	O
run	O
hstack	B-API
to	O
join	O
a	O
column	O
of	O
integer	O
values	O
to	O
a	O
list	O
of	O
columns	O
created	O
by	O
a	O
TF-IDF	O
(	O
so	O
I	O
can	O
eventually	O
use	O
all	O
of	O
these	O
columns	O
/	O
features	O
in	O
a	O
classifier	O
)	O
.	O

How	O
to	O
pass	O
these	O
`	O
norm	O
`	O
and	O
`	O
cmap	O
`	O
parameters	O
in	O
matplotlib	O
to	O
`	O
plt.show	B-API
`	O
or	O
`	O
imshow()	B-API
`	O
?	O

Forget	O
about	O
the	O
C	O
stack	O
,	O
numpy	O
objects	O
can't	O
use	O
it	O
.	O

You	O
can	O
use	O
the	O
append	B-API
function	O
as	O
he	O
has	O
defined	O
.	O

This	O
can	O
be	O
particularly	O
tricky	O
when	O
trying	O
to	O
append	O
to	O
a	O
numpy	O
array	O
quickly	O
.	O

I	O
have	O
a	O
question	O
regarding	O
to	O
the	O
`	O
fft	B-API
`	O
and	O
`	O
ifft	B-API
`	O
functions	O
.	O

So	O
for	O
now	O
,	O
I	O
just	O
changed	O
the	O
max	B-API
(	O
z	O
)	O
to	O
a	O
number	O
that	O
I	O
know	O
is	O
the	O
max	B-API
(	O
1567	O
)	O
.	O

The	O
`	O
add	B-API
`	O
operation	O
does	O
not	O
do	O
the	O
same	O
thing	O
as	O
`	O
join	B-API
`	O
.	O

You	O
don't	O
specify	O
`	O
x	O
`	O
or	O
`	O
y	O
`	O
,	O
and	O
your	O
`	O
mat	O
[:	O
,	O
i+1	O
]`	O
indexing	O
will	O
not	O
work	O
with	O
a	O
structured	O
array	O
.	O

This	O
is	O
because	O
in	O
some	O
cases	O
it's	O
not	O
just	O
NaNs	O
and	O
1s	O
,	O
but	O
other	O
integers	O
,	O
which	O
gives	O
a	O
std	O
>	O
0	O
.	O

I	O
tried	O
adding	O
`	O
/	O
Library	O
/	O
TeX	O
/	O
Root	O
/	O
bin	O
/	O
universal-darwin	O
`	O
to	O
the	O
Global	O
Python	O
Path	O
of	O
the	O
Project	O
Properties	O
,	O
but	O
I	O
still	O
get	O
the	O
same	O
errors	O
.	O

My	O
Python	O
Path	O
is	O
correct	O
C	O
:\	O
Python27_32bit\	O
and	O
I	O
also	O
have	O
\lib\	O
site-packages	O
\	O
and	O
\DLL	O
included	O
correctly	O
.	O

Adding	O
Python	O
Path	O
on	O
Windows	O
7	O

Append	O
`	O
;	O
C	O
:\	O
python27\Scripts	O
`	O
to	O
the	O
end	O
of	O
`	O
Path	O
`	O
variable	O

I	O
use	O
a	O
palette	O
file	O
that	O
I'm	O
able	O
to	O
create	O
using	O
GIMP	O
+	O
Sample	O
a	O
Gradient	O
Along	O
a	O
Path	O
.	O

Spine	O
position	O
is	O
specified	O
by	O
a	O
2	O
tuple	O
of	O
(	O
position	O
type	O
,	O
amount	O
)	O
.	O

Annotation	O
along	O
a	O
curve	O
in	O
matplotlib	O

Heat	O
Map	O
Annotation	O
with	O
text	O

Annotation	O
on	O
top	O
of	O
the	O
bars	O
show	O
the	O
actual	O
percentage	O
of	O
that	O
category	O
.	O

Text	O
File	O
.	O

I'm	O
using	O
Ubuntu	O
and	O
Sublime	O
Text	O
.	O

Check	O
this	O
page	O
:	O
Text	O
Rendering	O
with	O
LaTeX	O
.	O

When	O
using	O
Matplotlib	O
(	O
Pylab	O
)	O
for	O
rendering	O
Text	O
with	O
the	O
same	O
metrics	O
as	O
AriaL	O
(	O
e.g.	O
,	O
Arial	O
itself	O
or	O
Liberation	O
Sans	O
)	O
output	O
looks	O
ok	O
-	O
e.g.	O
,	O
the	O
width	O
of	O
the	O
legend	O
box	O
is	O
right	O
.	O

Text	O
box	O
with	O
line	O
wrapping	O
in	O
matplotlib	O
?	O

Python	O
/	O
Matplotlib	O
-	O
Quickly	O
Updating	O
Text	O
on	O
Axes	O

Text	O
display	O
problem	O
with	O
matplotlib	O
?	O

Network	O
from	O
Table	O
(	O
Text	O
/	O
MS	O
Excel	O
)	O
..	O

Text	O
alignment	O
in	O
a	O
Matplotlib	O
legend	O

Underlining	O
Text	O
in	O
Python	O
/	O
Matplotlib	O

(	O
Text	O
colour	O
comes	O
out	O
as	O
black	O
)	O
#CODE	O

However	O
,	O
when	O
I	O
paste	O
this	O
code	O
into	O
my	O
Wordpress	O
page	O
(	O
using	O
the	O
Text	O
editor	O
,	O
not	O
the	O
visual	O
editor	O
)	O
nothing	O
happens	O
.	O

This	O
generates	O
the	O
plot	O
but	O
the	O
Legend	O
B	O
is	O
placed	O
at	O
the	O
upper	O
right	O
hand	O
side	O
corner	O
and	O
Legend	O
A	O
is	O
by	O
default	O
placed	O
at	O
the	O
left	O
hand	O
upper	O
corner	O
.	O

Multiple	O
Pie	O
Charts	O
with	O
a	O
Shared	O
Legend	O

You	O
can	O
add	O
a	O
legend	O
to	O
only	O
the	O
first	O
axes	O
after	O
plotting	O
all	O
of	O
your	O
pie	O
charts	O
:	O
#CODE	O

Matplotlib	O
:	O
Legend	O
not	O
displayed	O
properly	O

Legend	O
colors	O
in	O
Matplotlib	O
table	O
function	O
?	O

Legend	O
transparency	O
,	O
when	O
using	O
secondary	O
axis	O

Legend	O
is	O
outside	O
the	O
frame	O
.	O

Button	O
1	O
:	O
Shows	O
the	O
pointscores	O
of	O
John	O
and	O
Daniel	O
in	O
level	O
1	O
.	O

How	O
to	O
get	O
multiple	O
Button	O
Click	O
Events	O
in	O
Python	O

Button	O
click	O
->	O
ser.write	O
,	O
ser.read	O
,	O
draw	O

Another	O
solution	O
is	O
print	O
a	O
'	O
Cursor	O
'	O
or	O
marker	O
line	O
on	O
the	O
plot	O
,	O
and	O
change	O
its	O
coordinates	O
with	O
the	O
mouse	O
events	O
.	O

An	O
Arrow	O
would	O
appear	O
with	O
data	O
about	O
the	O
invisible	O
line	O
one	O
,	O
but	O
he	O
wanted	O
info	O
about	O
line	O
two	O
.	O

Arrow	O
on	O
a	O
line	O
plot	O
with	O
matplotlib	O

Drawing	O
Arrow	O
in	O
(	O
x	O
,	O
y	O
)	O
coordinate	O
in	O
Python	O

To	O
be	O
more	O
specific	O
,	O
if	O
you	O
look	O
at	O
the	O
answer	O
to	O
that	O
question	O
it	O
shows	O
how	O
to	O
make	O
a	O
3D	O
Arrow	O
and	O
use	O
that	O
to	O
annotate	O
points	O
in	O
a	O
3D	O
plot	O
--	O
I	O
have	O
used	O
this	O
recipe	O
extensively	O
and	O
it	O
makes	O
me	O
wonder	O
how	O
it	O
isn't	O
built	O
into	O
matplotlib	O
yet	O
.	O

Node	O
positions	O
are	O
generated	O
,	O
stored	O
and	O
assigned	O
like	O
this	O
#CODE	O

Node	O
and	O
edge	O
attribute	O
files	O
are	O
simply	O
formatted	O
:	O
a	O
node	O
attribute	O
file	O
begins	O
with	O
the	O
name	O
of	O
the	O
attribute	O
on	O
the	O
first	O
line	O
(	O
note	O
that	O
it	O
cannot	O
contain	O
spaces	O
)	O
.	O

Normalize	O
the	O
input	O
data	O
and	O
scale	O
it	O

Normalize	O
your	O
data	O
.	O

Normalize	O
again	O

Normalize	O
your	O
data	O
,	O
apply	O
the	O
colormap	O
,	O
save	O
the	O
image	O
.	O
matplotlib	O
provides	O
all	O
the	O
necessary	O
functionality	O
:	O
#CODE	O

Normalize	O
histogram2d	B-API
by	O
bin	O
area	O

Python	O
/	O
Matplotlib	O
-	O
Figure	O
Borders	O
in	O
wxPython	O

gcf()	B-API
means	O
Get	O
Current	O
Figure	O

Figure	O
title	O
with	O
several	O
colors	O
in	O
matplotlib	O

However	O
,	O
the	O
sample	O
consists	O
of	O
distinct	O
solutions	O
which	O
form	O
lines	O
in	O
the	O
parameter	O
space	O
such	O
that	O
putting	O
everything	O
into	O
a	O
matrix	O
and	O
using	O
`	O
imshow	B-API
`	O
is	O
not	O
desirable	O
because	O
of	O
the	O
pixelation	O
artefacts	O
(	O
Figure	O
1	O
)	O
.	O

See	O
Figure	O
2	O
.	O

Labeling	O
Figure	O
from	O
String	O
List	O

I	O
was	O
able	O
to	O
maximize	O
Figure	O
windows	O
for	O
TkAgg	O
,	O
QT4Agg	O
,	O
and	O
wxAgg	O
using	O
the	O
following	O
lines	O
:	O
#CODE	O

I	O
want	O
to	O
draw	O
a	O
quadratic	O
Figure	O
.	O

So	O
I	O
guess	O
I	O
have	O
to	O
built	O
each	O
button	O
separately	O
,	O
and	O
don't	O
know	O
how	O
to	O
"	O
order	O
"	O
them	O
in	O
the	O
buttons_frame	O
2	O
)	O
I	O
am	O
working	O
within	O
a	O
for	O
loop	O
,	O
so	O
I	O
can't	O
use	O
a	O
"	O
main	O
"	O
specifically	O
for	O
this	O
.	O
and	O
3	O
)	O
the	O
Figure	O
to	O
plot	O
is	O
already	O
created	O
before	O
entering	O
the	O
GUI	O
.	O

But	O
I	O
wonder	O
if	O
there	O
is	O
a	O
way	O
to	O
do	O
the	O
same	O
link	O
(	O
when	O
zooming	O
on	O
figure	O
1	O
,	O
I	O
get	O
the	O
same	O
zoom	O
on	O
figure	O
2	O
on	O
one	O
particular	O
axis	O
)	O
when	O
defining	O
2	O
different	O
Figures	O
(	O
I	O
want	O
those	O
graph	O
to	O
appear	O
far	O
from	O
each	O
other	O
so	O
I	O
guess	O
that	O
I	O
can't	O
put	O
them	O
in	O
the	O
same	O
Figure	O
...	O
)	O

I	O
removed	O
the	O
reference	O
to	O
Figure	O
0	O
and	O
had	O
it	O
generate	O
a	O
new	O
figure	O
each	O
time	O
.	O

Right	O
now	O
,	O
that	O
it	O
the	O
best	O
I	O
can	O
do	O
,	O
see	O
Figure	O
.	O

Sounds	O
like	O
you	O
just	O
want	O
an	O
image	O
in	O
the	O
Figure	O
,	O
right	O
?	O

You	O
should	O
perhaps	O
try	O
some	O
converter	O
that	O
can	O
produce	O
DXF	O
from	O
EPS	O
,	O
PDF	O
,	O
SVG	O
...	O

For	O
example	O
see	O
this	O
converter	O
in	O
java	O
:	O

You	O
already	O
have	O
one	O
such	O
converter	O
in	O
your	O
`	O
np.loadtxt	B-API
`	O
method	O
call	O
.	O

You	O
can	O
achieve	O
this	O
by	O
defining	O
a	O
converter	O
that	O
converts	O
sting	O
representations	O
of	O
dates	O
to	O
`	O
datenums	O
`	O
.	O

Matplotlib	O
Plot	O
Lines	O
Above	O
Each	O
Bar	O

Matplotlib.pyplot	B-API
Bar	O
Plot	O
Grouping	O
Subplots	O

How	O
to	O
properly	O
give	O
Annotations	O
to	O
Pandas	O
Bar	O
Charts	O
?	O

Pandas	O
,	O
Bar	O
Chart	O
Settings	O
Customization	O

Two	O
Bar	O
Plots-	O
Non	O
side	O
by	O
side	O

I	O
have	O
a	O
couple	O
of	O
problems	O
with	O
the	O
Bar	O
Chart	O
that	O
I'm	O
trying	O
to	O
create	O
in	O
python	O
.	O

I	O
have	O
a	O
simple	O
graph	O
with	O
a	O
Navigation	O
Tool	O
Bar	O
.	O

Matplotlib	O
Subplot	O
Animation	O
with	O
Basemap	O

Basic	O
Animation	O
with	O
matplotlib's	O
pyplot	B-API

How	O
Can	O
I	O
Save	O
Animation.Artist	O
animation	O
?	O

Animation	O
with	O
contours	O
matplotlib	O

I	O
found	O
the	O
solution	O
(	O
set	O
2	O
)	O
that	O
uses	O
the	O
mpl	O
Toolkit	O
and	O
AA	O
to	O
allow	O
sharing	O
of	O
the	O
X	O
Axis	O
and	O
present	O
more	O
than	O
2	O
scales	O
.	O
by	O
changing	O
the	O
code	O
to	O
allow	O
for	O
set	O
2	O
is	O
where	O
I	O
noticed	O
problems	O
.	O

The	O
side	O
scales	O
almost	O
look	O
good	O
(	O
exception	O
is	O
repeats	O
on	O
the	O
right	O
)	O
and	O
I	O
CANNOT	O
CHANGE	O
FONT	O
size	O
of	O
the	O
X-Axis	O
labels	O
and	O
Y	O
Axis	O
labels	O
.	O

Reverse	O
Z	O
Axis	O
on	O
matplotlib	O
3D	O
Plot	O

You	O
have	O
an	O
example	O
of	O
the	O
broken	O
axis	O
in	O
the	O
matplotlib	O
examples	O
:	O
Broken	O
Axis	O

Axis	O
scale	O
with	O
bins	O

Converting	O
Integer	O
(	O
Day	O
Count	O
)	O
X	O
Axis	O
to	O
Months	O

3d	O
Polygon	O
Plot	O
in	O
matplotlib	O
baselines	O
slanted	O

I	O
am	O
trying	O
to	O
create	O
my	O
own	O
version	O
of	O
the	O
3D	O
Polygon	O
plot	O
as	O
shown	O
on	O
the	O
Matplotlib	O
web	O
site	O
:	O

I'm	O
trying	O
to	O
make	O
a	O
polar	O
chart	O
with	O
matplotlib	O
and	O
python	O
2.7	O
,	O
but	O
I'm	O
struggling	O
on	O
how	O
to	O
increase	O
the	O
space	O
between	O
the	O
X-Axis	O
and	O
the	O
Tick	O
Labels	O
for	O
that	O
same	O
axis	O
.	O

Tick	O
labels	O
on	O
x-axis	O
aren't	O
symmetric	O
(	O
Matplotlib	O
)	O

Tick	O
label	O
displayed	O
when	O
clicking	O
on	O
graph	O
?	O

Axes	O
missing	O
when	O
plotting	O
in	O
matplotlib	O
using	O
vispy	O
as	O
backend	O

In	O
theory	O
,	O
this	O
code	O
doesn't	O
change	O
any	O
coordinates	O
;	O
it	O
just	O
gets	O
the	O
coordinates	O
of	O
each	O
label	O
,	O
maps	O
it	O
to	O
Axes	O
coordinates	O
using	O
the	O
Text	O
object's	O
internally-stored	O
transform	O
,	O
and	O
then	O
sets	O
the	O
position	O
.	O

@USER	O
I	O
think	O
he	O
wants	O
to	O
get	O
the	O
tick	O
positions	O
in	O
Axes	O
coordinates	O
.	O

Axes	O
fonts	O
with	O
text.usetex	O
'	O
true	O
'	O
does	O
not	O
use	O
set	O
font	O

Also	O
,	O
when	O
specifying	O
where	O
you	O
want	O
the	O
subplot	O
to	O
be	O
placed	O
(	O
the	O
third	O
input	O
to	O
`	O
Figure.add_subplot()	B-API
`)	O
,	O
you	O
do	O
not	O
want	O
to	O
use	O
`	O
y+1	O
`	O
because	O
that	O
would	O
start	O
at	O
`	O
1	O
`	O
and	O
end	O
at	O
`	O
6	O
`	O
which	O
would	O
go	O
out	O
of	O
the	O
available	O
range	O
of	O
0-5	O
.	O

While	O
it	O
might	O
be	O
possible	O
to	O
hack	O
`	O
JointGrid	O
`	O
to	O
get	O
this	O
to	O
work	O
,	O
I	O
suspect	O
it	O
will	O
very	O
likely	O
be	O
easier	O
to	O
just	O
use	O
`	O
kdeplot	O
`	O
on	O
one	O
Axes	O
,	O
using	O
`	O
twinx	B-API
`	O
and	O
`	O
twiny	B-API
to	O
place	O
and	O
scale	O
the	O
marginal	O
plots	O
properly	O
.	O

I	O
want	O
to	O
transform	O
those	O
intensity	O
values	O
to	O
pixel	O
intensity	O
values	O
as	O
in	O
the	O
following	O
image	O
:	O

The	O
longer	O
the	O
time	O
period	O
becomes	O
,	O
the	O
sharper	O
the	O
peaks	O
will	O
become	O
(	O
the	O
Fourier	O
transform	O
of	O
the	O
cosines	O
):	O
#CODE	O

How	O
to	O
transform	O
your	O
data	O
into	O
this	O
format	O
is	O
a	O
simple	O
question	O
,	O
maybe	O
a	O
bit	O
googling	O
and	O
trial	O
and	O
error	O
.	O

Perhaps	O
it	O
is	O
best	O
to	O
transform	O
to	O
linear	O
coordinates	O
and	O
calculate	O
how	O
to	O
produce	O
the	O
curved	O
grid	O
for	O
the	O
declination	O
and	O
the	O
radial	O
lines	O
for	O
the	O
right	O
ascension	O
.	O

Since	O
my	O
data	O
is	O
roughly	O
spherical	O
I	O
triangulate	O
the	O
azimuth	O
and	O
zenith	O
angles	O
from	O
the	O
spherical	O
coordinate	O
transform	O
of	O
my	O
data	O
points	O
.	O

A	O
workaround	O
might	O
be	O
to	O
log10	B-API
transform	O
the	O
data	O
before	O
plotting	O
,	O
but	O
the	O
approaches	O
I	O
have	O
tried	O
,	O
#CODE	O

Without	O
having	O
to	O
transform	O
everything	O
to	O
string	O
or	O
another	O
kind	O
of	O
object	O
?	O

However	O
,	O
the	O
dates	O
mysteriously	O
transform	O
themselves	O
to	O
an	O
ugly	O
and	O
unreadable	O
format	O
when	O
plotting	O
the	O
same	O
data	O
as	O
a	O
bar	O
plot	O
.	O

I	O
want	O
to	O
find	O
out	O
how	O
to	O
transform	O
magnitude	O
value	O
of	O
accelerometer	O
to	O
frequency	O
domain	O
.	O

Then	O
,	O
you	O
need	O
to	O
set	O
the	O
transform	O
for	O
the	O
new	O
lines	O
on	O
`	O
a_all	O
`	O
to	O
move	O
them	O
to	O
the	O
new	O
axis	O
.	O

What	O
about	O
applying	O
a	O
rectangular	O
(	O
ok	O
,	O
in	O
three	O
dimensions	O
,	O
cubic	O
)	O
window	O
to	O
your	O
field	O
before	O
fourier	O
transform	O
?	O

The	O
canvas	O
seems	O
to	O
get	O
locked	O
and	O
after	O
the	O
call	O
of	O
the	O
pick	O
event	O
I	O
can	O
not	O
use	O
the	O
other	O
functionalities	O
as	O
well	O
.	O

When	O
it	O
is	O
triggered	O
it	O
seems	O
that	O
the	O
canvas	O
gets	O
locked	O
and	O
I	O
can	O
not	O
use	O
any	O
other	O
functionality	O
.	O

I	O
am	O
trying	O
to	O
draw	O
an	O
arrow	O
on	O
the	O
scatterplot	O
.	O

Are	O
these	O
parametric	O
orbits	O
,	O
so	O
that	O
you	O
could	O
draw	O
vertical	O
lines	O
for	O
each	O
time	O
(	O
or	O
whatever	O
)	O
_t_	O
?	O

I've	O
follow	O
this	O
subject	O
:	O
How	O
to	O
draw	O
planes	O
from	O
a	O
set	O
of	O
linear	O
equations	O
in	O
Python	O
?	O

I	O
am	O
able	O
to	O
draw	O
with	O
all	O
variables	O
at	O
x-axis	O
if	O
convert	O
it	O
to	O
bar	O
graph	O
.	O

But	O
in	O
my	O
particular	O
case	O
I	O
have	O
to	O
draw	O
Line2D	B-API
instances	O
using	O
Points	O
coordinates	O
on	O
top	O
of	O
the	O
regular	O
plots	O
that	O
are	O
all	O
using	O
Data	O
coordinates	O
.	O

I'm	O
using	O
imshow()	B-API
to	O
draw	O
a	O
2D	O
numpy	O
array	O
,	O
so	O
for	O
example	O
:	O
#CODE	O

I	O
need	O
to	O
draw	O
all	O
function	O
in	O
the	O
same	O
window	O

I	O
want	O
to	O
draw	O
a	O
small	O
red	O
box	O
around	O
one	O
of	O
the	O
ticklabels	O
,	O
as	O
so	O
:	O

I	O
draw	O
4D	O
plot	O
.	O

I'd	O
like	O
to	O
draw	O
/	O
plot	O
an	O
horizontal	O
line	O
on	O
top	O
of	O
the	O
heatmap	O
like	O
in	O
this	O
figure	O

How	O
do	O
I	O
draw	O
edge	O
labels	O
for	O
MultiGraph	O
in	O
NetworkX	O
?	O

How	O
to	O
draw	O
a	O
contour	O
plot	O
using	O
Python	O
?	O

I	O
tried	O
to	O
draw	O
a	O
contour	O
plot	O
using	O
Python	O
.	O

The	O
second	O
option	O
is	O
a	O
touch	O
more	O
verbose	O
,	O
but	O
has	O
the	O
advantage	O
that	O
the	O
y-axis	O
limits	O
on	O
the	O
second	O
plot	O
will	O
autoscale	O
as	O
you'd	O
expect	O
.	O

I	O
included	O
the	O
code	O
to	O
autoscale	O
the	O
viewport	O
,	O
but	O
that's	O
not	O
strictly	O
necessary	O
.	O

possible	O
duplicate	O
of	O
[	O
How	O
to	O
autoscale	O
y	O
axis	O
in	O
matplotlib	O
?	O
]	O
(	O
#URL	O
)	O

if	O
the	O
image	O
is	O
a	O
NxM	O
array	O
of	O
any	O
type	O
,	O
it	O
is	O
interpreted	O
through	O
the	O
colormap	O
(	O
autoscale	O
,	O
if	O
not	O
indicated	O
otherwise	O
)	O
.	O

Now	O
I	O
changed	O
my	O
mind	O
and	O
decide	O
to	O
autoscale	O
the	O
data	O
(	O
and	O
the	O
view	O
)	O
,	O
expecting	O
these	O
limits	O
:	O

I	O
would	O
like	O
to	O
be	O
able	O
to	O
autoscale	O
a	O
matplotlib	O
figure	O
to	O
make	O
arbitrarily	O
placed	O
text	O
annotations	O
visible	O
.	O

I	O
have	O
to	O
refresh	O
the	O
page	O
to	O
get	O
the	O
tooltips	O
back	O
.	O

will	O
refresh	O
your	O
system's	O
reference	O
to	O
the	O
bash_profile	O
and	O
you	O
should	O
be	O
good	O
to	O
go	O
in	O
importing	O
and	O
using	O
matplotlib	O

Id	O
like	O
the	O
user	O
to	O
be	O
able	O
to	O
update	O
an	O
existing	O
and	O
open	O
axis	O
i.e.	O
to	O
refresh	O
the	O
axis	O
.	O

Placing	O
Custom	O
Images	O
in	O
a	O
Plot	O
Window	O
--	O
as	O
custom	O
data	O
markers	O
or	O
to	O
annotate	O
those	O
markers	O

How	O
to	O
annotate	O
/	O
highlight	O
a	O
3d	O
plot	O
in	O
MatPlotLib	O

Well	O
,	O
it	O
takes	O
a	O
loop	O
to	O
annotate	O
all	O
data	O
points	O
,	O
I	O
thought	O
that	O
there	O
should	O
be	O
a	O
function	O
that	O
does	O
just	O
that	O
.	O

You	O
can	O
annotate	O
a	O
specific	O
point	O
in	O
the	O
image	O
using	O
`	O
plt.text	B-API
(	O
x	O
,	O
y	O
,	O
str	O
)`	O
.	O

To	O
state	O
it	O
in	O
a	O
general	O
form	O
,	O
I'm	O
looking	O
for	O
a	O
way	O
to	O
join	O
several	O
points	O
with	O
a	O
gradient	O
color	O
line	O
using	O
matplotlib	O
,	O
and	O
I'm	O
not	O
finding	O
it	O
anywhere	O
.	O

Now	O
instead	O
of	O
straight	O
arrows	O
,	O
I	O
want	O
to	O
join	O
points	O
by	O
curve	O
arrows	O
.	O

If	O
you	O
like	O
,	O
join	O
circos's	O
google	O
group	O
to	O
discuss	O
:	O
#URL	O

Then	O
join	O
me	O
in	O
upvoting	O
that	O
answer	O
and	O
that	O
comment	O
:-)	O

Because	O
there	O
have	O
been	O
closest	O
points	O
but	O
when	O
we	O
join	O
them	O
they	O
lead	O
to	O
an	O
intersections	O
or	O
points	O
which	O
are	O
not	O
so	O
close	O
but	O
should	O
be	O
joined	O
together	O

@USER	O
Because	O
Python	O
automatically	O
join	O
two	O
adjacent	O
strings	O
into	O
one	O
string	O
.	O

This	O
produces	O
a	O
figure	O
like	O
the	O
first	O
figure	O
at	O
How	O
to	O
join	O
overlapping	O
circles	O
?	O

Matplotlib	O
has	O
lots	O
of	O
pre-defined	O
colormaps	O
for	O
you	O
to	O
use	O
.	O

Here	O
are	O
all	O
of	O
the	O
predefined	O
colormaps	O
.	O

For	O
me	O
the	O
simplest	O
way	O
is	O
plotting	O
directly	O
the	O
masks	O
with	O
imshow	B-API
,	O
passing	O
different	O
colormaps	O
.	O

There	O
is	O
a	O
list	O
of	O
colormaps	O
to	O
choose	O
from	O
here	O
.	O

There	O
is	O
also	O
a	O
way	O
to	O
define	O
custom	O
colormaps	O
.	O

The	O
list	O
of	O
available	O
colormaps	O
by	O
default	O
is	O
here	O
.	O

You	O
can	O
add	O
your	O
own	O
colormaps	O
to	O
`	O
_cm.py	O
`	O
in	O
your	O
mpl	O
directory	O
and	O
then	O
change	O
your	O
rc	O
file	O
.	O

How	O
can	O
I	O
tell	O
append_axes	O
that	O
I	O
want	O
to	O
append	O
the	O
y	O
subplot	O
to	O
the	O
right	O
of	O
the	O
"	O
main	O
axes	O
"	O
containing	O
the	O
scatter	O
plot	O
?	O

I	O
got	O
a	O
boxplot	O
graph	O
like	O
this	O
:	O

add	O
boxplot	O
to	O
other	O
graph	O
in	O
python	O

but	O
when	O
I	O
do	O
it	O
on	O
the	O
'	O
link	O
'	O
series	O
I	O
can	O
draw	O
the	O
boxplot	O
correctly	O
.	O

and	O
I	O
am	O
able	O
to	O
draw	O
the	O
boxplot	O
.	O

Or	O
,	O
more	O
generally	O
,	O
modify	O
/	O
transform	O
to	O
you	O
heart's	O
content	O
,	O
and	O
then	O
boxplot	O
.	O

If	O
the	O
ticklabels	O
are	O
already	O
set	O
to	O
a	O
string	O
as	O
in	O
e.g.	O
a	O
boxplot	O
,	O
this	O
is	O
still	O
working	O
.	O

How	O
do	O
I	O
add	O
inset	O
axes	O
and	O
zoom	O
in	O
on	O
the	O
first	O
boxplot	O
of	O
the	O
two	O
?	O

I'm	O
not	O
setting	O
the	O
position	O
of	O
each	O
boxplot	O
,	O
so	O
I	O
don't	O
know	O
where	O
they	O
will	O
appear	O
exactly	O
.	O

I	O
wanted	O
to	O
add	O
a	O
box	O
for	O
each	O
boxplot	O
with	O
a	O
zoomed-in	O
view	O
on	O
a	O
specific	O
y-axis	O
range	O
.	O

UserWarning	O
:	O
2D	O
hist	O
input	O
should	O
be	O
nsamples	O
x	O
nvariables	O
;	O

I'm	O
doing	O
a	O
hist	O
plot	O
and	O
I	O
want	O
some	O
numbers	O
shown	O
in	O
the	O
plot	O
,	O
so	O
I	O
put	O
in	O
a	O
text	O
box	O
using	O
mathtext	B-API
for	O
the	O
text	O
,	O
but	O
I	O
doesn't	O
work	O
and	O
I	O
can't	O
see	O
why	O
.	O

This	O
lead	O
to	O
my	O
colorbar	O
having	O
sqrt	O
ticks	O
and	O
I	O
want	O
to	O
translate	O
them	O
back	O
to	O
the	O
original	O
values	O
.	O

avoiding	O
the	O
local	O
cache	O
when	O
fetching	O
yahoo	O
finance	O
data	O
from	O
matplotlib.finance	B-API
in	O
python	O

I	O
am	O
fetching	O
yahoo	O
finance	O
data	O
in	O
Python	O
through	O
this	O
interface	O
:	O

It	O
would	O
also	O
be	O
worth	O
looking	O
at	O
the	O
scatter	O
plot	O
documentation	O
at	O
#URL	O
#CODE	O

I	O
am	O
using	O
the	O
following	O
code	O
to	O
stitch	O
a	O
.png	O
into	O
a	O
scatter	O
plot	O
from	O
MATPLOTLIB	O
.	O

Now	O
I	O
want	O
to	O
create	O
a	O
scatter	O
plot	O
with	O
the	O
data	O
above	O
..	O

matplotlib	O
:	O
Understanding	O
and	O
changing	O
axis	O
labels	O
for	O
a	O
scatter	O
plot	O
updated	O
incrementally	O

I	O
have	O
a	O
script	O
that	O
generates	O
scatter	O
plots	O
for	O
data	O
being	O
generated	O
by	O
a	O
hardware	O
device	O
.	O

I	O
build	O
a	O
scatter	O
plot	O
using	O
matplotlib	O
and	O
python2.7	O

Build	O
a	O
scatter	O
plot	O
for	O
baz	O
based	O
on	O
the	O
x-axis	O
(	O
foo	O
)	O
and	O
y-axis	O
(	O
bar	O
)	O

It	O
is	O
a	O
normal	O
scatter	O
plot	O
.	O

Value	O
Error	O
with	O
color	O
array	O
when	O
slicing	O
values	O
for	O
scatter	O
plot	O

I	O
want	O
to	O
specify	O
the	O
frequency	O
of	O
markers	O
that	O
are	O
printed	O
in	O
my	O
scatter	O
plot	O
.	O

Regression	O
line	O
and	O
fitted	O
curve	O
for	O
scatter	O
plots	O
in	O
matplotlib	O

but	O
`	O
from	O
matplotlib.path	B-API
import	O
Path	B-API
`	O
throws	O
#CODE	O

The	O
Path	B-API
object	O
does	O
not	O
store	O
the	O
points	O
along	O
a	O
Bezier	O
curve	O
,	O
just	O
the	O
minimum	O
parameters	O
it	O
needs	O
.	O

Users	O
of	O
Path	B-API
objects	O
should	O
not	O
access	O
the	O
vertices	O
and	O
codes	O
arrays	O

The	O
trick	O
is	O
to	O
use	O
Path	B-API
and	O
PathPatch	B-API
.	O

This	O
allows	O
you	O
to	O
get	O
the	O
Matplotlib	O
Path	B-API
vertices	O
and	O
codes	O
in	O
the	O
projection	O
coordinates	O
which	O
you	O
can	O
then	O
convert	O
into	O
a	O
new	O
Path	B-API
.	O

I	O
was	O
playing	O
with	O
PathCollection	B-API
(	O
my	O
dyslexia	O
is	O
killing	O
me	O
switching	O
between	O
Path	B-API
and	O
Patch	O
)	O
,	O
and	O
if	O
I	O
can	O
get	O
a	O
unit	O
circle	O
drawn	O
and	O
I	O
can	O
apply	O
an	O
affine	O
transformation	O
to	O
it	O
,	O
then	O
I	O
think	O
it	O
should	O
work	O
,	O
as	O
it	O
doesn't	O
seem	O
to	O
inherently	O
fill	O
the	O
space	O
.	O

Thus	O
the	O
`	O
Spine	B-API
`	O
objects	O
are	O
in	O
question	O

You	O
can	O
use	O
the	O
`	O
set_position()	B-API
`	O
method	O
of	O
the	O
`	O
Spine	B-API
`	O
class	O
:	O
#CODE	O

You	O
mentioned	O
the	O
use	O
of	O
`	O
Locator	B-API
`	O
and	O
`	O
Formatter	B-API
`	O
objects	O
in	O
your	O
comment	O
.	O

You	O
need	O
to	O
call	O
remove	O
on	O
the	O
instance	O
of	O
the	O
`	O
Annotation	B-API
`	O
object	O
.	O

Using	O
Annotation	B-API
Instead	O
of	O
Ticklabels	O

What	O
is	O
the	O
difference	O
between	O
a	O
Text	B-API
instance	O
and	O
string	O
in	O
python	O
?	O

I	O
believe	O
the	O
anti-aliasing	O
of	O
Text	B-API
objects	O
is	O
up	O
to	O
the	O
font	O
engine	O
being	O
used	O
.	O

What	O
you	O
should	O
do	O
is	O
save	O
a	O
reference	O
to	O
the	O
first	O
`	O
Text	B-API
`	O
object	O
and	O
update	O
its	O
contents	O
by	O
calling	O
its	O
`	O
set_text()	B-API
`	O
method	O
.	O

There	O
is	O
a	O
references	O
to	O
the	O
Text	B-API
object	O
returned	O
by	O
the	O
original	O
setting	O
of	O
suptitle	B-API
in	O
figure.texts	O
.	O

I'm	O
having	O
a	O
problem	O
with	O
the	O
Text	B-API
object	O
that	O
matplotlib	O
use	O
to	O
represent	O
the	O
ticklabels	O
.	O

I	O
think	O
you	O
need	O
to	O
displace	O
the	O
`	O
Text	B-API
`	O
object	O
,	O
using	O
the	O
`	O
set_position	B-API
((	O
x	O
,	O
y	O
))`	O
method	O
.	O

This	O
includes	O
`	O
Text	B-API
`	O
objects	O
,	O
`	O
Line2D	B-API
`	O
objects	O
,	O
`	O
collection	O
`	O
objects	O
,	O
`	O
Patch	O
`	O
objects	O
...	O

Text	B-API
object	O
in	O
matplotlib	O
doesnt	O
respond	O
to	O
zooming	O
properly	O

After	O
drawing	O
a	O
matplotlib	O
Text	B-API
instance	O
and	O
then	O
interactively	O
panning	O
,	O
the	O
resulting	O
drawn	O
text	O
is	O
clipped	O
to	O
the	O
data	O
window	O
but	O
not	O
the	O
surrounding	O
bounding	O
box	O
.	O

Something	O
like	O
`	O
Text	B-API
(	O
2	O
,	O
0	O
,	O
u'Text	O
(	O
2	O
,	O
0	O
,	O
u	O
"	O
Text	B-API
(	O
0.4	O
,	O
u\	O
'	O
0.4	O
\	O
')")')`	O
.	O

`	O
plt.legend	B-API
`	O
returns	O
a	O
`	O
Legend	B-API
`	O
object	O
with	O
methods	O
that	O
allow	O
you	O
to	O
modify	O
the	O
appearance	O
of	O
the	O
legend	O
.	O

So	O
first	O
we'll	O
save	O
the	O
`	O
Legend	B-API
`	O
object	O
:	O
#CODE	O

In	O
practice	O
I	O
seem	O
to	O
end	O
up	O
mixing	O
them	O
both	O
myself	O
in	O
SW	O
;	O
it's	O
largely	O
a	O
matter	O
of	O
taste	O
whether	O
you	O
go	O
through	O
the	O
pyplot	B-API
API	O
or	O
access	O
the	O
objects	O
.	O
pyplot	B-API
is	O
certainly	O
very	O
convenient	O
although	O
as	O
you	O
want	O
to	O
do	O
more	O
complex	O
/	O
exotic	O
things	O
you'll	O
find	O
what	O
you	O
can	O
do	O
with	O
pyplot	B-API
alone	O
limited	O
and	O
you'll	O
need	O
to	O
get	O
to	O
know	O
at	O
least	O
the	O
full	O
API's	O
Axes	B-API
,	O
Figure	B-API
,	O
Legend	B-API
and	O
Path	B-API
objects	O
better	O
.	O

There	O
was	O
a	O
refactor	O
of	O
the	O
`	O
Legend	B-API
`	O
class	O
awhile	O
back	O
.	O

call	O
`	O
Legend.get_texts()	B-API
`	O
will	O
get	O
a	O
list	O
of	O
Text	B-API
object	O
in	O
the	O
legend	B-API
object	O
:	O
#CODE	O

Some	O
parameters	O
could	O
easily	O
be	O
read	O
from	O
the	O
`	O
Legend	B-API
`	O
object	O
,	O
others	O
(	O
like	O
`	O
title	O
`	O
,	O
`	O
fancybox	O
`)	O
required	O
some	O
'	O
artistics	O
'	O
.	O

42	O
from	O
matplotlib.legend	B-API
import	O
Legend	B-API

How	O
do	O
I	O
choose	O
the	O
optimum	O
width	O
for	O
a	O
matplotlib	O
Button	B-API
?	O

I	O
removed	O
`	O
color=axcolor	O
`	O
from	O
the	O
`	O
Button	B-API
`	O
call	O
;	O
and	O
I	O
added	O
a	O
`	O
plt.show()	B-API
`	O
before	O
the	O
event	O
connect	O
,	O
otherwise	O
a	O
figure	O
window	O
didn't	O
appear	O
for	O
me	O
(	O
neither	O
through	O
`	O
ipython	O
`	O
,	O
nor	O
with	O
`	O
python	O
`)	O
.	O

button	O
=	O
Button	B-API
(	O
ax=reset_axis	O
,	O
label=	O
'	O
Reset	O
'	O
,	O
color=	O
'	O
lightblue	O
'	O
,	O
hovercolor=	O
'	O
0.975	O
')	O

`	O
tbar.add_button	O
(	O
a	O
Button	B-API
object	O
);	O
`	O

For	O
your	O
buttons	O
to	O
work	O
,	O
you	O
need	O
to	O
keep	O
a	O
reference	O
to	O
the	O
`	O
Button	B-API
`	O
object	O
around	O
.	O

I	O
know	O
how	O
to	O
add	O
and	O
work	O
with	O
single	O
cursor	O
`	O
self.cursor	O
=	O
Cursor	B-API
(	O
self.static_canvas.Dataplot	O
,	O
useblit=True	O
,	O
color=	O
'	O
red	O
'	O
,	O
linewidth=2	O
)`	O
,	O
but	O
what	O
I	O
should	O
do	O
to	O
create	O
to	O
cursors	O
?	O

I	O
think	O
tillsten	O
is	O
right	O
--	O
study	O
how	O
the	O
[	O
`	O
Cursor	B-API
`	O
class	O
]	O
(	O
#URL	O
)	O
does	O
it	O
.	O

I've	O
checked	O
briefly	O
,	O
but	O
I	O
don't	O
know	O
how	O
to	O
modify	O
the	O
properties	O
of	O
an	O
`	O
Arc	B-API
`	O
instance	O
,	O
although	O
I'm	O
sure	O
it's	O
possible	O
.	O

You	O
could	O
also	O
try	O
passing	O
a	O
`	O
Arrow	B-API
`	O
instance	O
as	O
marker	O
,	O
but	O
I'm	O
not	O
sure	O
whether	O
that	O
works	O
.	O

Currently	O
,	O
I	O
don't	O
think	O
it	O
possible	O
as	O
the	O
`	O
Arrow	B-API
`	O
class	O
only	O
supports	O
`'	O
solid	O
'	O
|	O
'	O
dashed	O
'	O
|	O
'	O
dashdot	O
'	O
|	O
'	O
dotted	O
'`	O
four	O
different	O
linestyles	O
.	O

The	O
Node	B-API
class	O
has	O
the	O
coordinates	O
stored	O
as	O
members	O
(	O
x	O
and	O
y	O
)	O
,	O
as	O
well	O
as	O
index	O
.	O

You	O
can	O
scale	O
your	O
z	O
values	O
to	O
fit	O
this	O
range	O
with	O
Normalize	B-API
.	O

You	O
should	O
mention	O
the	O
`	O
Normalize	B-API
`	O
methods	O
here	O
as	O
well	O
.	O

Matplotlib	O
provides	O
the	O
class	O
`	O
Normalize	B-API
`	O
for	O
that	O
:	O
#CODE	O

Create	O
a	O
new	O
instance	O
of	O
`	O
Normalize	B-API
`	O
for	O
each	O
image	O
you	O
want	O
to	O
process	O
.	O

And	O
then	O
you	O
can	O
also	O
replicate	O
the	O
functionality	O
of	O
`	O
Normalize	B-API
`	O
(	O
since	O
you	O
seem	O
to	O
not	O
like	O
it	O
):	O
#CODE	O

Use	O
these	O
to	O
create	O
a	O
`	O
Normalize	B-API
`	O
instance	O
(	O
other	O
normalisation	O
classes	O
are	O
available	O
,	O
e.g.	O
log	O
scale	O
)	O
.	O

The	O
documentation	O
of	O
Normalize	B-API
might	O
be	O
a	O
bit	O
deceiving	O
here	O
:	O
`	O
process_value	O
`	O
is	O
a	O
function	O
which	O
is	O
only	O
used	O
for	O
preprocessing	O
(	O
and	O
static	O
)	O
.	O

I	O
have	O
several	O
questions	O
regarding	O
the	O
Normalize	B-API
class	O
in	O
Matplotlib	O
.	O

with	O
your	O
own	O
`	O
Normalize	B-API
`	O
function	O
.	O

This	O
might	O
be	O
why	O
they've	O
avoided	O
implementing	O
it	O
as	O
part	O
of	O
Normalize	B-API
.	O

matplotlib	O
:	O
can	O
I	O
create	O
AxesSubplot	O
objects	O
,	O
then	O
add	O
them	O
to	O
a	O
Figure	B-API
instance	O
?	O

Also	O
do	O
you	O
use	O
Figure	B-API
from	O
the	O
local	O
matplotlib	O
installation	O
or	O
not	O
?	O

Additionally	O
,	O
there	O
are	O
functions	O
from	O
the	O
pyplot	B-API
interface	O
and	O
there	O
are	O
methods	O
on	O
the	O
`	O
Figure	B-API
`	O
class	O
.	O

I'll	O
assume	O
in	O
the	O
following	O
that	O
`	O
fig	O
`	O
is	O
an	O
instance	O
of	O
a	O
`	O
Figure	B-API
`	O
:	O

Both	O
the	O
Figure	B-API
and	O
the	O
Axes	B-API
class	O
have	O
a	O
`	O
clear()	O
`	O
method	O
.	O

I	O
had	O
this	O
same	O
problem	O
,	O
and	O
it	O
was	O
caused	O
by	O
calling	O
`	O
show()	O
`	O
on	O
the	O
Figure	B-API
object	O
instead	O
of	O
the	O
pyplot	B-API
object	O
.	O

It	O
got	O
wrapped	O
up	O
in	O
a	O
subclass	O
of	O
Figure	B-API
,	O
which	O
also	O
got	O
level-of-detail	O
functionality	O
and	O
context	O
menus	O
.	O

I	O
have	O
an	O
external	O
function	O
which	O
returns	O
a	O
Figure	B-API
object	O
,	O
and	O
in	O
this	O
situation	O
,	O
each	O
Figure	B-API
object	O
is	O
composed	O
of	O
exactly	O
one	O
Axes	B-API
object	O
.	O

While	O
a	O
search	O
did	O
lead	O
me	O
to	O
see	O
that	O
pyplot.figure()	B-API
is	O
the	O
development	O
team's	O
recommended	O
instantiation	O
technique	O
,	O
it	O
doesn't	O
change	O
the	O
question	O
:	O
is	O
there	O
any	O
way	O
to	O
do	O
Axes	B-API
/	O
Figure	B-API
copy	O
construction	O
and	O
Figure	B-API
construction	O
via	O
composition	O
of	O
copied	O
Axes	B-API
?	O

A	O
reference	O
to	O
it	O
isn't	O
stored	O
in	O
the	O
`	O
Figure	B-API
`	O
object	O
,	O
but	O
is	O
stored	O
in	O
the	O
`	O
Canvas	O
`	O
object	O
so	O
you	O
can	O
destroy	O
a	O
window	O
via	O
#CODE	O

Removing	O
the	O
`	O
frameon=False	O
`	O
option	O
from	O
`	O
f	O
=	O
Figure	B-API
(	O
figsize	O
=(	O
12	O
,	O
5	O
)	O
,	O
dpi=100	O
,	O
frameon=False	O
)`	O
solved	O
the	O
issue	O
.	O

I	O
used	O
the	O
Bar	B-API
class	O
to	O
plot	O
length	O
of	O
videos	O
vs	O
views	O
which	O
are	O
the	O
x	O
and	O
y	O
values	O
of	O
the	O
tuples	O
.	O

Animation	B-API
will	O
not	O
work	O
on	O
inplace	O
(	O
or	O
inline	O
?	O
)	O
on	O
notebook	O
.	O

By	O
artifacts	O
,	O
I	O
now	O
understand	O
to	O
mean	O
you	O
are	O
creating	O
a	O
second	O
`	O
Animation	B-API
`	O
object	O
and	O
what	O
you	O
get	O
is	O
both	O
of	O
them	O
running	O
in	O
parallel	O
(	O
which	O
I	O
am	O
not	O
sure	O
what	O
I	O
expect	O
to	O
happen	O
there	O
)	O
.	O

by	O
`	O
ax	O
`	O
I	O
mean	O
the	O
current	O
`	O
Axis	B-API
`	O
object	O
,	O
which	O
you	O
were	O
getting	O
at	O
via	O
`	O
gca	B-API
`	O
.	O

Your	O
legend	B-API
command	O
is	O
using	O
the	O
markers	O
,	O
not	O
the	O
lines	O
as	O
inputs	O
by	O
using	O
`	O
plot	O
[	O
0	O
]`	O
.	O

`	O
Axes	B-API
`	O
objects	O
know	O
about	O
things	O
like	O
tick	O
location	O
and	O
labels	O
and	O
the	O
display	O
range	O
(	O
which	O
it	O
does	O
by	O
knowing	O
about	O
`	O
Axis	B-API
`	O
object	O
,	O
but	O
that	O
is	O
getting	O
even	O
more	O
into	O
the	O
weeds	O
)	O
.	O

Use	O
Axis	B-API
method	O
`	O
set_xscale	B-API
`	O
or	O
`	O
set_yscale	B-API
`	O
.	O

`	O
ax.set_xticks()	B-API
`	O
is	O
a	O
method	O
of	O
the	O
`	O
Axes	B-API
`	O
object	O
,	O
whilst	O
`	O
matplotlib.ticker.FixedLocator	B-API
`	O
is	O
an	O
object	O
which	O
is	O
used	O
with	O
the	O
`	O
Axis	B-API
`	O
object	O
(	O
`	O
Axes	B-API
`	O
is	O
basically	O
the	O
whole	O
graph	O
,	O
whilst	O
`	O
Axis	B-API
`	O
is	O
just	O
one	O
of	O
the	O
(	O
two	O
)	O
axis	O
(	O
x	O
or	O
y	O
)	O
.	O

This	O
is	O
not	O
particularly	O
well	O
documented	O
,	O
but	O
`	O
Polygon	B-API
`	O
objects	O
have	O
a	O
pair	O
of	O
methods	O
`	O
get_xy	B-API
`	O
and	O
`	O
set_xy	B-API
`	O
.	O

In	O
particular	O
,	O
if	O
/	O
when	O
there	O
are	O
so	O
many	O
circles	O
for	O
the	O
figure	O
to	O
become	O
connected	O
,	O
the	O
`	O
for	O
polygon	O
in	O
polygons	O
:	O
`	O
fails	O
with	O
a	O
`	O
TypeError	O
:	O
'	O
Polygon	B-API
'	O
object	O
is	O
not	O
iterable	O
`	O
.	O

Just	O
use	O
the	O
`	O
Polygon	B-API
`	O
or	O
`	O
Rectangle	B-API
`	O
classes	O
:	O
#CODE	O

As	O
you	O
can	O
see	O
,	O
the	O
edge	O
is	O
center-positioned	O
along	O
the	O
border	O
of	O
the	O
domain	O
of	O
the	O
Rectangle	B-API
object	O
,	O
and	O
so	O
bleeds	O
into	O
this	O
domain	O
.	O

You	O
can	O
do	O
this	O
by	O
overplotting	O
a	O
Rectangle	B-API
patch	O
on	O
the	O
cell	O
that	O
you	O
would	O
want	O
to	O
highlight	O
.	O

Currently	O
I	O
use	O
the	O
`	O
add_patch	B-API
(	O
Rectangle	B-API
(	O
...	O
))`	O
,	O
but	O
it	O
does	O
not	O
fit	O
really	O
well	O
.	O

Unfortunately	O
it	O
seems	O
that	O
the	O
'	O
Rectangle	B-API
'	O
object	O
has	O
no	O
attribute	O
'	O
set_bottom	O
'	O
.	O

You	O
can	O
acces	O
ALL	O
the	O
properties	O
of	O
a	O
`	O
Tick	B-API
`	O
object	O
using	O
this	O
approach	O
:	O
#CODE	O

Fortunately	O
you	O
can	O
update	O
figures	O
you've	O
moved	O
to	O
where	O
you	O
want	O
them	O
pretty	O
easily	O
,	O
by	O
using	O
the	O
object	O
interface	O
specifically	O
,	O
and	O
updating	O
the	O
Axes	B-API
object	O
without	O
creating	O
a	O
new	O
figure	O
.	O

(	O
You	O
can	O
also	O
always	O
find	O
this	O
data	O
inside	O
the	O
`	O
Axes	B-API
`	O
object	O
if	O
you	O
know	O
where	O
to	O
look	O
.	O
)	O

By	O
deferring	O
the	O
expense	O
of	O
drawing	O
you	O
can	O
greatly	O
improve	O
the	O
performance	O
of	O
functions	O
that	O
make	O
many	O
calls	O
to	O
`	O
Figure	B-API
`	O
and	O
`	O
Axes	B-API
`	O
methods	O
.	O

`	O
Figure.add_subplot()	B-API
`	O
returns	O
an	O
`	O
Axes	B-API
`	O
instance	O
,	O
and	O
`	O
pyplot.subplots()	B-API
`	O
returns	O
an	O
`	O
Axis	B-API
`	O
object	O
as	O
second	O
output	O
parameter	O
.	O

As	O
a	O
side	O
note	O
,	O
it	O
is	O
better	O
to	O
pass	O
`	O
Axes	B-API
`	O
objects	O
into	O
your	O
function	O
than	O
create	O
them	O
(	O
implicitly	O
)	O
internally	O
.	O

Here	O
,	O
what	O
you	O
have	O
done	O
is	O
capture	O
the	O
`	O
Axes	B-API
`	O
instance	O
that	O
is	O
returned	O
from	O
`	O
add_subplot()	B-API
`	O
.	O

If	O
I	O
create	O
an	O
`	O
Axes	B-API
`	O
object	O
in	O
`	O
matplotlib	O
`	O
and	O
mutate	O
it	O
(	O
i.e.	O
by	O
plotting	O
some	O
data	O
)	O
and	O
then	O
I	O
call	O
a	O
function	O
without	O
passing	O
my	O
`	O
Axes	B-API
`	O
object	O
to	O
that	O
function	O
then	O
that	O
function	O
can	O
still	O
mutate	O
my	O
`	O
Axes	B-API
`	O
.	O

Pass	O
multiple	O
matplotlib	O
Axes	B-API
objects	O
from	O
generator	O
function	O
and	O
display	O
them	O

The	O
`	O
transform	B-API
`	O
in	O
this	O
case	O
is	O
a	O
`	O
BboxTransformTo	O
`	O
object	O
,	O
which	O
:	O

You	O
can	O
use	O
the	O
`	O
transform	B-API
`	O
keyword	O
:	O
#CODE	O

But	O
when	O
I	O
checked	O
the	O
source	O
code	O
of	O
draw_networkx_nodes	O
draw_networkx	O
,	O
I	O
realized	O
that	O
it	O
is	O
not	O
a	O
straight	O
forward	O
task	O
as	O
the	O
draw	B-API
function	O
stores	O
the	O
positions	O
(	O
nodes	O
and	O
edges	O
)	O
in	O
a	O
numpy	O
array	O
,	O
send	O
it	O
to	O
the	O
ax.scatter	B-API
function	O
of	O
matplotlib	O
(	O
sourcecode	O
)	O
which	O
is	O
a	O
bit	O
hard	O
to	O
manipulate	O
without	O
messing	O
something	O
up	O
.	O

This	O
simply	O
calls	O
the	O
draw	B-API
method	O
of	O
the	O
figure	O
periodically	O
.	O

Then	O
I	O
just	O
added	O
a	O
signal	O
to	O
the	O
custom	O
version	O
and	O
overrode	O
the	O
draw	B-API
method	O
.	O

EDIT	O
:	O
I'm	O
super	O
blind	O
,	O
sorry	O
for	O
that	O
,	O
you're	O
calling	O
the	O
draw	B-API
method	O
,	O
however	O
it	O
is	O
a	O
good	O
idea	O
to	O
add	O
*	O
args	O
and	O
**	O
kwargs	O
to	O
any	O
overriden	O
methods	O
..	O
try	O
that	O
,	O
and	O
perhaps	O
call	O
FancyBboxPatch.draw	O
at	O
the	O
end	O
of	O
overriden	O
method	O

I'm	O
also	O
panning	O
and	O
zooming	O
into	O
this	O
figure	O
,	O
and	O
have	O
been	O
using	O
the	O
draw	B-API
method	O
to	O
show	O
the	O
new	O
perspectives	O
from	O
zooming	O
in	O
(	O
using	O
set_xlim	B-API
and	O
set_ylim	B-API
)	O
and	O
from	O
panning	O
(	O
drag_pan	B-API
and	O
start_pan	B-API
)	O
.	O

I	O
would	O
use	O
`	O
ax.autoscale	B-API
(	O
enable=False	O
)`	O
before	O
your	O
call	O
to	O
`	O
scatter	B-API
`	O
.	O

You	O
can	O
perhaps	O
loop	O
into	O
your	O
`	O
AxesSubplot	O
`	O
objects	O
and	O
call	O
`	O
autoscale	B-API
`	O
passing	O
the	O
`	O
axis	O
`	O
parameter	O
:	O
#CODE	O

@USER	O
-	O
If	O
you'd	O
like	O
to	O
rescale	O
the	O
axes	B-API
,	O
call	O
`	O
ax.autoscale()	B-API
`	O
every	O
time	O
you	O
remove	O
a	O
point	O
.	O

Python	O
:	O
Add	O
x-y	O
margins	B-API
automatically	O
with	O
autoscale	B-API
(	O
pyplot	B-API
)	O

Ahh	O
,	O
it's	O
the	O
call	O
to	O
`	O
autoscale	B-API
`	O
that	O
I'm	O
missing	O
.	O

The	O
trick	O
is	O
at	O
the	O
end	O
,	O
in	O
the	O
custom	O
refresh	B-API
method	O
!	O

For	O
what	O
you're	O
wanting	O
to	O
do	O
,	O
you'd	O
be	O
far	O
better	O
off	O
using	O
annotate	B-API
.	O

It's	O
quite	O
simple	O
to	O
do	O
manually	O
with	O
`	O
annotate	B-API
`	O
.	O

If	O
you're	O
wanting	O
to	O
adjust	O
vertical	O
alignment	O
,	O
horizontal	O
alignment	O
,	O
etc	O
,	O
just	O
add	O
those	O
as	O
arguments	O
to	O
`	O
annotate	B-API
`	O
(	O
e.g.	O
`	O
horizontalalignment=	O
'	O
right	O
'`	O
or	O
equivalently	O
`	O
ha=	O
'	O
right	O
'`)	O

It's	O
quite	O
simple	O
to	O
do	O
manually	O
with	O
`	O
annotate	B-API
`	O
.	O

You	O
can	O
use	O
the	O
annotate	B-API
command	O
to	O
place	O
text	O
annotations	O
at	O
any	O
x	O
and	O
y	O
values	O
you	O
want	O
.	O

+1	O
Just	O
as	O
a	O
side	O
note	O
,	O
annotate	B-API
has	O
"	O
offseting	O
the	O
annotations	O
a	O
little	O
"	O
built-in	O
.	O

While	O
there's	O
nothing	O
wrong	O
with	O
Ofri's	O
answer	O
,	O
`	O
annotate	B-API
`	O
is	O
intended	O
especially	O
for	O
this	O
purpose	O
:	O
#CODE	O

Just	O
use	O
`	O
annotate	B-API
`	O
and	O
specify	O
axis	O
coordinates	O
.	O

It	O
is	O
also	O
possible	O
to	O
make	O
an	O
arrow	O
with	O
text	O
,	O
using	O
the	O
annotate	B-API
method	O
.	O

The	O
closest	O
thing	O
I	O
have	O
been	O
able	O
to	O
find	O
while	O
searching	O
here	O
is	O
the	O
annotate	B-API
command	O
,	O
but	O
that	O
appears	O
to	O
create	O
a	O
fixed	O
label	O
on	O
the	O
plot	O
.	O

`	O
plt.annotate	B-API
(	O
'	O
Something	O
'	O
,	O
(	O
0	O
,	O
0	O
)	O
,	O
(	O
0	O
,	O
-20	O
)	O
,	O
xycoords=	O
'	O
axes	B-API
fraction	O
'	O
,	O
textcoords=	O
'	O
offset	O
points	O
'	O
,	O
va=	O
'	O
top	O
')`	O

@USER	O
I'm	O
not	O
sure	O
why	O
we	O
have	O
to	O
explicitly	O
call	O
`	O
draw	B-API
`	O
.	O

The	O
`	O
boxplot	B-API
`	O
function	O
only	O
plots	O
quartiles	O
(	O
0	O
,	O
25	O
,	O
50	O
,	O
75	O
,	O
100	O
)	O
.	O

Is	O
there	O
any	O
way	O
I	O
can	O
extract	O
these	O
values	O
for	O
use	O
in	O
my	O
downstream	O
code	O
from	O
the	O
boxplot	B-API
object	O
?	O

I	O
am	O
plotting	O
a	O
non-normal	O
distribution	O
using	O
boxplot	B-API
and	O
interested	O
in	O
finding	O
out	O
about	O
outliers	O
using	O
boxplot	B-API
function	O
of	O
matplotlib	O
.	O

You	O
should	O
use	O
the	O
`	O
hist	B-API
`	O
function	O
.	O

An	O
similar	O
example	O
of	O
such	O
plot	O
is	O
"	O
hist	B-API
(	O
x	O
,	O
orientation=	O
'	O
horizontal	O
')"	O
.	O

I	O
need	O
to	O
use	O
the	O
`	O
hist	B-API
`	O
function	O
,	O
I	O
have	O
looked	O
elsewhere	O
on	O
this	O
site	O
but	O
I	O
haven't	O
found	O
anything	O
.	O

I	O
tried	O
doing	O
hist	B-API
(	O
x	O
/	O
x.sum()	O
)	O
but	O
that	O
reduce	O
the	O
values	O
of	O
the	O
numbers	O
in	O
the	O
x	O
axis	O
and	O
does	O
not	O
change	O
their	O
frequency	O
,	O
so	O
the	O
y-axis	O
is	O
unchanged	O

How	O
can	O
I	O
prevent	O
the	O
labels	O
of	O
`	O
xticks	B-API
`	O
from	O
overlapping	O
with	O
the	O
labels	O
of	O
`	O
yticks	B-API
`	O
when	O
using	O
`	O
hist	B-API
`	O
(	O
or	O
other	O
plotting	O
commands	O
)	O
in	O
matplotlib	O
?	O

An	O
easy	O
way	O
to	O
do	O
this	O
is	O
to	O
add	O
`	O
0j	O
`	O
to	O
the	O
argument	O
of	O
the	O
`	O
sqrt	B-API
`	O
,	O
like	O
this	O
,	O
`	O
sqrt	B-API
(	O
1+0j-	O
(	O
1	O
/	O
x	O
)	O
**2	O
)`	O
.	O

You	O
need	O
to	O
set	O
the	O
new	O
coordinates	O
of	O
the	O
datapoints	O
in	O
the	O
internal	O
`	O
_ofsets3d	O
`	O
variable	O
of	O
the	O
`	O
Line3DCollection	O
`	O
object	O
returned	O
by	O
the	O
`	O
scatter	B-API
`	O
function	O
.	O

You	O
can	O
use	O
`	O
scatter	B-API
`	O
for	O
this	O
,	O
but	O
that	O
requires	O
having	O
numerical	O
values	O
for	O
your	O
`	O
key1	O
`	O
,	O
and	O
you	O
won't	O
have	O
a	O
legend	B-API
,	O
as	O
you	O
noticed	O
.	O

The	O
`	O
scatter	B-API
`	O
and	O
`	O
hist	B-API
`	O
commands	O
really	O
expect	O
`	O
x	O
`	O
and	O
`	O
y	O
`	O
to	O
be	O
1D	O
arrays	O
.	O

I'm	O
wondering	O
if	O
it	O
is	O
possible	O
to	O
have	O
individual	O
alpha	O
values	O
for	O
each	O
point	O
to	O
be	O
plotted	O
using	O
the	O
scatter	B-API
function	O
of	O
Matplotlib	O
.	O

The	O
problem	O
happens	O
when	O
I	O
call	O
the	O
scatter	B-API
function	O
.	O

If	O
you	O
are	O
trying	O
to	O
create	O
an	O
animation	O
,	O
look	O
in	O
to	O
the	O
`	O
animation	B-API
`	O
module	O
of	O
matplotlib	O
,	O
it	O
takes	O
care	O
of	O
a	O
lot	O
of	O
the	O
details	O
for	O
you	O
.	O

Apparently	O
,	O
the	O
"	O
Animation	B-API
"	O
class	O
of	O
Matplotlib	O
runs	O
the	O
animation	O
in	O
a	O
separate	O
thread	O
.	O

It	O
simply	O
don't	O
use	O
the	O
Animation	B-API
class	O
and	O
builds	O
its	O
own	O
animation	O
from	O
crash	O
.	O

I	O
think	O
`	O
axis	O
([	O
xo	O
,	O
x1	O
,	O
y0	O
,	O
y1	O
])`	O
is	O
in	O
terms	O
of	O
proportion	O
of	O
the	O
Figure	B-API
,	O
not	O
the	O
data	O
transform	O
.	O

I	O
used	O
the	O
scatter	B-API
function	O
and	O
plotted	O
the	O
points	O
,	O
but	O
the	O
surface	O
function	O
is	O
not	O
working	O
(	O
the	O
window	O
is	O
empty	O
)	O
.	O

The	O
solution	O
I	O
found	O
for	O
this	O
involves	O
using	O
Normalize	B-API
to	O
make	O
a	O
normalised	O
colour	O
list	O
based	O
on	O
the	O
relevant	O
data	O
,	O
mapping	O
it	O
to	O
a	O
ScalarMappable	B-API
,	O
and	O
using	O
that	O
to	O
set	O
the	O
face	O
colour	O
and	O
c	O
limits	O
on	O
each	O
frame	O
of	O
the	O
animation	O
.	O

But	O
because	O
all	O
of	O
the	O
functionality	O
relies	O
on	O
the	O
hook	O
,	O
when	O
the	O
canvas	O
is	O
finally	O
shown	O
I	O
presume	O
Python's	O
garbage	O
collection	O
has	O
removed	O
the	O
Animation	B-API
instance	O
---	O
since	O
it	O
was	O
never	O
assigned	O
to	O
a	O
variable	O
---	O
and	O
therefore	O
the	O
animation	O
can	O
never	O
be	O
started	O
.	O

Notice	O
`	O
xytext	O
=	O
(	O
0	O
,	O
0	O
)`	O
means	O
no	O
offset	O
,	O
and	O
omitting	O
`	O
arrowprops	O
`	O
causes	O
`	O
plt.annotate	B-API
`	O
to	O
not	O
draw	O
an	O
arrow	O
.	O
