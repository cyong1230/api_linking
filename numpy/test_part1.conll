Note	O
that	O
the	O
diagonal	N
is	O
always	O
zero	O
since	O
`	O
mahalanobis	U
(	O
x	O
,	O
x	O
)`	O
equals	O
zero	O
for	O

possible	O
duplicate	O
of	O
[	O
NumPy	O
min	B-API
/	O
max	B-API
in-place	O
assignment	O
]	O
(	O
#URL	O
)	O

Once	O
the	O
tree	O
structure	O
has	O
been	O
built	O
,	O
go	O
back	O
and	O
collect	O
all	O
the	O
branches	O
and	O
leaves	O
into	O
the	O
array	O
structure	O
and	O
by	O
definition	O
,	O
they	O
will	O
be	O
unique	N
.	O

I	O
wrote	O
the	O
following	O
code	O
but	O
the	O
output	O
only	O
contains	O
the	O
ids	N
(	O
single	O
column	O
)	O
.	O

Maximum	O
is	O
always	O
bigger	O
than	O
the	O
minimum	O
(	O
more	O
to	O
the	O
right	O
on	O
a	O
1d	O
axis	O
,	O
not	O
by	O
absolute	N
value	O
)	O
.	O

Note	O
that	O
`	O
unq_count	O
`	O
doesn't	O
count	O
the	O
occurrences	O
of	O
the	O
last	O
unique	N
item	O
,	O
because	O
that	O
is	O
not	O
needed	O
to	O
split	O
the	O
index	O
array	O
.	O

If	O
yes	O
,	O
you	O
can	O
use	O
the	O
Linux	O
terminal	O
to	O
strip	N
quotes	O
from	O
the	O
ends	O
of	O
the	O
rows	O
quickly	O
.	O

The	O
append	B-API
method	O
for	O
a	O
numpy	O
array	O
returns	O
a	O
copy	O
of	O
the	O
array	O
with	O
new	O
items	O
added	O
to	O
the	O
end	O
.	O

I	O
want	O
to	O
get	O
the	O
norm	B-API
of	O
this	O
array	O
using	O
numpy	O
.	O

The	O
only	O
problem	O
here	O
is	O
that	O
I	O
think	O
it	O
will	O
append	N
directly	O
to	O
the	O
column	O
,	O
when	O
I	O
would	O
prefer	O
it	O
to	O
append	N
to	O
a	O
new	O
column	O
.	O

You	O
don't	O
need	O
to	O
import	O
string	O
,	O
and	O
you	O
don't	O
need	O
to	O
loop	O
through	O
all	O
the	O
lines	O
and	O
append	N
text	O
or	O
count	O
the	O
characters	O
.	O

The	O
transpose	N
of	O
the	O
transpose	N
of	O
a	O
matrix	O
==	O
that	O
matrix	O
,	O
or	O
,	O
[	O
A^T	O
]	O
^T	O
==	O
A	O
.	O

Currently	O
I	O
am	O
looping	O
through	O
the	O
arrays	O
and	O
using	O
numpy.dstack	B-API
to	O
stack	N
the	O
1000	O
arrays	O
into	O
a	O
rather	O
large	O
3d	O
array	O
...	O
and	O
then	O
will	O
calculate	O
the	O
mean	O
across	O
the	O
3rd	O
(	O
?	O
)	O
dimension	O
.	O

If	O
you	O
strip	N
all	O
these	O
out	O
and	O
just	O
call	O
lapack	O
in	O
your	O
for	O
loop	O
(	O
since	O
you	O
already	O
know	O
the	O
dimensions	O
of	O
your	O
matrix	O
and	O
maybe	O
know	O
that	O
it's	O
real	O
,	O
not	O
complex	O
)	O
,	O
things	O
run	O
MUCH	O
faster	O
(	O
Note	O
that	O
I've	O
made	O
my	O
array	O
larger	O
)	O
:	O
#CODE	O

First	O
,	O
you	O
have	O
a	O
binomial	N
response	O
:	O
having	O
or	O
not	O
having	O
a	O
particular	O
behavior	O
.	O

The	O
call	O
to	O
`	O
np.sqrt	B-API
`	O
,	O
which	O
is	O
a	O
Python	O
function	O
call	O
,	O
is	O
killing	O
your	O
performance	O
You	O
are	O
computing	O
the	O
square	O
root	O
of	O
scalar	O
floating	O
point	O
value	O
,	O
so	O
you	O
should	O
use	O
the	O
`	O
sqrt	B-API
`	O
function	O
from	O
the	O
C	O
math	O
library	O
.	O

This	O
would	O
call	O
the	O
function	O
`	O
np.loadtxt	B-API
`	O
which	O
would	O
load	O
the	O
file	O
`	O
GPBUSD1d.txt	O
'`	O
and	O
transpose	N
(	O
"	O
unpack	O
")	O
it	O
.	O

You	O
can't	O
change	O
the	O
typing	O
of	O
the	O
array	O
in-place	O
(	O
unless	O
I'm	O
grossly	O
mistaken	O
)	O
,	O
but	O
you	O
can	O
floor	B-API
.	O

Finally	O
I	O
just	O
transpose	N
the	O
dataframe	O
to	O
get	O
ids	N
as	O
rows	O
and	O
categories	O
as	O
columns	O
.	O

The	O
following	O
way	O
of	O
obtaining	O
the	O
unique	N
elements	O
in	O
all	O
sub-arrays	O
is	O
very	O
fast	O
:	O
#CODE	O

You	O
can't	O
use	O
the	O
numpy	O
reshape	B-API
for	O
a	O
simple	O
reason	O
:	O
you	O
have	O
data	O
duplicity	O
in	O
your	O
original	O
array	O
(	O
time	O
and	O
positions	O
)	O
and	O
not	O
in	O
the	O
result	O
you	O
want	O
.	O

So	O
it	O
does	O
not	O
make	O
much	O
sense	O
to	O
me	O
to	O
reshape	N
it	O
to	O
a	O
"	O
1d-matrix	O
"	O
.	O

Now	O
create	O
5-bit	O
bitstrings	O
from	O
each	O
integer	O
and	O
join	N
them	O
together	O
:	O
#CODE	O

It	O
would	O
probably	O
be	O
just	O
as	O
much	O
work	O
to	O
translate	N
the	O
top	O
Matlab	O
routine	O
from	O
Maurits	O
.	O

In	O
the	O
particular	O
case	O
of	O
your	O
example	O
,	O
where	O
your	O
unique	N
values	O
are	O
sequential	O
integers	O
,	O
you	O
can	O
use	O
`	O
find_objects	U
`	O
directly	O
.	O

axis=1	O
refers	O
to	O
working	O
on	O
rows	O
in	O
this	O
2d	O
case	O
(	O
axis=0	O
,	O
in	O
contrast	O
,	O
would	O
be	O
getting	O
you	O
the	O
max	B-API
in	O
each	O
column	O
)	O

There	O
are	O
many	O
other	O
`	O
ufunc	U
`	O
,	O
and	O
other	O
iteration	O
modes	O
-	O
`	O
accumulate	B-API
`	O
,	O
`	O
reduceat	B-API
`	O
.	O

All	O
diagonal	N
elements	O
will	O
be	O
of	O
the	O
form	O
`	O
s_i	O
**	O
2	O
/	O
s_i	O
**	O
2	O
==	O
1	O
`	O
.	O

@USER	O
In	O
the	O
example	O
above	O
,	O
I	O
get	O
the	O
following	O
error	O
:	O
Non-broadcastable	O
operand	O
with	O
shape	O
(	O
100	O
)	O
doesn't	O
match	O
the	O
broadcast	B-API
shape	O
(	O
100,100	O
)	O

is	O
calculated	O
such	O
that	O
all	O
but	O
the	O
diagonal	N
#CODE	O

To	O
compute	O
the	O
number	O
of	O
unique	N
elements	O
in	O
a	O
numpy	O
array	O
,	O
you	O
can	O
use	O
`	O
unique	B-API
(	O
x	O
)	O
.size	O
`	O
or	O
`	O
len	U
(	O
unique	B-API
(	O
x	O
))`	O
(	O
see	O
`	O
numpy.unique	B-API
`	O
)	O
.	O

Or	O
would	O
that	O
basically	O
require	O
implementing	O
the	O
outer	N
loop	O
in	O
Cython	O
?	O

For	O
a	O
tensor	O
it	O
is	O
not	O
clear	O
how	O
to	O
define	O
an	O
inverse	O
or	O
a	O
transpose	N
.	O

Second	O
,	O
you	O
are	O
doing	O
transpose	B-API
the	O
hard	O
way	O
.	O

Where	O
does	O
log	B-API
(	O
b	O
,	O
2	O
)	O
come	O
from	O
?	O

(	O
The	O
values	O
in	O
the	O
corners	O
correspond	O
to	O
the	O
diagonal	N
elements	O
.	O
)	O

I	O
tried	O
using	O
the	O
scipy.stat	U
module	O
by	O
creating	O
my	O
numbers	O
with	O
`	O
np.random.normal	B-API
`	O
,	O
since	O
it	O
only	O
takes	O
data	O
and	O
not	O
stat	O
values	O
like	O
mean	O
and	O
std	N
dev	O
(	O
is	O
there	O
any	O
way	O
to	O
use	O
these	O
values	O
directly	O
)	O
.	O

The	O
asymptotic	O
complexity	O
of	O
both	O
of	O
the	O
`	O
matrix_rank	B-API
`	O
and	O
`	O
det	B-API
`	O
calls	O
are	O
therefore	O
O	O
(	O
n^3	O
)	O
,	O
the	O
complexity	O
of	O
LU	O
decomposition	O
.	O

I	O
think	O
the	O
np.std()	B-API
is	O
just	O
universal	O
std	B-API
.	O

Golub	O
and	O
Van	O
Loan	O
also	O
provide	O
a	O
way	O
of	O
storing	O
a	O
matrix	O
in	O
diagonal	N
dominant	O
form	O
.	O

I	O
see	O
no	O
reason	O
why	O
`	O
numpy	O
`	O
would	O
need	O
to	O
make	O
a	O
copy	O
for	O
an	O
operation	O
like	O
this	O
,	O
as	O
long	O
as	O
it	O
does	O
the	O
necessary	O
checks	O
for	O
overlaps	O
(	O
though	O
of	O
course	O
as	O
others	O
have	O
noted	O
,	O
`	O
resize	B-API
`	O
may	O
itself	O
have	O
to	O
allocate	O
a	O
new	O
block	O
of	O
memory	O
)	O
.	O

I	O
found	O
another	O
stack	N
question	O
about	O
this	O
here	O
,	O
but	O
I	O
am	O
not	O
entirely	O
sure	O
how	O
it	O
was	O
resolved	O
,	O
I'm	O
still	O
a	O
little	O
confused	O
.	O

Maybe	O
`	O
floor	B-API
(	O
arange	B-API
(	O
0	O
,	O
10	O
,	O
0.1	O
))`	O
?	O

In	O
python	O
,	O
I	O
would	O
like	O
to	O
convolve	N
the	O
two	O
matrices	O
along	O
the	O
second	O
axis	O
only	O
.	O

`	O
view	B-API
`	O
is	O
basically	O
taking	O
your	O
two	O
coordinates	O
as	O
a	O
single	O
variable	O
that	O
can	O
be	O
used	O
to	O
find	O
the	O
unique	N
coordinates	O
.	O

Keep	O
in	O
mind	O
that	O
machine	O
precision	O
for	O
a	O
32-bit	O
double	O
is	O
~	O
10^-16	O
,	O
which	O
will	O
be	O
an	O
absolute	N
limiting	O
factor	O
.	O

Also	O
,	O
if	O
there	O
is	O
then	O
I	O
could	O
just	O
append	N
to	O
the	O
b	O
and	O
c	O
arrays	O
each	O
time	O
instead	O
of	O
overwriting	O
and	O
starting	O
from	O
scratch	O
each	O
loop	O
.	O

Use	O
`	O
multiprocessing.Process	U
(	O
target	O
=	O
somefunc	O
,	O
args	O
=	O
(	O
sa	O
,	O
)`	O
(	O
and	O
`	O
start	U
`	O
,	O
maybe	O
`	O
join	B-API
`)	O
to	O
call	O
`	O
somefunc	O
`	O
in	O
a	O
separate	O
process	O
,	O
passing	O
the	O
shared	O
array	O
.	O

Take	O
a	O
look	O
a	O
the	O
concatenate	B-API
function	O
.	O

Unlike	O
Joe	O
Kington's	O
answer	O
,	O
the	O
benefit	O
of	O
this	O
is	O
that	O
you	O
don't	O
need	O
to	O
know	O
the	O
original	O
shape	O
of	O
the	O
data	O
in	O
the	O
`	O
.mat	O
`	O
file	O
,	O
i.e.	O
no	O
need	O
to	O
reshape	N
upon	O
reading	O
in	O
.	O

but	O
I	O
think	O
,	O
finding	O
the	O
local	O
max	N
can	O
be	O
simplified	O
to	O
:	O
#CODE	O

@USER	O
`	O
swapaxes	B-API
`	O
seemed	O
to	O
be	O
indistinguishable	O
from	O
`	O
transpose	B-API
(	O
0	O
,	O
2	O
,	O
1	O
)`	O
.	O

Do	O
gradient	B-API
actually	O
compute	O
really	O
a	O
gradient	N
?	O

I	O
would	O
suggest	O
to	O
first	O
program	O
it	O
with	O
`	O
np.nditer	B-API
`	O
and	O
then	O
translate	N
it	O
into	O
C	O
.	O

As	O
you	O
can	O
see	O
,	O
using	O
the	O
join	B-API
function	O
on	O
the	O
list	O
(	O
`	O
binary_list	O
`)	O
works	O
properly	O
,	O
but	O
on	O
the	O
equivalent	O
numpy	O
array	O
(	O
`	O
binary_split_array	O
`)	O
it	O
doesn't	O
:	O
we	O
can	O
see	O
the	O
string	O
returned	O
is	O
only	O
72	O
characters	O
long	O
instead	O
of	O
80	O
.	O

@USER	O
.B	O
.	O
the	O
above	O
question	O
is	O
significantly	O
different	O
from	O
mine	O
;	O
it	O
asks	O
for	O
both	O
min	B-API
and	O
max	B-API
,	O
and	O
it	O
is	O
for	O
2D	O
matrix	O

This	O
will	O
join	N
the	O
rows	O
and	O
write	O
them	O
to	O
a	O
new	O
csv	O
:	O
#CODE	O

The	O
reason	O
I	O
have	O
`	O
-det	O
(	O
mat	N
)`	O
in	O
the	O
energy	O
function	O
is	O
because	O
the	O
simulated	O
annealing	O
algorithm	O
does	O
minimization	O
.	O

Also	O
is	O
`	O
x	O
`	O
unique	N
?	O

Pandas	O
append	B-API
filtered	O
row	O
to	O
another	O
DataFrame	Y

Again	O
,	O
the	O
code	O
notes	O
that	O
set	O
of	O
combinations	O
is	O
not	O
unique	N
;	O
but	O
it	O
does	O
have	O
a	O
unique	N
subset	O
,	O
namely	O
[[	O
2	O
3	O
]	O
,	O
[	O
0	O
1	O
]]	O
,	O
which	O
as	O
you	O
just	O
revealed	O
,	O
you	O
do	O
consider	O
a	O
valid	O
combination	O
.	O

That	O
concatenate	B-API
action	O
should	O
be	O
pretty	O
fast	O
.	O

If	O
you	O
want	O
to	O
pass	O
in	O
the	O
transpose	N
,	O
you'll	O
need	O
to	O
set	O
`	O
rowvar	O
`	O
to	O
zero	O
.	O

You	O
can	O
override	O
this	O
behavior	O
by	O
using	O
the	O
arguments	O
`	O
vmin	O
`	O
and	O
`	O
vmax	O
`	O
(	O
or	O
`	O
norm	N
`)	O
of	O
`	O
imshow	O
`	O
.	O

@USER	O
,	O
`	O
cs	O
`	O
is	O
sorted	O
and	O
`	O
searchsorted()	B-API
`	O
exploits	O
that	O
to	O
do	O
a	O
binary	O
search	O
-	O
only	O
`	O
O	O
(	O
log	B-API
(	O
len	U
(	O
weights	O
)))`	O
comparisons	O
are	O
needed	O
.	O

Think	O
`	O
flatten	B-API
`	O
without	O
the	O
copy	O
.	O

In	O
your	O
case	O
it	O
looks	O
like	O
the	O
weight	O
arrays	O
will	O
have	O
the	O
same	O
dimension	O
as	O
'	O
A	O
'	O
,	O
so	O
you	O
reshape	N
them	O
accordingly	O
and	O
multiply	O
dx	O
and	O
dy	O
by	O
their	O
individual	O
weight	O
vectors	O
.	O

Does	O
this	O
mean	O
the	O
standard	O
error	O
of	O
the	O
gradient	N
or	O
intercept	O
?	O

Also	O
,	O
the	O
algo	O
has	O
a	O
lot	O
of	O
matrices	O
manipulation	O
(	O
fft	B-API
,	O
filters	O
,	O
etc	O
.	O
)	O
,	O
so	O
using	O
numpy	O
/	O
scipy	O
should	O
result	O
in	O
faster	O
run	O
time	O
.	O

You	O
can	O
broadcast	N
that	O
into	O
an	O
array	O
using	O
expressions	O
,	O
for	O
example	O
#CODE	O

If	O
I	O
use	O
the	O
above	O
test	O
on	O
the	O
absolute	N
values	O
of	O
the	O
angles	O
to	O
be	O
tested	O
,	O
everything	O

The	O
returned	O
gradient	N
hence	O
has	O

"	O
In	O
the	O
first	O
case	O
the	O
gradient	N
is	O
1	O
mV	O
/	O
ms	O
,	O
in	O
the	O
second	O
case	O
it	O
is	O
50	O
mV	O
/	O
ms	O
.	O

If	O
True	O
,	O
uses	O
the	O
old	O
behavior	O
from	O
Numeric	O
,	O
(	O
correlate	B-API
(	O
a	O
,	O
v	O
)	O
==	O
correlate	B-API
(	O
v	O
,	O
a	O
)	O
,	O
and	O
the	O
conjugate	O
is	O
not	O
taken	O
for	O
complex	O
arrays	O
)	O
.	O

Why	O
don't	O
you	O
just	O
compress	N
the	O
files	O
with	O
the	O
built-in	O
`	O
gzip	O
`	O
module	O
?	O

So	O
you	O
need	O
to	O
write	O
some	O
function	O
that	O
convert	O
a	O
poly	N
parameters	O
array	O
to	O
a	O
latex	O
string	O
,	O
here	O
is	O
an	O
example	O
:	O
#CODE	O

In	O
your	O
example	O
,	O
the	O
square	O
root	O
is	O
calculated	O
by	O
evaluating	O
the	O
the	O
module	O
and	O
the	O
argument	O
of	O
your	O
complex	O
number	O
(	O
essentially	O
via	O
the	O
log	B-API
function	O
,	O
which	O
returns	O
log	B-API
(	O
module	O
)	O
+	O
i	O
phase	O
)	O
.	O

I	O
am	O
trying	O
to	O
run	O
hstack	B-API
to	O
join	N
a	O
column	O
of	O
integer	O
values	O
to	O
a	O
list	O
of	O
columns	O
created	O
by	O
a	O
TF-IDF	O
(	O
so	O
I	O
can	O
eventually	O
use	O
all	O
of	O
these	O
columns	O
/	O
features	O
in	O
a	O
classifier	O
)	O
.	O

How	O
to	O
pass	O
these	O
`	O
norm	N
`	O
and	O
`	O
cmap	O
`	O
parameters	O
in	O
matplotlib	O
to	O
`	O
plt.show	Y
`	O
or	O
`	O
imshow()	Y
`	O
?	O

Forget	O
about	O
the	O
C	O
stack	N
,	O
numpy	O
objects	O
can't	O
use	O
it	O
.	O

You	O
can	O
use	O
the	O
append	B-API
function	O
as	O
he	O
has	O
defined	O
.	O

This	O
can	O
be	O
particularly	O
tricky	O
when	O
trying	O
to	O
append	N
to	O
a	O
numpy	O
array	O
quickly	O
.	O

I	O
have	O
a	O
question	O
regarding	O
to	O
the	O
`	O
fft	B-API
`	O
and	O
`	O
ifft	B-API
`	O
functions	O
.	O

So	O
for	O
now	O
,	O
I	O
just	O
changed	O
the	O
max	B-API
(	O
z	O
)	O
to	O
a	O
number	O
that	O
I	O
know	O
is	O
the	O
max	B-API
(	O
1567	O
)	O
.	O

The	O
`	O
add	B-API
`	O
operation	O
does	O
not	O
do	O
the	O
same	O
thing	O
as	O
`	O
join	B-API
`	O
.	O

You	O
don't	O
specify	O
`	O
x	O
`	O
or	O
`	O
y	O
`	O
,	O
and	O
your	O
`	O
mat	N
[:	O
,	O
i+1	O
]`	O
indexing	O
will	O
not	O
work	O
with	O
a	O
structured	O
array	O
.	O

This	O
is	O
because	O
in	O
some	O
cases	O
it's	O
not	O
just	O
NaNs	O
and	O
1s	O
,	O
but	O
other	O
integers	O
,	O
which	O
gives	O
a	O
std	N
>	O
0	O
.	O
