OLS	O
solution	O
using	O
pinv	B-API
/	O
svd	B-API
#CODE	O

The	O
bad	O
days	O
are	O
eliminated	O
,	O
and	O
the	O
good	O
ones	N
are	O
kept	O
.	O

From	O
this	O
I've	O
gathered	O
that	O
`	O
len()	U
`	O
will	O
return	O
the	O
number	O
of	O
rows	O
,	O
so	O
I	O
can	O
always	O
us	O
the	O
transpose	B-API
,	O
`	O
len	U
(	O
A.T	O
)`	O
,	O
for	O
the	O
number	O
of	O
columns	O
.	O

shape	O
mismatch	O
:	O
value	O
array	O
of	O
shape	Y
(	O
1000	O
,	O
)	O
could	O
not	O
be	O
broadcast	N
to	O
indexing	O
result	O
of	O
shape	Y
(	O
1000,3,255,255	O
)	O

@USER	O
Well	O
in	O
this	O
case	O
,	O
`	O
searchsorted	B-API
`	O
is	O
basically	O
looking	O
for	O
places	O
or	O
indices	N
where	O
elements	O
from	O
`	O
message	O
`	O
exists	O
in	O
the	O
keys	O
of	O
`	O
codes	O
`	O
.	O

@USER	O
--	O
I	O
had	O
a	O
hard	O
time	O
remembering	O
how	O
`	O
translate	B-API
`	O
and	O
`	O
maketrans	U
`	O
work	O
for	O
quite	O
a	O
while	O
too	O
,	O
but	O
I've	O
gotten	O
used	O
to	O
it	O
.	O

Edit	O
:	O
if	O
you're	O
using	O
a	O
version	O
of	O
numpy	O
>	O
=	O
1.8.0	O
,	O
then	O
`	O
np.linalg.eigvals	B-API
`	O
operates	O
over	O
the	O
last	O
two	O
dimensions	O
of	O
whatever	O
array	O
you	O
hand	O
it	O
,	O
so	O
if	O
you	O
reshape	N
your	O
input	O
to	O
an	O
`	O
(	O
n_subarrays	O
,	O
nrows	O
,	O
ncols	O
)`	O
array	O
you'll	O
only	O
have	O
to	O
call	O
`	O
eigvals	B-API
`	O
once	O
:	O
#CODE	O

`	O
reshape	B-API
`	O
returns	O
a	O
view	O
of	O
the	O
original	O
array	O
,	O
not	O
a	O
copy	O
,	O
so	O
the	O
conversion	O
to	O
3D	O
only	O
requires	O
altering	O
the	O
`	O
shape	N
`	O
and	O
`	O
strides	O
`	O
attributes	O
of	O
the	O
array	O
,	O
without	O
having	O
to	O
copy	O
any	O
of	O
the	O
actual	O
data	O
.	O

sum	N
this	O
new	O
array	O
along	O
particular	O
axes	O
;	O
and	O
then	O
maybe	O

Calling	O
`	O
reshape	B-API
`	O
returns	O
a	O
view	O
,	O
so	O
it	O
doesn't	O
incur	O
any	O
big	O
copying	O
costs	O
or	O
anything	O
like	O
that	O
.	O

so	O
at	O
some	O
point	O
in	O
the	O
execution	O
it	O
will	O
max	N
my	O
memory	O
.	O

If	O
`	O
len	U
(	O
vals	O
)`	O
is	O
too	O
long	O
,	O
do	O
you	O
want	O
to	O
truncate	N
`	O
vals	O
`	O
?	O
and	O
if	O
`	O
len	U
(	O
vals	O
)`	O
is	O
too	O
short	O
,	O
do	O
you	O
want	O
to	O
fill	O
the	O
rest	O
of	O
the	O
array	O
with	O
`	O
0	O
`	O
s	O
?	O

Note	O
that	O
extension	O
to	O
even	O
higher	O
combinatorics	O
should	O
be	O
trivial	O
,	O
along	O
the	O
lines	O
presented	O
;	O
but	O
keep	O
an	O
eye	N
on	O
the	O
n	O
used	O
in	O
that	O
case	O
.	O

These	O
functions	O
return	O
a	O
list	O
,	O
which	O
I	O
convert	O
to	O
a	O
numpy	O
array	O
and	O
then	O
sum	N
over	O
.	O

Can	O
it	O
be	O
because	O
of	O
the	O
many	O
zeros	N
in	O
the	O
initial	O
table	O
?	O

I	O
also	O
understand	O
that	O
sum	B-API
(	O
A	O
,	O
axis=1	O
)	O
will	O
sum	N
each	O
row	O
.	O

But	O
what	O
I	O
really	O
want	O
to	O
do	O
,	O
is	O
to	O
bin	O
`	O
array	O
[:	O
,	O
1	O
]`	O
by	O
day	O
(	O
as	O
derived	O
by	O
the	O
unix	O
timestamps	O
in	O
array	O
[:	O
,	O
0	O
])	O
,	O
and	O
plot	O
these	O
as	O
a	O
stacked	O
histogram	N
,	O
with	O
each	O
(	O
colored	O
)	O
stack	N
representing	O
a	O
day	O
.	O

It's	O
interesting	O
to	O
see	O
that	O
when	O
I	O
go	O
back	O
to	O
`	O
nloop=1000	O
`	O
,	O
`	O
nreps=3	O
`	O
I	O
actually	O
see	O
a	O
slightly	O
*	O
greater	O
*	O
rate	N
of	O
cache	O
misses	O
for	O
the	O
row	O
sum	N
(	O
17%	O
vs	O
13%	O
)	O
,	O
even	O
though	O
it's	O
faster	O
than	O
the	O
column	O
sum	N
.	O

You	O
can	O
concatenate	N
arrays	O
in	O
`	O
numpy	O
`	O
.	O

If	O
you	O
are	O
100%	O
sure	O
that	O
l2	O
would	O
only	O
be	O
one	O
column	O
then	O
you	O
can	O
reshape	N
that	O
array	O
to	O
make	O
it	O
one	O
dimensional	O
before	O
doing	O
the	O
subtraction	O
.	O

You	O
won't	O
be	O
able	O
to	O
create	O
a	O
2D	O
array	O
that	O
way	O
,	O
and	O
@USER	O
method	O
of	O
returning	O
a	O
1D	O
array	O
that	O
you	O
reshape	N
afterwards	O
is	O
a	O
sure	O
go	O
.	O

I	O
have	O
a	O
square	O
matrix	O
A	O
(	O
could	O
be	O
any	O
size	O
)	O
and	O
I	O
want	O
to	O
take	O
the	O
upper	O
triangular	O
part	O
and	O
place	O
those	O
values	O
in	O
an	O
array	O
without	O
the	O
values	O
below	O
the	O
center	O
diagonal	N
(	O
k=0	O
)	O
.	O

You	O
can	O
mimic	O
this	O
behavior	O
with	O
a	O
simple	O
function	O
to	O
flatten	N
a	O
list	O
:	O
#CODE	O

So	O
`	O
popt	O
`	O
,	O
according	O
to	O
the	O
documentation	O
,	O
returns	O
*	O
"	O
Optimal	O
values	O
for	O
the	O
parameters	O
so	O
that	O
the	O
sum	N
of	O
the	O
squared	O
error	O
of	O
f	O
(	O
xdata	O
,	O
popt	O
)	O
-	O
ydata	O
is	O
minimized	O
"	O
.	O

And	O
I'd	O
like	O
indices	N
`	O
i	O
`	O
such	O
that	O
,	O
#CODE	O

But	O
,	O
`	O
resize	B-API
`	O
looks	O
like	O
it	O
just	O
might	O
be	O
the	O
thing	O
I'm	O
looking	O
for	O
...	O

`	O
rfft	B-API
`	O
,	O
apart	O
from	O
repeated	O
terms	O
excluded	O
,	O
and	O
an	O
almost	O
2x	O
speed-up	O
,	O
returns	O
the	O
exact	O
same	O
you	O
would	O
get	O
from	O
`	O
fft	B-API
`	O
.	O

Plus	O
,	O
if	O
I	O
have	O
4	O
dimensions	O
,	O
I	O
thought	O
I	O
should	O
have	O
4	O
eigenvalues	O
and	O
not	O
150	O
like	O
the	O
eig	B-API
gives	O
me	O
.	O

If	O
I	O
run	O
your	O
code	O
to	O
generate	O
`	O
d	O
`	O
and	O
`	O
dx	O
`	O
with	O
`	O
eig	B-API
`	O
I	O
get	O
the	O
following	O
:	O
#CODE	O

In	O
other	O
words-	O
it	O
is	O
not	O
just	O
taking	O
a	O
min	N
or	O
max	N
.	O

D	O
[	O
I+1	O
,	O
J+1	O
]	O
=	O
map	Y
(	O
norm	N
,	O
x	O
[	O
I	O
]	O
-y	O
[	O
J	O
])	O
+	O
np.minimum	B-API
(	O
np.minimum	B-API
(	O
D	O
[	O
I	O
,	O
J	O
]	O
,	O
D	O
[	O
I	O
,	O
J+1	O
])	O
,	O
D	O
[	O
I+1	O
,	O
J	O
])	O
?	O

`	O
dot	B-API
`	O
just	O
has	O
tighter	O
code	O
for	O
a	O
specific	O
combination	O
of	O
dimensions	O
.	O

numpy	O
sum	B-API
does	O
not	O
agree	O

Since	O
you	O
are	O
only	O
adding	O
many	O
`	O
1	O
`	O
s	O
you	O
can	O
convert	O
`	O
diff	N
`	O
to	O
`	O
bool	O
`	O
:	O
#CODE	O

It	O
isn't	O
mathematically	O
possible	O
to	O
represent	O
0	O
on	O
a	O
log	N
scale	O
,	O
so	O
the	O
first	O
value	O
will	O
have	O
to	O
either	O
be	O
masked	O
or	O
clipped	O
to	O
a	O
very	O
small	O
positive	O
number	O
.	O

possible	O
duplicate	O
of	O
[	O
Efficiently	O
count	O
the	O
number	O
of	O
occurrences	O
of	O
unique	N
subarrays	O
in	O
NumPy	O
?	O
]	O
(	O
#URL	O
)	O

Or	O
you	O
could	O
mask	O
the	O
x	O
value	O
as	O
well	O
,	O
so	O
the	O
indices	N
were	O
consistent	O
between	O
x	O
and	O
y	O
#CODE	O

Here	O
the	O
`	O
outer	B-API
`	O
method	O
of	O
the	O
`	O
multiply	B-API
`	O
ufunc	Y
is	O
used	O
to	O
create	O
the	O
new	O
20x20	O
array	O
.	O

I	O
have	O
a	O
3D	O
numpy	O
array	O
consisting	O
of	O
1's	O
and	O
zeros	N
defining	O
open	O
versus	O
filled	O
space	O
in	O
a	O
porous	O
solid	O
(	O
it's	O
currently	O
a	O
numpy	O
Int64	O
array	O
)	O
.	O

You	O
are	O
attempting	O
to	O
broadcast	N
a	O
4-D	O
array	O
together	O
with	O
a	O
3-D	O
array	O
.	O

Scipy	O
NDimage	O
correlate	N
:	O
unbearably	O
slow	O

I	O
know	O
that	O
I	O
can	O
reshape	N
the	O
array	O
to	O
a	O
100	O
x	O
2	O
array	O
of	O
grid	O
points	O
:	O
#CODE	O

You	O
probably	O
could	O
get	O
`	O
append	B-API
`	O
to	O
work	O
,	O
but	O
it	O
just	O
does	O
a	O
step	O
by	O
step	O
concatenate	N
,	O
which	O
is	O
slower	O
.	O

This	O
produces	O
a	O
random	O
permutation	N
of	O
each	O
column's	O
indices	N
.	O

As	O
it	O
happens	O
,	O
the	O
histogram	N
is	O
enough	O
for	O
the	O
former	O
.	O

I	O
see	O
how	O
the	O
symmetry	O
of	O
the	O
trace	O
lets	O
you	O
replace	O
the	O
final	O
`	O
dot	B-API
`	O
.	O

In	O
that	O
question	O
,	O
I	O
sought	O
to	O
sum	N
values	O
in	O
a	O
numpy	O
structured	O
array	O
based	O
on	O
multiple	O
criteria	O
,	O
including	O
matches	O
in	O
a	O
list	O
.	O

Assuming	O
I	O
understand	O
you	O
,	O
and	O
you're	O
looking	O
for	O
the	O
indices	N
where	O
either	O
the	O
element	O
is	O
True	O
or	O
the	O
next	O
element	O
is	O
True	O
,	O
you	O
can	O
take	O
advantage	O
of	O
`	O
shift	U
`	O
and	O
use	O
#CODE	O

to	O
delete	O
the	O
lines	O
that	O
had	O
zeros	N
in	O
them	O
!	O

Fill	O
scipy	O
/	O
numpy	O
matrix	O
based	O
on	O
indices	N
and	O
values	O

It	O
looks	O
like	O
a	O
vector	O
product	O
followed	O
by	O
a	O
sum	N
along	O
the	O
resulting	O
array	O
.	O

The	O
trick	O
is	O
that	O
this	O
convolve	B-API
function	O
can	O
be	O
used	O
in-place	O
so	O
the	O
double	O
for	O
loop	O
:	O
#CODE	O

But	O
this	O
reshape	B-API
should	O
produce	O
a	O
`	O
(	O
n	O
,	O
1	O
,	O
1	O
)`	O
array	O
,	O
not	O
your	O
`	O
(	O
1	O
,	O
1	O
,	O
1	O
,...	O
)`	O
array	O
.	O

For	O
an	O
extreme	O
example	O
,	O
consider	O
a	O
sequence	O
that	O
consists	O
of	O
9	O
zeros	N
followed	O
by	O
the	O
result	O
of	O
a	O
coin	O
toss	O
,	O
9	O
zeros	N
and	O
another	O
coin	O
toss	O
,	O
etc	O
.	O

If	O
so	O
then	O
`	O
np.array	B-API
(	O
a	O
)`	O
is	O
a	O
2d	O
array	O
,	O
and	O
you	O
can	O
sum	N
over	O
`	O
axis=1	O
`	O
.	O

I	O
am	O
trying	O
to	O
create	O
a	O
lat	O
/	O
lon	O
grid	O
that	O
contains	O
an	O
array	O
of	O
found	O
indices	N
where	O
two	O
conditions	O
are	O
met	O
for	O
a	O
lat	O
/	O
lon	O
combination	O
.	O

This	O
NAMBE	O
is	O
the	O
absolute	N
difference	O
between	O
a	O
base	O
vector	O
and	O
another	O
vector	O
,	O
divided	O
by	O
the	O
base	O
vector	O
and	O
multiplied	O
by	O
a	O
hundred	O
,	O
in	O
pseudo-code	O
notation	O
:	O
#CODE	O

this	O
my	O
code	O
to	O
and	O
i	O
want	O
to	O
use	O
histogram	N
data	O
to	O
plot	O
scatter	O
where	O
y	O
axis	O
is	O
counts	O
center	O
from	O
the	O
histogram	N
,	O
is	O
there	O
any	O
direct	O
command	O
or	O
way	O
to	O
do	O
this	O
?	O

Please	O
compile	O
with	O
`	O
cython	O
-a	O
`	O
,	O
then	O
show	O
us	O
the	O
C	O
code	O
that	O
the	O
`	O
a	O
[	O
0	O
]	O
+=	O
sum	N
`	O
line	O
turns	O
into	O
.	O

The	O
revised	O
question	O
is	O
still	O
a	O
duplicate	O
,	O
see	O
[	O
this	O
question	O
]	O
(	O
#URL	O
)	O
,	O
and	O
[	O
this	O
question	O
]	O
(	O
#URL	O
)	O
for	O
finding	O
the	O
indices	N
.	O

ValueError	O
:	O
operands	O
could	O
not	O
be	O
broadcast	N
together	O
with	O
different	O
shapes	O
in	O
numpy	O
?	O

There	O
are	O
thousands	O
of	O
numbers	O
below	O
the	O
ones	N
shown	O
here	O
.	O

Assuming	O
you	O
want	O
to	O
align	O
all	O
the	O
arrays	O
to	O
the	O
left	O
,	O
and	O
pad	O
to	O
the	O
right	O
with	O
zeros	N
,	O
then	O
you	O
could	O
first	O
find	O
the	O
maximum	O
length	O
with	O
#CODE	O

How	O
to	O
do	O
the	O
same	O
If	O
I	O
want	O
to	O
apply	O
norm	N
column-wise	O
to	O
a	O
matrix	O
?	O

The	O
easiest	O
approach	O
is	O
to	O
reshape	N
to	O
data	O
to	O
a	O
long	O
format	O
using	O
`	O
.stack	Y
`	O
,	O
which	O
can	O
be	O
be	O
passed	O
straight	O
into	O
rolling	O
mean	O
.	O

It's	O
pretty	O
low-level	O
,	O
and	O
mostly	O
focused	O
on	O
how	O
to	O
address	O
the	O
more	O
difficult	O
problem	O
of	O
how	O
to	O
pass	O
C++	O
data	O
to	O
and	O
from	O
NumPy	O
without	O
copying	O
,	O
but	O
here's	O
how	O
you'd	O
do	O
a	O
copied	O
std	N
::	O
vector	O
return	O
with	O
that	O
:	O
#CODE	O

`	O
std	N
=	O
RMS	O
(	O
data	O
-	O
mean	O
)`	O
.	O

This	O
generalized	O
diagonal	N
would	O
be	O
defined	O
as	O
those	O
elements	O
of	O
the	O
array	O
whose	O
0th	O
and	O
2nd	O
index	O
coincide	O
,	O
and	O
would	O
have	O
shape	O
(	O
3	O
,	O
3	O
,	O
7	O
)	O
.	O

I	O
have	O
a	O
given	O
array	O
`	O
[	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
1	O
,	O
1	O
,	O
2	O
,	O
1	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
0	O
,	O
1	O
,	O
0	O
,	O
1	O
,	O
2	O
,	O
1	O
,	O
0	O
,	O
2	O
,	O
3	O
`]	O
(	O
arbitrary	O
elements	O
from	O
0-5	O
)	O
and	O
I	O
want	O
to	O
have	O
a	O
counter	O
for	O
the	O
occurence	O
of	O
zeros	N
in	O
a	O
row	O
.	O

To	O
see	O
the	O
benefits	O
of	O
this	O
,	O
you	O
need	O
to	O
use	O
`	O
z	O
,	O
p	O
,	O
k	O
=	O
butter	O
(	O
output=	O
'	O
zpk	O
')`	O
and	O
then	O
work	O
with	O
poles	O
and	O
zeros	N
instead	O
of	O
numerator	O
and	O
denominator	O
.	O

In	O
that	O
case	O
you	O
would	O
"	O
extrapolate	O
"	O
zeros	N
to	O
the	O
left	O
and	O
the	O
right	O
.	O

can	O
numpy	O
interpret	O
column	O
of	O
indices	N
like	O
matlab	O
does	O

To	O
get	O
the	O
diagonal	N
elements	O
you	O
can	O
get	O
their	O
indices	N
with	O
`	O
np.triu_indices	B-API
`	O
(	O
or	O
,	O
for	O
the	O
lower	O
triangle	O
,	O
`	O
np.tril_indices	B-API
`)	O
and	O
then	O
index	O
by	O
them	O
.	O

The	O
question	O
states	O
that	O
the	O
input	O
array	O
is	O
of	O
shape	O
`	O
(	O
128	O
,	O
36	O
,	O
8)	O
`	O
and	O
we	O
are	O
interested	O
in	O
finding	O
unique	N
subarrays	O
of	O
length	O
`	O
8	O
`	O
in	O
the	O
last	O
dimension	O
.	O

What	O
does	O
work	O
,	O
however	O
is	O
nesting	O
append	B-API
and	O
concatenate	B-API
#CODE	O

(	O
`	O
b	O
`	O
will	O
be	O
broadcast	N
along	O
(	O
?	O
)	O
the	O
first	O
axis	O
)	O
#CODE	O

As	O
he	O
points	O
out	O
,	O
the	O
`	O
[	O
0	O
]	O
[	O
1	O
]`	O
element	O
is	O
what	O
you'd	O
want	O
for	O
`	O
cov	B-API
(	O
a	O
,	O
b	O
)`	O
.	O

returns	O
`	O
1	O
`	O
,	O
making	O
the	O
sum	N
not	O
commutative	O
!	O

But	O
as	O
I	O
have	O
a	O
log	N
of	O
values	O
(	O
10000+	O
)	O
,	O
this	O
will	O
be	O
quite	O
slow	O
.	O

@USER	O
-	O
good	O
point	O
.	O
anyway	O
,	O
`	O
diff	B-API
`	O
works	O
on	O
python	O
lists	O
too	O
.	O

It	O
will	O
also	O
work	O
if	O
they	O
are	O
both	O
arrays	O
that	O
can	O
be	O
broadcast	N
.	O

It's	O
column	O
stack	N
that	O
requires	O
equal	O
length	O
strings	O
.	O

In	O
the	O
end	O
it	O
is	O
usually	O
not	O
too	O
complicated	O
,	O
especially	O
if	O
you	O
use	O
[	O
`	O
mgrid	B-API
`]	O
(	O
#URL	O
)	O
or	O
similar	O
to	O
get	O
the	O
indices	N
.	O

The	O
absolute	N
error	O
will	O
be	O
at	O
most	O
1	O
/	O
2	O
ULP	O
,	O
2	O
-150	O
.	O

AttributeError	O
:	O
'	O
Add	O
'	O
object	O
has	O
no	O
attribute	O
'	O
log	N
'	O
Python	O

Or	O
,	O
you	O
could	O
initialize	O
an	O
array	O
of	O
all	O
zeros	N
if	O
you	O
know	O
the	O
size	O
of	O
the	O
array	O
ahead	O
of	O
time	O
.	O

Are	O
you	O
checking	O
shape	O
or	O
number	O
of	O
nonzero	N
values	O
?	O

Something	O
like	O
`	O
eigvals	N
,	O
eigvecs	O
=	O
la.eigh	O
(	O
mat	B-API
)`	O
`	O
principal	O
=	O
eigvecs	O
[:	O
,	O
eigvals.argmax()	O
]`	O
`	O
if	O
(	O
principal	O
>	O
=	O
0	O
)	O
.all()	O
or	O
(	O
pricipal	O
<=	O
0	O
)	O
.all()	O
:	O
print	O
'	O
all	O
the	O
same	O
'`	O
?	O

I	O
also	O
want	O
bins	O
to	O
have	O
a	O
width	O
of	O
.5	O
so	O
that	O
I	O
can	O
have	O
a	O
bin	O
from	O
10.5	O
to	O
11	O
or	O
24	O
to	O
24.5	O
etc	O
...	O
because	O
otherwise	O
,	O
python	O
outputs	O
the	O
histogram	N
with	O
the	O
bins	O
random	O
and	O
undetermined	O
.	O

Maximum	O
is	O
always	O
bigger	O
than	O
the	O
minimum	O
(	O
more	O
to	O
the	O
right	O
on	O
a	O
1d	O
axis	O
,	O
not	O
by	O
absolute	N
value	O
)	O
.	O

should	O
give	O
the	O
sum	N
of	O
the	O
columns	O
.	O

Suppose	O
,	O
You	O
wanna	O
check	O
how	O
many	O
times	O
you	O
will	O
get	O
six	O
if	O
you	O
roll	N
dice	O
10	O
times	O
.	O

With	O
this	O
option	O
,	O
the	O
result	O
will	O
broadcast	N
correctly	O

Do	O
you	O
mean	O
`	O
indices	N
=	O
np.where	B-API
(	O
a	O
==	O
a.max()	O
)`	O
in	O
line	O
3	O
?	O

The	O
problem	O
I	O
have	O
much	O
later	O
on	O
in	O
the	O
code	O
is	O
that	O
if	O
one	O
of	O
these	O
parameters	O
isn't	O
in	O
the	O
ASCII	O
file	O
it	O
throws	O
errors	O
up	O
so	O
I	O
have	O
to	O
keep	O
adding	O
in	O
ones	N
I	O
don't	O
need	O
.	O

`	O
append	B-API
`	O
adds	O
them	O
to	O
the	O
end	O
of	O
the	O
list	O
,	O
which	O
is	O
exactly	O
what	O
you	O
want	O
.	O

I	O
have	O
two	O
3dim	O
numpy	O
matrices	O
and	O
I	O
want	O
to	O
do	O
a	O
dot	N
product	O
according	O
to	O
one	O
axis	O
without	O
using	O
a	O
loop	O
in	O
theano	O
.	O

you	O
have	O
at	O
most	O
4	O
in	O
that	O
dimension	O
(	O
see	O
your	O
reshape	N
line	O
)	O
,	O
so	O
the	O
index	O
it	O
will	O
count	O
are	O
0	O
and	O
2	O
(	O
1	O
and	O
3	O
are	O
skipped	O
,	O
and	O
3	O
is	O
the	O
last	O
element	O
)	O
.	O

Once	O
we	O
have	O
the	O
indices	N
to	O
sort	O
`	O
data	O
`	O
,	O
to	O
get	O
a	O
sorted	O
copy	O
of	O
the	O
array	O
it	O
is	O
faster	O
to	O
use	O
the	O
indices	N
than	O
to	O
re-sort	O
the	O
array	O
:	O
#CODE	O

I	O
hope	O
this	O
will	O
help	O
you	O
perform	O
your	O
transpose	N
and	O
column-wise	O
operations	O

It	O
is	O
better	O
to	O
specify	O
that	O
I'm	O
looking	O
for	O
something	O
that	O
performs	O
the	O
log-sum-exp	O
trick	O
,	O
doing	O
a	O
simply	O
succession	O
of	O
exp	N
elem-wise	O
,	O
summing	O
the	O
rows	O
and	O
doing	O
a	O
log	N
elem-wise	O
is	O
trivial	O
in	O
`	O
scipy.sparse	O
`	O
.	O

Scipy	O
uses	O
`	O
int32	O
`	O
to	O
store	O
`	O
indptr	O
`	O
and	O
`	O
indices	N
`	O
for	O
the	O
sparse	O
formats	O
.	O

But	O
not	O
able	O
to	O
plot	O
it	O
as	O
a	O
graph	O
(	O
something	O
like	O
a	O
histogram	N
)	O
...	O
that	O
is	O
the	O
problem	O
.	O

It	O
gave	O
error	O
testing	O
doesnot	O
have	O
attribute	O
append	N
as	O
its	O
of	O
None	O
Type	O
.	O

In	O
both	O
cases	O
,	O
you	O
can	O
access	O
individual	O
elements	O
by	O
indices	N
,	O
like	O
`	O
R	O
[	O
0	O
]`	O
(	O
which	O
would	O
give	O
you	O
a	O
specific	O
object	O
,	O
a	O
`	O
np.void	O
`	O
,	O
that	O
still	O
gives	O
you	O
the	O
possibility	O
to	O
access	O
the	O
fields	O
separately	O
)	O
,	O
or	O
by	O
slices	O
`	O
R	O
[	O
1	O
:	O
-1	O
]`	O
...	O

I	O
think	O
you	O
can	O
have	O
a	O
sum	N
over	O
a	O
sliding	O
window	O
(	O
or	O
a	O
rolling	O
window	O
)	O
or	O
a	O
mean	O
over	O
a	O
sliding	O
window	O
.	O

I	O
got	O
your	O
point	O
and	O
I	O
find	O
it	O
more	O
logical	O
,	O
but	O
when	O
trying	O
the	O
code	O
you've	O
suggested	O
to	O
get	O
rid	O
of	O
the	O
second	O
error	O
I	O
got	O
another	O
error	O
:	O
`	O
AttributeError	O
:	O
flatten	B-API
`	O

`	O
dot	B-API
`	O
does	O
many	O
things	O
under	O
the	O
hood	O
,	O
it	O
is	O
apparent	O
that	O
`	O
np.dot	B-API
(	O
A	O
,	O
x	O
)`	O
is	O
not	O
calling	O
BLAS	O
and	O
is	O
somehow	O
defaulting	O
over	O
to	O
numpy's	O
internal	O
GEMM	O
routine	O
.	O

Below	O
is	O
some	O
code	O
which	O
uses	O
a	O
callback	O
to	O
print	O
out	O
the	O
current	O
azimuthal	O
and	O
elevation	O
angles	O
,	O
as	O
well	O
as	O
append	N
them	O
to	O
a	O
list	O
for	O
further	O
use	O
later	O
.	O

It's	O
super	O
alex	O
,	O
here	O
to	O
answer	O
NumPy	O
questions	O
in	O
the	O
blink	O
of	O
an	O
eye	N
:)	O

Your	O
solution	O
of	O
searching	O
the	O
eigenvalues	O
for	O
the	O
ones	N
you	O
want	O
seems	O
plausible	O
enough	O
.	O

If	O
d	O
is	O
larger	O
than	O
8	O
or	O
9	O
,	O
then	O
bases	O
will	O
be	O
sufficiently	O
long	O
that	O
you	O
probably	O
would	O
be	O
better	O
off	O
going	O
with	O
the	O
other	O
version	O
using	O
the	O
dot	N
product	O
.	O

Interesting	O
,	O
in	O
R	O
`	O
Reduce	O
(	O
'	O
+	O
'	O
,	O
s	O
)`	O
yields	O
the	O
same	O
sum	U
as	O
in	O
python	O
.	O

I'm	O
not	O
sure	O
which	O
indices	N
i	O
need	O
to	O
change	O
to	O
achieve	O
the	O
minimum	O
and	O
not	O
the	O
maximum	O
values	O
.	O

The	O
dimension	O
of	O
`	O
result	O
`	O
has	O
been	O
set	O
earlier	O
to	O
the	O
correct	O
dimension	O
,	O
so	O
can	O
check	O
it	O
,	O
but	O
it	O
would	O
be	O
nice	O
to	O
only	O
use	O
the	O
length	O
of	O
`	O
indices	N
`	O
to	O
determine	O
it	O
.	O

Alternatively	O
,	O
what	O
about	O
applying	O
the	O
same	O
function	O
without	O
indices	N
along	O
the	O
depth	O
axes	O
?	O

Here's	O
an	O
O	O
(	O
n	O
log	N
n	O
)	O
algorithm	O
for	O
your	O
problem	O
.	O

You	O
need	O
to	O
add	O
axes	O
to	O
`	O
coeffs	O
`	O
so	O
it	O
will	O
broadcast	N
in	O
the	O
dimension	O
(	O
s	O
)	O
you	O
want	O
.	O

If	O
you	O
want	O
to	O
search	O
for	O
a	O
certain	O
rank	O
on	O
B	O
randomly	O
,	O
you	O
need	O
to	O
start	O
off	O
with	O
a	O
valid	O
B	O
with	O
max	N
rank	O
,	O
and	O
rotate	O
a	O
random	O
column	O
j	O
of	O
a	O
random	O
B	O
i	O
by	O
a	O
random	O
amount	O
.	O

I	O
want	O
to	O
save	O
some	O
histogram	N
data	O
in	O
a	O
csv	O
file	O
.	O

I	O
want	O
to	O
read	O
a	O
mat	N
file	O
back	O
in	O
python	O
but	O
I	O
have	O
trouble	O
going	O
back	O
to	O
a	O
graph	O
,	O
because	O
the	O
mat	N
file	O
gives	O
a	O
numpy.ndarray	B-API
type	O
file	O
and	O
I	O
need	O
a	O
sparse	O
matrix	O
to	O
reconstruct	O
my	O
graph	O
.	O

numpy	O
makes	O
it	O
easy	O
to	O
translate	N
python	O
objects	O
into	O
numpy	O
ndarrays	O
,	O
and	O
will	O
even	O
pick	O
an	O
appropriate	O
resulting	O
data	O
type	O
if	O
one	O
is	O
not	O
specified	O
:	O
#CODE	O

This	O
`	O
T	O
`	O
and	O
`	O
X	O
`	O
broadcast	N
together	O
just	O
fine	O
,	O
for	O
example	O
`	O
T*X	O
`	O
works	O
.	O

I	O
assume	O
the	O
number	O
produced	O
in	O
exp	B-API
is	O
too	O
big	O
to	O
fit	O
in	O
a	O
`	O
float64	O
`	O
.	O

I	O
have	O
a	O
numpy	O
matrix	O
A	O
and	O
I	O
need	O
a	O
function	O
that	O
will	O
count	O
(	O
A	O
[	O
i	O
,	O
j	O
]	O
/	O
sum	B-API
of	O
all	O
elements	O
in	O
i-th	O
column	O
)	O
-	O
A	O
[	O
i	O
,	O
j	O
]	O
/	O
sum	B-API
of	O
all	O
elements	O
in	O
j-th	O
row	O

This	O
also	O
works	O
if	O
,	O
instead	O
of	O
a	O
single	O
index	O
,	O
you	O
provide	O
an	O
array	O
of	O
indices	N
:	O
#CODE	O

How	O
to	O
solve	O
nonlinear	O
equation	O
without	O
sympy	O
(	O
max	N
and	O
min	N
)	O
?	O

Bivariate	O
Legendre	N
Polynomial	N
Fitting	O
to	O
find	O
orthogonal	O
coefficents	O

For	O
numpy	O
this	O
list	O
includes	O
'	O
linalg	Y
'	O
,	O
'	O
fft	B-API
'	O
,	O
'	O
random	Y
'	O
,	O
'	O
ctypeslib	Y
'	O
,	O
'	O
ma	Y
'	O
,	O
and	O
'	O
doc	O
'	O
last	O
I	O
checked	O
.	O

I	O
have	O
a	O
big	O
n-square	O
diagonal	N
matrix	O
,	O
in	O
the	O
scipy's	O
sparse	O
DIA	O
format	O

To	O
find	O
the	O
most	O
frequent	O
value	O
of	O
a	O
flat	O
array	O
,	O
use	O
`	O
unique	B-API
`	O
,	O
`	O
bincount	B-API
`	O
and	O
`	O
argmax	B-API
`	O
:	O
#CODE	O

The	O
funny	O
thing	O
is	O
in	O
the	O
above	O
function	O
If	O
i	O
pass	O
an	O
extra	O
argument	O
and	O
just	O
divide	O
sum	N
by	O
it	O
,	O
then	O
the	O
times	O
are	O
the	O
same	O
again	O
.	O

are	O
the	O
same	O
as	O
the	O
ones	N
posted	O
in	O
the	O
examples	O
of	O
this	O
web	O
page	O
.	O

How	O
to	O
remove	O
rings	O
from	O
convolve	N
healpix	O
map	O
?	O

With	O
the	O
information	O
of	O
the	O
full	O
stack	N
trace	O
report	O
the	O
bug	O
to	O
the	O
ubuntu	O
team	O
.	O

fastest	O
way	O
to	O
get	O
lookup	O
table	O
indices	N
with	O
numpy	O

Well	O
,	O
a	O
few	O
more	O
,	O
anyway	O
:	O
`	O
cos	B-API
`	O
,	O
`	O
pi	O
`	O
,	O
`	O
diag	B-API
`	O

I	O
implemented	O
a	O
LOWESS	O
smoother	O
(	O
which	O
is	O
the	O
curve	O
you	O
see	O
)	O
with	O
a	O
tight	O
fit	O
to	O
eliminate	O
noise	O
,	O
since	O
the	O
real	O
waveforms	O
have	O
a	O
non-trivial	O
noise	O
component	O
,	O
and	O
then	O
tried	O
doing	O
a	O
rolling	O
max	N
with	O
a	O
window	O
over	O
the	O
data	O
,	O
but	O
I	O
can't	O
get	O
anything	O
solid	O
.	O

But	O
sum	B-API
function	O
from	O
numpy	O
doesn't	O
suport	O
"	O
1:3	O
"	O

(	O
the	O
`	O
np.nonzero	B-API
`	O
should	O
return	O
a	O
tuple	O
with	O
one	O
element	O
,	O
an	O
array	O
of	O
indices	N
)	O
.	O

Can	O
the	O
"	O
small	O
values	O
of	O
derivative	O
"	O
be	O
small	O
with	O
respect	O
to	O
the	O
sin	N
curve	O
?	O

6	O
columns	O
,	O
92370574	O
rows	O
,	O
2496502	O
locations	O
,	O
37	O
months	O
each	O
,	O
unique	N
amounts	O
for	O
each	O
value	O
.	O

Note	O
that	O
where	O
possible	O
,	O
`	O
reshape	B-API
`	O
will	O
give	O
you	O
a	O
view	O
of	O
the	O
array	O
.	O

Here	O
you	O
append	N
only	O
a	O
REFERENCE	O
to	O
your	O
only	O
one	O
existing	O
`	O
energy	O
`	O
array	O
.	O

And	O
you	O
can	O
combine	O
the	O
summation	O
and	O
multiplication	O
into	O
a	O
dot	N
product	O
:	O
#CODE	O

For	O
example	O
,	O
`	O
a	O
`	O
is	O
generated	O
from	O
`	O
a	O
=	O
z	O
[	O
z	O
!	O
=0	O
]`	O
;	O
`	O
a	O
`	O
then	O
changes	O
through	O
some	O
processing	O
,	O
and	O
now	O
I	O
need	O
to	O
insert	O
`	O
nan	O
`	O
s	O
where	O
there	O
were	O
originally	O
zeros	N
.	O

I	O
frequently	O
use	O
the	O
numpy.where	B-API
function	O
to	O
gather	O
a	O
tuple	O
of	O
indices	N
of	O
a	O
matrix	O
having	O
some	O
property	O
.	O

I	O
suspect	O
the	O
original	O
formula	O
was	O
right	O
but	O
you	O
didn't	O
encode	N
it	O
right	O
in	O
Python	O
.	O

This	O
gets	O
me	O
the	O
sum	N
of	O
all	O
red	O
combined	O
in	O
original	O
-	O
all	O
red	O
combined	O
in	O
mutated	O
.	O

`	O
p2	O
=	O
einsum	B-API
(	O
'	O
nk	O
,	O
nk	O
->	O
n	O
'	O
,	O
p1	O
,	O
delta	O
)`	O
is	O
the	O
pairwise	O
dot	N
product	O
of	O
the	O
rows	O
of	O
`	O
p1	O
`	O
and	O
`	O
delta	O
`	O
.	O

I	O
did	O
the	O
reshape	B-API
,	O
just	O
so	O
that	O
both	O
arrays	O
are	O
same	O
shape	O
,	O
but	O
I	O
do	O
not	O
think	O
you	O
really	O
need	O
the	O
reshaping	O
,	O
with	O
the	O
list	O
comprehension	O
the	O
shape	O
of	O
array	O
you	O
get	O
is	O
`	O
(	O
length	O
of	O
string	O
,	O
)`	O

I	O
made	O
a	O
typo	O
in	O
the	O
norm	B-API
,	O
fixed	O
now	O
.	O

Also	O
,	O
I	O
expect	O
the	O
positions	O
of	O
the	O
zeros	N
to	O
be	O
relatively	O
sparse	O
(	O
~1%	O
of	O
all	O
bit	O
positions	O
)	O
.	O

Slicing	O
arrays	O
with	O
meshgrid	B-API
/	O
array	O
indices	N
in	O
Numpy	O

(	O
An	O
nonzero	N
exit	O
status	O
usually	O
indicates	O
an	O
error	O
on	O
Unix	O
style	O
systems	O
.	O
A	O
couple	O
programs	O
are	O
different	O
,	O
e.g.	O
,	O
`	O
diff	B-API
`	O
.	O
)	O
Try	O
examining	O
the	O
`	O
stderr	O
`	O
produced	O
by	O
the	O
subprocess	O
to	O
see	O
what	O
error	O
messages	O
are	O
printed	O
there	O
.	O

To	O
achieve	O
exactly	O
what	O
you	O
are	O
asking	O
for	O
I	O
would	O
apply	O
a	O
`	O
[	O
3x3	O
]`	O
box-filter	O
on	O
the	O
image	O
and	O
than	O
I	O
would	O
resize	N
the	O
matrix	O
using	O
nearest	O
neighbor	O
interpolation	O
.	O

Is	O
there	O
a	O
quick	O
way	O
to	O
reshape	N
my	O
`	O
csr_matrix	O
`	O
without	O
copying	O
everything	O
in	O
it	O
?	O

The	O
catch	O
is	O
that	O
I	O
need	O
to	O
keep	O
the	O
colors	O
exactly	O
the	O
way	O
they	O
are	O
(	O
background	O
:	O
I'm	O
resizing	O
a	O
map	O
where	O
provinces	O
are	O
color-coded	O
)	O
,	O
and	O
so	O
I	O
cannot	O
just	O
perform	O
a	O
resize	N
with	O
bicubic	O
interpolation	O
,	O
because	O
that	O
will	O
also	O
interpolate	O
the	O
pixel	O
colors	O
while	O
smoothing	O
.	O

You	O
should	O
"	O
flatten	N
"	O
the	O
array	O
of	O
arrays	O
first	O
.	O
unfortunately	O
,	O
there's	O
no	O
builtin	O
method	O
,	O
see	O
#URL	O

then	O
concatenate	N
the	O
saved	O
objects	O
whit	O
this	O
code	O
:	O
#CODE	O

For	O
something	O
like	O
a	O
dot	N
product	O
,	O
pandas	O
`	O
DataFrames	Y
`	O
are	O
generally	O
going	O
to	O
be	O
slower	O
than	O
a	O
numpy	O
array	O
since	O
pandas	O
is	O
doing	O
**	O
a	O
lot	O
more	O
stuff	O
**	O
aligning	O
labels	O
,	O
potentially	O
dealing	O
with	O
heterogenous	O
types	O
,	O
and	O
so	O
on	O
.	O

I	O
want	O
to	O
pass	O
an	O
array	O
of	O
indices	N
and	O
column	O
names	O
and	O
get	O
a	O
list	O
of	O
objects	O
that	O
are	O
found	O
in	O
the	O
corresponding	O
index	O
and	O
column	O
name	O
.	O

From	O
this	O
you	O
would	O
expect	O
the	O
total	O
sum	N
to	O
be	O
`	O
100,679,697	O
=	O
200*	O
(	O
1,000,000	O
-	O
499,097	O
)	O
+	O
499,097	O
`	O

The	O
histogram	N
way	O
is	O
not	O
the	O
fastest	O
,	O
and	O
can't	O
tell	O
the	O
difference	O
between	O
an	O
arbitrarily	O
small	O
separation	O
of	O
points	O
and	O
`	O
2	O
*	O
sqrt	B-API
(	O
2	O
)	O
*	O
b	O
`	O
(	O
where	O
`	O
b	O
`	O
is	O
bin	O
width	O
)	O
.	O

}	O
for	O
n=1	O
,	O
2	O
,	O
3	O
,	O
4	O
,	O
5	O
,	O
6	O
(	O
using	O
Sum	B-API
(	O
c_n	O
exp	B-API
(	O
i	O
2	O
pi	O
n	O
x	O
)	O
)	O
as	O
Fourier	O
series	O
)	O
.	O

I	O
think	O
I	O
can	O
t	O
just	O
simple	O
sum	N
the	O
"	O
seq	O
*	O
"	O
array	O
,	O
because	O
instead	O
of	O
a	O
chord	O
I	O
will	O
get	O
noise	O
.	O

I	O
presume	O
you	O
want	O
to	O
transpose	N
first	O
:	O
#CODE	O

Oh	O
,	O
that's	O
interesting	O
you	O
can	O
do	O
it	O
with	O
stack	B-API
.	O

In	O
this	O
case	O
,	O
using	O
numpy	O
outer	B-API
operations	O
allow	O
you	O
to	O
compute	O
the	O
multiplications	O
and	O
sums	O
at	O
the	O
`	O
C	O
`	O
loop	O
speed	O
.	O

The	O
most	O
efficient	O
way	O
is	O
likely	O
to	O
use	O
'	O
np.empty()	B-API
'	O
to	O
allocate	O
the	O
space	O
/	O
memory	O
for	O
your	O
end	O
dataset	O
and	O
then	O
load	O
data	O
&	O
broadcast	N
within	O
that	O
using	O
slice	O
indexing	O
.	O

Ok	O
,	O
with	O
your	O
histogram	N
I	O
get	O
at	O
least	O
the	O
total	O
number	O
of	O
each	O
pair	O
.	O

This	O
is	O
because	O
python's	O
sum	B-API
is	O
basically	O
summing	O
a	O
for	O
loop	O
over	O
the	O
object	O
.	O

Then	O
the	O
entire	O
shape	O
changes	O
from	O
(	O
x	O
,	O
y	O
)	O
to	O
merely	O
(	O
x	O
,	O
)	O
and	O
I	O
get	O
'	O
too	O
many	O
indices	N
'	O
errors	O
when	O
I	O
try	O
to	O
use	O
masks	O
.	O

If	O
reps	O
has	O
length	O
d	O
,	O
the	O
result	O
will	O
have	O
dimension	O
of	O
max	B-API
(	O
d	O
,	O
A.ndim	O
)	O
.	O

I	O
want	O
to	O
do	O
this	O
by	O
dividing	O
each	O
histogram	N
by	O
its	O
maximum	O
value	O
so	O
all	O
the	O
distributions	O
have	O
the	O
same	O
scale	O
.	O

An	O
obvious	O
path	O
would	O
be	O
to	O
transpose	N
the	O
array	O
so	O
that	O
the	O
indices	N
that	O
I	O
am	O
selecting	O
would	O
come	O
up	O
first	O
.	O

Now	O
,	O
for	O
mean	O
calculations	O
,	O
those	O
numeric	O
IDs	N
could	O
be	O
used	O
as	O
`"	O
weights	O
"`	O
for	O
binning	O
with	O
`	O
np.bincount	B-API
`	O
,	O
giving	O
us	O
the	O
sum	N
of	O
data	O
elements	O
corresponding	O
to	O
each	O
`	O
ID	O
`	O
.	O

However	O
,	O
what	O
I	O
need	O
is	O
a	O
string	O
containing	O
all	O
the	O
elements	O
in	O
the	O
list	O
linked	O
by	O
'	O
;	O
'	O
,	O
not	O
the	O
list	O
itself	O
,	O
so	O
it	O
seems	O
like	O
I	O
have	O
to	O
sum	N
all	O
the	O
elements	O
in	O
asString	O
with	O
another	O
iteration	O
?	O

the	O
output	O
I	O
need	O
:	O
`	O
S	O
=	O
[	O
2	O
,	O
5	O
,	O
8	O
,	O
11	O
,	O
14	O
]`	O
I	O
thought	O
something	O
like	O
:	O
`	O
S1	O
=	O
np.array	B-API
(	O
L	O
[:	O
]	O
[	O
1	O
,	O
0	O
])`	O
should	O
work	O
but	O
whatever	O
I	O
try	O
I	O
have	O
the	O
error	O
like	O
:	O
`	O
TypeError	O
:	O
list	O
indices	N
must	O
be	O
integers	O
,	O
not	O
tuple	O
`	O
.	O

I	O
need	O
it	O
because	O
in	O
the	O
next	O
part	O
I	O
will	O
sum	N
up	O
this	O
large	O
np.array	B-API
with	O
some	O
delta_array	O
that	O
has	O
the	O
same	O
shape	O
.	O

Used	O
reshape	B-API
to	O
make	O
rows	O
into	O
columns	O
.	O

I	O
understand	O
that	O
you	O
could	O
create	O
an	O
array	O
of	O
zeros	N
and	O
iteratively	O
change	O
the	O
values	O
in	O
each	O
column	O
,	O
but	O
I	O
also	O
understand	O
this	O
is	O
not	O
an	O
efficient	O
method	O
.	O

I'm	O
trying	O
to	O
implement	O
the	O
univariate	O
gradient	N
descent	O
algorithm	O
in	O
python	O
.	O

numpy	O
glossary	O
says	O
the	O
sum	N
along	O
axis	O
argument	O
`	O
axis=1	O
`	O
sums	O
over	O
rows	O
:	O
"	O
we	O
can	O
sum	N
each	O
row	O
of	O
an	O
array	O
,	O
in	O
which	O
case	O
we	O
operate	O
along	O
columns	O
,	O
or	O
axis	O
1	O
"	O
.	O

It	O
also	O
prints	O
out	O
the	O
new	O
indices	N
signature	O
.	O

At	O
first	O
,	O
your	O
`	O
result	O
`	O
does	O
not	O
look	O
like	O
a	O
complex	O
FFT	B-API
output	O
,	O
because	O
you	O
calculated	O
the	O
absolute	N
values	O
of	O
the	O
FFT	B-API
.	O

When	O
you	O
do	O
fft	B-API
the	O
frequencies	O
ranges	O
from	O
-pi	O
/	O
timestep	O
to	O
pi	O
/	O
timestep	O
(	O
assuming	O
that	O
frequency	O
is	O
defined	O
as	O
w	O
=	O
2*pi	O
/	O
t	O
,	O
change	O
the	O
values	O
accordingly	O
if	O
you	O
use	O
f	O
=1	O
/	O
t	O
representation	O
)	O
.	O

debug	O
performance	O
diff	B-API
of	O
Same	O
code	O
on	O
nearly	O
same	O
cpu	O
/	O
ram	O

The	O
HTML	O
file	O
generated	O
by	O
Cython	O
indicates	O
that	O
the	O
bottleneck	O
is	O
the	O
dot	N
products	O
(	O
which	O
is	O
expected	O
of	O
course	O
)	O
.	O

`	O
numpy.unique	B-API
`	O
with	O
`	O
return_index=True	O
`	O
will	O
give	O
you	O
a	O
list	O
of	O
indices	N
to	O
take	O
from	O
.	O

I	O
forgot	O
exactly	O
why	O
,	O
but	O
there	O
is	O
a	O
good	O
reason	O
why	O
you	O
calculate	O
it	O
as	O
the	O
ratio	O
between	O
these	O
two	O
averages	O
,	O
instead	O
of	O
directly	O
averaging	O
`	O
fft	B-API
(	O
y	O
)	O
/	O
fft	B-API
(	O
x	O
)`	O
.	O

Do	O
you	O
really	O
want	O
this	O
'	O
roll	B-API
'	O
?	O

By	O
adding	O
a	O
nonzero	N
number	O
at	O
the	O
end	O
of	O
the	O
array	O
,	O
you	O
can	O
still	O
use	O
np.nonzero	B-API
to	O
get	O
your	O
desired	O
outcome	O
.	O

which	O
simply	O
sorts	O
the	O
terms	O
and	O
then	O
takes	O
the	O
ones	N
which	O
aren't	O
equal	O
to	O
the	O
previous	O
one	O
.	O

4	O
:	O
I	O
am	O
not	O
sure	O
about	O
the	O
indices	N
,	O
by	O
writing	O
couple	O
of	O
code	O
lines	O
I	O
just	O
able	O
to	O
get	O
cluster	O
indices	N
based	O
on	O
fclusterdata	O
.	O

Matlab	O
gives	O
me	O
a	O
norm	N
=	O
2	O
for	O
your	O
matrix	O
.	O

I	O
first	O
generated	O
a	O
labelled	O
array	O
of	O
unique	N
IDs	N
for	O
each	O
discrete	O
region	O
,	O
calculated	O
sizes	O
for	O
each	O
ID	O
,	O
masked	O
the	O
size	O
array	O
to	O
focus	O
only	O
on	O
size	O
==	O
1	O
blobs	O
,	O
then	O
index	O
the	O
original	O
array	O
and	O
set	O
IDs	N
with	O
a	O
size	O
==	O
1	O
to	O
0	O
:	O
#CODE	O

absolute	B-API
(	O
a	O
-	O
b	O
)	O
=	O
(	O
atol	O
+	O
rtol	O
*	O
absolute	B-API
(	O
b	O
))	O

Then	O
I	O
reshape	N
this	O
to	O
form	O
a	O
2D	O
numpy	O
array	O
.	O

n=5	O
(	O
min	N
length	O
of	O
sequence	O
)	O

I	O
have	O
written	O
a	O
function	O
which	O
contains	O
nested	O
loops	O
and	O
a	O
conditional	O
statement	O
;	O
the	O
purpose	O
of	O
the	O
loop	O
is	O
to	O
return	O
a	O
list	O
of	O
indices	N
for	O
the	O
nearest	O
elements	O
in	O
array	O
x	O
when	O
compared	O
to	O
array	O
y	O
.	O

I	O
also	O
want	O
to	O
color	O
the	O
1D	O
histogram	N
bars	O
according	O
to	O
the	O
same	O
normalization	O
.	O

If	O
you	O
are	O
calling	O
it	O
with	O
an	O
empty	O
matrix	O
for	O
[	O
low	O
,	O
high	O
]	O
it	O
will	O
just	O
use	O
whatever	O
the	O
max	N
and	O
min	N
values	O
in	O
the	O
array	O
are	O
.	O

Creating	O
a	O
class	O
deriving	O
from	O
`	O
ndarray	B-API
`	O
and	O
overriding	O
indexing	O
such	O
that	O
the	O
absolute	N
indices	N
are	O
used	O
.	O

One	O
solution	O
is	O
to	O
sort	O
both	O
arrays	O
(	O
adding	O
an	O
index	O
column	O
so	O
that	O
the	O
sorted	O
arrays	O
still	O
contains	O
the	O
original	O
indices	N
)	O
.	O

Use	O
`	O
reshape	B-API
`	O
:	O
#CODE	O

What's	O
wrong	O
with	O
the	O
normal	O
div	O
/	O
mod	N
operations	O
?	O

You	O
can	O
use	O
`	O
argmin	B-API
`	O
to	O
find	O
the	O
False	O
values	O
,	O
and	O
this	O
will	O
be	O
faster	O
and	O
take	O
less	O
memory	O
than	O
using	O
nonzero	B-API
,	O
but	O
this	O
is	O
linear	O
in	O
the	O
length	O
of	O
`	O
a	O
`	O
.	O

I'd	O
like	O
it	O
to	O
be	O
like	O
8x10^8	O
or	O
.8x10	O
^9	O
to	O
save	O
space	O
instead	O
of	O
putting	O
all	O
those	O
zeros	N
.	O

The	O
one	O
I	O
pointed	O
out	O
in	O
a	O
comment	O
to	O
other	O
answer	O
as	O
to	O
encode	N
the	O
binary	O
representation	O
of	O
the	O
array	O
as	O
a	O
Base64	O
text	O
block	O
.	O

due	O
to	O
broadcasting	O
,	O
you	O
don't	O
need	O
to	O
repeat	O
duplicate	O
indices	N
,	O
thus	O
:	O
#CODE	O

Maybe	O
`	O
flatten()	B-API
`	O
the	O
original	O
array	O
,	O
then	O
use	O
your	O
1D	O
solution	O
,	O
finally	O
calculate	O
the	O
real	O
nD	O
indices	N
using	O
the	O
original	O
shape	O
?	O